(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __pow = Math.pow;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // (disabled):node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "(disabled):node_modules/buffer/index.js"() {
    }
  });

  // node_modules/ton/node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "node_modules/ton/node_modules/bn.js/lib/bn.js"(exports, module) {
      (function(module2, exports2) {
        "use strict";
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number, base, endian) {
          if (BN2.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = require_buffer().Buffer;
          }
        } catch (e) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN2.prototype._init = function init(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN2.prototype._initArray = function _initArray(number, base, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string, index) {
          var c = string.charCodeAt(index);
          if (c >= 48 && c <= 57) {
            return c - 48;
          } else if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            assert(false, "Invalid character in " + string);
          }
        }
        function parseHexByte(string, lowerBound, index) {
          var r = parseHex4Bits(string, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string, index - 1) << 4;
          }
          return r;
        }
        BN2.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var b = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              b = c - 49 + 10;
            } else if (c >= 17) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            assert(c >= 0 && b < mul, "Invalid character");
            r += b;
          }
          return r;
        }
        BN2.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN2.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words;
          dest.length = src.length;
          dest.negative = src.negative;
          dest.red = src.red;
        }
        BN2.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN2.prototype.clone = function clone() {
          var r = new BN2(null);
          this.copy(r);
          return r;
        };
        BN2.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
          } catch (e) {
            BN2.prototype.inspect = inspect;
          }
        } else {
          BN2.prototype.inspect = inspect;
        }
        function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modrn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16, 2);
        };
        if (Buffer2) {
          BN2.prototype.toBuffer = function toBuffer(endian, length) {
            return this.toArrayLike(Buffer2, endian, length);
          };
        }
        BN2.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType, size) {
          if (ArrayType.allocUnsafe) {
            return ArrayType.allocUnsafe(size);
          }
          return new ArrayType(size);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          this._strip();
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert(byteLength <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength);
          return res;
        };
        BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
          var position = 0;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
          var position = res.length - 1;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 1;
          }
          return w;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN2.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this._strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this._strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN2.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN2.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out._strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN2(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this._strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this._strip();
          assert(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div2, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div2 = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div: div2,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div2 = res.div.neg();
            }
            return {
              div: div2,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div2(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN2.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN2.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN2.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN2(1);
          var x2 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          move(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN2(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN2(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN2(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // node_modules/symbol.inspect/index.js
  var require_symbol = __commonJS({
    "node_modules/symbol.inspect/index.js"(exports, module) {
      "use strict";
      var SymbolInspect = Symbol.for("nodejs.util.inspect.custom");
      module.exports = SymbolInspect;
    }
  });

  // node_modules/ton/dist/boc/BitString.js
  var require_BitString = __commonJS({
    "node_modules/ton/dist/boc/BitString.js"(exports) {
      "use strict";
      var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _BitString_instances;
      var _BitString_length;
      var _BitString_cursor;
      var _BitString_buffer;
      var _BitString_checkRange;
      var _a;
      var _b;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BitString = void 0;
      var bn_js_1 = __importDefault(require_bn());
      var symbol_inspect_1 = __importDefault(require_symbol());
      var __1 = require_dist2();
      var BitString = class {
        constructor(buffer, length, cursor) {
          _BitString_instances.add(this);
          _BitString_length.set(this, void 0);
          _BitString_cursor.set(this, void 0);
          _BitString_buffer.set(this, void 0);
          this[_a] = () => {
            let offset = 0;
            let end = __classPrivateFieldGet(this, _BitString_cursor, "f");
            return {
              next: () => {
                if (offset < end) {
                  let v = this.get(offset);
                  offset++;
                  return {
                    done: false,
                    value: v
                  };
                } else {
                  return {
                    done: true
                  };
                }
              }
            };
          };
          this.get = (n) => {
            __classPrivateFieldGet(this, _BitString_instances, "m", _BitString_checkRange).call(this, n);
            return (__classPrivateFieldGet(this, _BitString_buffer, "f")[n / 8 | 0] & 1 << 7 - n % 8) > 0;
          };
          this.on = (n) => {
            __classPrivateFieldGet(this, _BitString_instances, "m", _BitString_checkRange).call(this, n);
            __classPrivateFieldGet(this, _BitString_buffer, "f")[n / 8 | 0] |= 1 << 7 - n % 8;
          };
          this.off = (n) => {
            __classPrivateFieldGet(this, _BitString_instances, "m", _BitString_checkRange).call(this, n);
            __classPrivateFieldGet(this, _BitString_buffer, "f")[n / 8 | 0] &= ~(1 << 7 - n % 8);
          };
          this.toggle = (n) => {
            __classPrivateFieldGet(this, _BitString_instances, "m", _BitString_checkRange).call(this, n);
            __classPrivateFieldGet(this, _BitString_buffer, "f")[n / 8 | 0] ^= 1 << 7 - n % 8;
          };
          this.writeBit = (value) => {
            var _c;
            if (value === true || value > 0) {
              this.on(__classPrivateFieldGet(this, _BitString_cursor, "f"));
            } else {
              this.off(__classPrivateFieldGet(this, _BitString_cursor, "f"));
            }
            __classPrivateFieldSet(this, _BitString_cursor, (_c = __classPrivateFieldGet(this, _BitString_cursor, "f"), _c++, _c), "f");
          };
          this.writeUint = (value, bitLength) => {
            let v = new bn_js_1.default(value);
            if (bitLength == 0 || value.toString(2).length > bitLength) {
              if (v.isZero()) {
                return;
              }
              throw Error(`bitLength is too small for a value ${v.toString()}. Got ${bitLength}, expected >= ${value.toString(2).length}`);
            }
            const s = v.toString(2, bitLength);
            for (let i = 0; i < bitLength; i++) {
              this.writeBit(s[i] === "1");
            }
          };
          this.writeInt = (value, bitLength) => {
            let v = new bn_js_1.default(value);
            if (bitLength == 1) {
              if (v.eq(new bn_js_1.default(-1))) {
                this.writeBit(true);
                return;
              }
              if (v.isZero()) {
                this.writeBit(false);
                return;
              }
              throw Error(`bitlength is too small for a value ${v}`);
            } else {
              if (v.isNeg()) {
                this.writeBit(true);
                const b = new bn_js_1.default(2);
                const nb = b.pow(new bn_js_1.default(bitLength - 1));
                this.writeUint(nb.add(v), bitLength - 1);
              } else {
                this.writeBit(false);
                this.writeUint(v, bitLength - 1);
              }
            }
          };
          this.writeUint8 = (value) => {
            this.writeUint(value, 8);
          };
          this.writeBuffer = (buffer2) => {
            for (let i = 0; i < buffer2.length; i++) {
              this.writeUint8(buffer2[i]);
            }
          };
          this.writeCoins = (amount) => {
            if (amount == 0) {
              this.writeUint(0, 4);
            } else {
              amount = new bn_js_1.default(amount);
              const l = Math.ceil(amount.toString(16).length / 2);
              this.writeUint(l, 4);
              this.writeUint(amount, l * 8);
            }
          };
          this.writeAddress = (address) => {
            if (address === null) {
              this.writeUint(0, 2);
            } else {
              this.writeUint(2, 2);
              this.writeUint(0, 1);
              this.writeInt(address.workChain, 8);
              this.writeBuffer(address.hash);
            }
          };
          this.writeBitString = (value) => {
            for (let v of value) {
              this.writeBit(v);
            }
          };
          this[_b] = () => this.toFiftHex();
          __classPrivateFieldSet(this, _BitString_buffer, buffer, "f");
          __classPrivateFieldSet(this, _BitString_length, length, "f");
          __classPrivateFieldSet(this, _BitString_cursor, cursor, "f");
        }
        static alloc(length) {
          return new BitString(Buffer.alloc(Math.ceil(length / 8), 0), length, 0);
        }
        get available() {
          return this.length - this.cursor;
        }
        get length() {
          return __classPrivateFieldGet(this, _BitString_length, "f");
        }
        get cursor() {
          return __classPrivateFieldGet(this, _BitString_cursor, "f");
        }
        get buffer() {
          return __classPrivateFieldGet(this, _BitString_buffer, "f");
        }
        writeBitArray(value) {
          for (let v of value) {
            this.writeBit(v);
          }
        }
        writeVarUInt(value, headerBits) {
          let v = new bn_js_1.default(value);
          if (v.eq(new bn_js_1.default(0))) {
            this.writeUint(0, headerBits);
          } else {
            let h = v.toString("hex");
            while (h.length % 2 !== 0) {
              h = "0" + h;
            }
            const l = Math.ceil(h.length / 2);
            this.writeUint(l, headerBits);
            this.writeBuffer(Buffer.from(h, "hex"));
          }
        }
        clone() {
          let buf = Buffer.alloc(__classPrivateFieldGet(this, _BitString_buffer, "f").length);
          __classPrivateFieldGet(this, _BitString_buffer, "f").copy(buf);
          return new BitString(buf, __classPrivateFieldGet(this, _BitString_length, "f"), __classPrivateFieldGet(this, _BitString_cursor, "f"));
        }
        toString() {
          let res = "";
          for (let v of this) {
            if (v) {
              res = res + "1";
            } else {
              res = res + "0";
            }
          }
          return res;
        }
        toFiftHex() {
          if (this.cursor % 4 === 0) {
            const s = __classPrivateFieldGet(this, _BitString_buffer, "f").slice(0, Math.ceil(this.cursor / 8)).toString("hex").toUpperCase();
            if (this.cursor % 8 === 0) {
              return s;
            } else {
              return s.substr(0, s.length - 1);
            }
          } else {
            const temp = this.clone();
            temp.writeBit(1);
            while (temp.cursor % 4 !== 0) {
              temp.writeBit(0);
            }
            const hex = temp.toFiftHex().toUpperCase();
            return hex + "_";
          }
        }
        setTopUppedArray(array, fullfilledBytes = true) {
          __classPrivateFieldSet(this, _BitString_length, array.length * 8, "f");
          __classPrivateFieldSet(this, _BitString_buffer, Buffer.alloc(array.length), "f");
          array.copy(__classPrivateFieldGet(this, _BitString_buffer, "f"));
          __classPrivateFieldSet(this, _BitString_cursor, this.length, "f");
          if (fullfilledBytes || !this.length) {
            return;
          } else {
            let foundEndBit = false;
            for (let c = 0; c < 7; c++) {
              __classPrivateFieldSet(this, _BitString_cursor, __classPrivateFieldGet(this, _BitString_cursor, "f") - 1, "f");
              if (this.get(this.cursor)) {
                foundEndBit = true;
                this.off(this.cursor);
                break;
              }
            }
            if (!foundEndBit) {
              throw new Error("Incorrect TopUppedArray");
            }
          }
        }
        getTopUppedArray() {
          const ret = this.clone();
          let tu = Math.ceil(ret.cursor / 8) * 8 - ret.cursor;
          if (tu > 0) {
            tu = tu - 1;
            ret.writeBit(true);
            while (tu > 0) {
              tu = tu - 1;
              ret.writeBit(false);
            }
          }
          __classPrivateFieldSet(ret, _BitString_buffer, __classPrivateFieldGet(ret, _BitString_buffer, "f").slice(0, Math.ceil(ret.cursor / 8)), "f");
          return __classPrivateFieldGet(ret, _BitString_buffer, "f");
        }
        equals(src) {
          if (src.cursor !== this.cursor) {
            return false;
          }
          if (src.length !== this.length) {
            return false;
          }
          let sr = new __1.BitStringReader(src);
          let tr = new __1.BitStringReader(this);
          for (let i = 0; i < src.cursor; i++) {
            if (sr.readBit() !== tr.readBit()) {
              return false;
            }
          }
          return true;
        }
      };
      exports.BitString = BitString;
      _BitString_length = /* @__PURE__ */ new WeakMap(), _BitString_cursor = /* @__PURE__ */ new WeakMap(), _BitString_buffer = /* @__PURE__ */ new WeakMap(), _BitString_instances = /* @__PURE__ */ new WeakSet(), _a = Symbol.iterator, _b = symbol_inspect_1.default, _BitString_checkRange = function _BitString_checkRange2(n) {
        if (n > this.length) {
          throw Error("Invalid index: " + n);
        }
      };
    }
  });

  // node_modules/ton/dist/address/AddressExternal.js
  var require_AddressExternal = __commonJS({
    "node_modules/ton/dist/address/AddressExternal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AddressExternal = void 0;
      var AddressExternal = class {
        constructor(bits) {
          this.bits = bits;
        }
      };
      exports.AddressExternal = AddressExternal;
    }
  });

  // node_modules/ton/dist/boc/BitStringReader.js
  var require_BitStringReader = __commonJS({
    "node_modules/ton/dist/boc/BitStringReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BitStringReader = void 0;
      var bn_js_1 = require_bn();
      var __1 = require_dist2();
      var AddressExternal_1 = require_AddressExternal();
      var BitStringReader = class {
        constructor(string) {
          this.offset = 0;
          let r = Buffer.alloc(string.buffer.length);
          string.buffer.copy(r);
          this.buffer = r;
          this.length = string.cursor;
        }
        get currentOffset() {
          return this.offset;
        }
        get remaining() {
          return this.length - this.offset;
        }
        skip(bits) {
          for (let i = 0; i < bits; i++) {
            this.readBit();
          }
        }
        readUint(bits) {
          if (bits == 0) {
            return new bn_js_1.BN(0);
          }
          let res = "";
          for (let i = 0; i < bits; i++) {
            res += this.readBit() ? "1" : "0";
          }
          return new bn_js_1.BN(res, 2);
        }
        readUintNumber(bits) {
          return this.readUint(bits).toNumber();
        }
        readInt(bits) {
          if (bits === 0) {
            return new bn_js_1.BN(0);
          }
          if (bits === 1) {
            if (this.readBit()) {
              return new bn_js_1.BN(-1);
            } else {
              return new bn_js_1.BN(0);
            }
          }
          if (this.readBit()) {
            let base = this.readUint(bits - 1);
            const b = new bn_js_1.BN(2);
            const nb = b.pow(new bn_js_1.BN(bits - 1));
            return base.sub(nb);
          } else {
            return this.readUint(bits - 1);
          }
        }
        readIntNumber(bits) {
          return this.readInt(bits).toNumber();
        }
        readBuffer(size) {
          let res = [];
          for (let i = 0; i < size; i++) {
            res.push(this.readUintNumber(8));
          }
          return Buffer.from(res);
        }
        readBit() {
          let r = this.getBit(this.offset);
          this.offset++;
          return r;
        }
        readCoins() {
          let bytes = this.readUintNumber(4);
          if (bytes === 0) {
            return new bn_js_1.BN(0);
          }
          return new bn_js_1.BN(this.readBuffer(bytes).toString("hex"), "hex");
        }
        readVarUInt(headerBits) {
          let bytes = this.readUintNumber(headerBits);
          if (bytes === 0) {
            return new bn_js_1.BN(0);
          }
          return new bn_js_1.BN(this.readBuffer(bytes).toString("hex"), "hex");
        }
        readVarUIntNumber(headerBits) {
          return this.readVarUInt(headerBits).toNumber();
        }
        readUnaryLength() {
          let res = 0;
          while (this.readBit()) {
            res++;
          }
          return res;
        }
        readRemaining() {
          let res = __1.BitString.alloc(1023);
          while (this.offset < this.length) {
            res.writeBit(this.readBit());
          }
          return res;
        }
        readAddress() {
          let type = this.readUintNumber(2);
          if (type === 0) {
            return null;
          }
          if (type !== 2) {
            throw Error("Only STD address supported");
          }
          return this.readAddressSTD();
        }
        readAddressInternal() {
          let type = this.readUintNumber(2);
          if (type === 2) {
            return this.readAddressSTD();
          } else {
            throw Error("Invalid data");
          }
        }
        readAddressExternal() {
          let type = this.readUintNumber(2);
          if (type === 0) {
            return null;
          } else if (type === 1) {
            return this.readAddressExternalInt();
          } else {
            throw Error("Invalid data");
          }
        }
        readAddressAny() {
          let type = this.readUintNumber(2);
          if (type === 0) {
            return null;
          } else if (type === 2) {
            return this.readAddressSTD();
          } else if (type === 1) {
            return this.readAddressExternal();
          } else if (type === 3) {
            throw Error("Unsupported");
          } else {
            throw Error("Unreachable");
          }
        }
        readAddressExternalInt() {
          let len = this.readUintNumber(9);
          let result = this.readBitString(len);
          return new AddressExternal_1.AddressExternal(result);
        }
        readAddressSTD() {
          if (this.readUintNumber(1) === 0) {
            const wc = this.readIntNumber(8);
            const hash = this.readBuffer(32);
            return new __1.Address(wc, hash);
          } else {
            throw Error("Var Length address not supported");
          }
        }
        readBitString(n) {
          let res = __1.BitString.alloc(1023);
          for (let i = 0; i < n; i++) {
            res.writeBit(this.readBit());
          }
          return res;
        }
        getBit(n) {
          if (n >= this.length || n < 0) {
            throw Error("Out of range");
          }
          return (this.buffer[n / 8 | 0] & 1 << 7 - n % 8) > 0;
        }
      };
      exports.BitStringReader = BitStringReader;
    }
  });

  // node_modules/jssha/dist/sha.js
  var require_sha = __commonJS({
    "node_modules/jssha/dist/sha.js"(exports, module) {
      !function(n, r) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = r() : "function" == typeof define && define.amd ? define(r) : (n = "undefined" != typeof globalThis ? globalThis : n || self).jsSHA = r();
      }(exports, function() {
        "use strict";
        var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        function r(n2, r2, t2, e2) {
          var i2, o2, u2, f2 = r2 || [0], w2 = (t2 = t2 || 0) >>> 3, s2 = -1 === e2 ? 3 : 0;
          for (i2 = 0; i2 < n2.length; i2 += 1)
            o2 = (u2 = i2 + w2) >>> 2, f2.length <= o2 && f2.push(0), f2[o2] |= n2[i2] << 8 * (s2 + e2 * (u2 % 4));
          return { value: f2, binLen: 8 * n2.length + t2 };
        }
        function t(t2, e2, i2) {
          switch (e2) {
            case "UTF8":
            case "UTF16BE":
            case "UTF16LE":
              break;
            default:
              throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
          }
          switch (t2) {
            case "HEX":
              return function(n2, r2, t3) {
                return function(n3, r3, t4, e3) {
                  var i3, o2, u2, f2;
                  if (0 != n3.length % 2)
                    throw new Error("String of HEX type must be in byte increments");
                  var w2 = r3 || [0], s2 = (t4 = t4 || 0) >>> 3, a2 = -1 === e3 ? 3 : 0;
                  for (i3 = 0; i3 < n3.length; i3 += 2) {
                    if (o2 = parseInt(n3.substr(i3, 2), 16), isNaN(o2))
                      throw new Error("String of HEX type contains invalid characters");
                    for (u2 = (f2 = (i3 >>> 1) + s2) >>> 2; w2.length <= u2; )
                      w2.push(0);
                    w2[u2] |= o2 << 8 * (a2 + e3 * (f2 % 4));
                  }
                  return { value: w2, binLen: 4 * n3.length + t4 };
                }(n2, r2, t3, i2);
              };
            case "TEXT":
              return function(n2, r2, t3) {
                return function(n3, r3, t4, e3, i3) {
                  var o2, u2, f2, w2, s2, a2, h2, c2, v2 = 0, A2 = t4 || [0], E2 = (e3 = e3 || 0) >>> 3;
                  if ("UTF8" === r3)
                    for (h2 = -1 === i3 ? 3 : 0, f2 = 0; f2 < n3.length; f2 += 1)
                      for (u2 = [], 128 > (o2 = n3.charCodeAt(f2)) ? u2.push(o2) : 2048 > o2 ? (u2.push(192 | o2 >>> 6), u2.push(128 | 63 & o2)) : 55296 > o2 || 57344 <= o2 ? u2.push(224 | o2 >>> 12, 128 | o2 >>> 6 & 63, 128 | 63 & o2) : (f2 += 1, o2 = 65536 + ((1023 & o2) << 10 | 1023 & n3.charCodeAt(f2)), u2.push(240 | o2 >>> 18, 128 | o2 >>> 12 & 63, 128 | o2 >>> 6 & 63, 128 | 63 & o2)), w2 = 0; w2 < u2.length; w2 += 1) {
                        for (s2 = (a2 = v2 + E2) >>> 2; A2.length <= s2; )
                          A2.push(0);
                        A2[s2] |= u2[w2] << 8 * (h2 + i3 * (a2 % 4)), v2 += 1;
                      }
                  else
                    for (h2 = -1 === i3 ? 2 : 0, c2 = "UTF16LE" === r3 && 1 !== i3 || "UTF16LE" !== r3 && 1 === i3, f2 = 0; f2 < n3.length; f2 += 1) {
                      for (o2 = n3.charCodeAt(f2), true === c2 && (o2 = (w2 = 255 & o2) << 8 | o2 >>> 8), s2 = (a2 = v2 + E2) >>> 2; A2.length <= s2; )
                        A2.push(0);
                      A2[s2] |= o2 << 8 * (h2 + i3 * (a2 % 4)), v2 += 2;
                    }
                  return { value: A2, binLen: 8 * v2 + e3 };
                }(n2, e2, r2, t3, i2);
              };
            case "B64":
              return function(r2, t3, e3) {
                return function(r3, t4, e4, i3) {
                  var o2, u2, f2, w2, s2, a2, h2 = 0, c2 = t4 || [0], v2 = (e4 = e4 || 0) >>> 3, A2 = -1 === i3 ? 3 : 0, E2 = r3.indexOf("=");
                  if (-1 === r3.search(/^[a-zA-Z0-9=+/]+$/))
                    throw new Error("Invalid character in base-64 string");
                  if (r3 = r3.replace(/=/g, ""), -1 !== E2 && E2 < r3.length)
                    throw new Error("Invalid '=' found in base-64 string");
                  for (o2 = 0; o2 < r3.length; o2 += 4) {
                    for (w2 = r3.substr(o2, 4), f2 = 0, u2 = 0; u2 < w2.length; u2 += 1)
                      f2 |= n.indexOf(w2.charAt(u2)) << 18 - 6 * u2;
                    for (u2 = 0; u2 < w2.length - 1; u2 += 1) {
                      for (s2 = (a2 = h2 + v2) >>> 2; c2.length <= s2; )
                        c2.push(0);
                      c2[s2] |= (f2 >>> 16 - 8 * u2 & 255) << 8 * (A2 + i3 * (a2 % 4)), h2 += 1;
                    }
                  }
                  return { value: c2, binLen: 8 * h2 + e4 };
                }(r2, t3, e3, i2);
              };
            case "BYTES":
              return function(n2, r2, t3) {
                return function(n3, r3, t4, e3) {
                  var i3, o2, u2, f2, w2 = r3 || [0], s2 = (t4 = t4 || 0) >>> 3, a2 = -1 === e3 ? 3 : 0;
                  for (o2 = 0; o2 < n3.length; o2 += 1)
                    i3 = n3.charCodeAt(o2), u2 = (f2 = o2 + s2) >>> 2, w2.length <= u2 && w2.push(0), w2[u2] |= i3 << 8 * (a2 + e3 * (f2 % 4));
                  return { value: w2, binLen: 8 * n3.length + t4 };
                }(n2, r2, t3, i2);
              };
            case "ARRAYBUFFER":
              try {
                new ArrayBuffer(0);
              } catch (n2) {
                throw new Error("ARRAYBUFFER not supported by this environment");
              }
              return function(n2, t3, e3) {
                return function(n3, t4, e4, i3) {
                  return r(new Uint8Array(n3), t4, e4, i3);
                }(n2, t3, e3, i2);
              };
            case "UINT8ARRAY":
              try {
                new Uint8Array(0);
              } catch (n2) {
                throw new Error("UINT8ARRAY not supported by this environment");
              }
              return function(n2, t3, e3) {
                return r(n2, t3, e3, i2);
              };
            default:
              throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
          }
        }
        function e(r2, t2, e2, i2) {
          switch (r2) {
            case "HEX":
              return function(n2) {
                return function(n3, r3, t3, e3) {
                  var i3, o2, u2 = "", f2 = r3 / 8, w2 = -1 === t3 ? 3 : 0;
                  for (i3 = 0; i3 < f2; i3 += 1)
                    o2 = n3[i3 >>> 2] >>> 8 * (w2 + t3 * (i3 % 4)), u2 += "0123456789abcdef".charAt(o2 >>> 4 & 15) + "0123456789abcdef".charAt(15 & o2);
                  return e3.outputUpper ? u2.toUpperCase() : u2;
                }(n2, t2, e2, i2);
              };
            case "B64":
              return function(r3) {
                return function(r4, t3, e3, i3) {
                  var o2, u2, f2, w2, s2, a2 = "", h2 = t3 / 8, c2 = -1 === e3 ? 3 : 0;
                  for (o2 = 0; o2 < h2; o2 += 3)
                    for (w2 = o2 + 1 < h2 ? r4[o2 + 1 >>> 2] : 0, s2 = o2 + 2 < h2 ? r4[o2 + 2 >>> 2] : 0, f2 = (r4[o2 >>> 2] >>> 8 * (c2 + e3 * (o2 % 4)) & 255) << 16 | (w2 >>> 8 * (c2 + e3 * ((o2 + 1) % 4)) & 255) << 8 | s2 >>> 8 * (c2 + e3 * ((o2 + 2) % 4)) & 255, u2 = 0; u2 < 4; u2 += 1)
                      a2 += 8 * o2 + 6 * u2 <= t3 ? n.charAt(f2 >>> 6 * (3 - u2) & 63) : i3.b64Pad;
                  return a2;
                }(r3, t2, e2, i2);
              };
            case "BYTES":
              return function(n2) {
                return function(n3, r3, t3) {
                  var e3, i3, o2 = "", u2 = r3 / 8, f2 = -1 === t3 ? 3 : 0;
                  for (e3 = 0; e3 < u2; e3 += 1)
                    i3 = n3[e3 >>> 2] >>> 8 * (f2 + t3 * (e3 % 4)) & 255, o2 += String.fromCharCode(i3);
                  return o2;
                }(n2, t2, e2);
              };
            case "ARRAYBUFFER":
              try {
                new ArrayBuffer(0);
              } catch (n2) {
                throw new Error("ARRAYBUFFER not supported by this environment");
              }
              return function(n2) {
                return function(n3, r3, t3) {
                  var e3, i3 = r3 / 8, o2 = new ArrayBuffer(i3), u2 = new Uint8Array(o2), f2 = -1 === t3 ? 3 : 0;
                  for (e3 = 0; e3 < i3; e3 += 1)
                    u2[e3] = n3[e3 >>> 2] >>> 8 * (f2 + t3 * (e3 % 4)) & 255;
                  return o2;
                }(n2, t2, e2);
              };
            case "UINT8ARRAY":
              try {
                new Uint8Array(0);
              } catch (n2) {
                throw new Error("UINT8ARRAY not supported by this environment");
              }
              return function(n2) {
                return function(n3, r3, t3) {
                  var e3, i3 = r3 / 8, o2 = -1 === t3 ? 3 : 0, u2 = new Uint8Array(i3);
                  for (e3 = 0; e3 < i3; e3 += 1)
                    u2[e3] = n3[e3 >>> 2] >>> 8 * (o2 + t3 * (e3 % 4)) & 255;
                  return u2;
                }(n2, t2, e2);
              };
            default:
              throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
          }
        }
        var i = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], o = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428], u = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], f = "Chosen SHA variant is not supported";
        function w(n2, r2) {
          var t2, e2, i2 = n2.binLen >>> 3, o2 = r2.binLen >>> 3, u2 = i2 << 3, f2 = 4 - i2 << 3;
          if (i2 % 4 != 0) {
            for (t2 = 0; t2 < o2; t2 += 4)
              e2 = i2 + t2 >>> 2, n2.value[e2] |= r2.value[t2 >>> 2] << u2, n2.value.push(0), n2.value[e2 + 1] |= r2.value[t2 >>> 2] >>> f2;
            return (n2.value.length << 2) - 4 >= o2 + i2 && n2.value.pop(), { value: n2.value, binLen: n2.binLen + r2.binLen };
          }
          return { value: n2.value.concat(r2.value), binLen: n2.binLen + r2.binLen };
        }
        function s(n2) {
          var r2 = { outputUpper: false, b64Pad: "=", outputLen: -1 }, t2 = n2 || {}, e2 = "Output length must be a multiple of 8";
          if (r2.outputUpper = t2.outputUpper || false, t2.b64Pad && (r2.b64Pad = t2.b64Pad), t2.outputLen) {
            if (t2.outputLen % 8 != 0)
              throw new Error(e2);
            r2.outputLen = t2.outputLen;
          } else if (t2.shakeLen) {
            if (t2.shakeLen % 8 != 0)
              throw new Error(e2);
            r2.outputLen = t2.shakeLen;
          }
          if ("boolean" != typeof r2.outputUpper)
            throw new Error("Invalid outputUpper formatting option");
          if ("string" != typeof r2.b64Pad)
            throw new Error("Invalid b64Pad formatting option");
          return r2;
        }
        function a(n2, r2, e2, i2) {
          var o2 = n2 + " must include a value and format";
          if (!r2) {
            if (!i2)
              throw new Error(o2);
            return i2;
          }
          if (void 0 === r2.value || !r2.format)
            throw new Error(o2);
          return t(r2.format, r2.encoding || "UTF8", e2)(r2.value);
        }
        var h = function() {
          function n2(n3, r2, t2) {
            var e2 = t2 || {};
            if (this.t = r2, this.i = e2.encoding || "UTF8", this.numRounds = e2.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds)
              throw new Error("numRounds must a integer >= 1");
            this.o = n3, this.u = [], this.s = 0, this.h = false, this.v = 0, this.A = false, this.l = [], this.H = [];
          }
          return n2.prototype.update = function(n3) {
            var r2, t2 = 0, e2 = this.S >>> 5, i2 = this.p(n3, this.u, this.s), o2 = i2.binLen, u2 = i2.value, f2 = o2 >>> 5;
            for (r2 = 0; r2 < f2; r2 += e2)
              t2 + this.S <= o2 && (this.m = this.R(u2.slice(r2, r2 + e2), this.m), t2 += this.S);
            this.v += t2, this.u = u2.slice(t2 >>> 5), this.s = o2 % this.S, this.h = true;
          }, n2.prototype.getHash = function(n3, r2) {
            var t2, i2, o2 = this.U, u2 = s(r2);
            if (this.T) {
              if (-1 === u2.outputLen)
                throw new Error("Output length must be specified in options");
              o2 = u2.outputLen;
            }
            var f2 = e(n3, o2, this.C, u2);
            if (this.A && this.F)
              return f2(this.F(u2));
            for (i2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), o2), t2 = 1; t2 < this.numRounds; t2 += 1)
              this.T && o2 % 32 != 0 && (i2[i2.length - 1] &= 16777215 >>> 24 - o2 % 32), i2 = this.K(i2, o2, 0, this.L(this.o), o2);
            return f2(i2);
          }, n2.prototype.setHMACKey = function(n3, r2, e2) {
            if (!this.g)
              throw new Error("Variant does not support HMAC");
            if (this.h)
              throw new Error("Cannot set MAC key after calling update");
            var i2 = t(r2, (e2 || {}).encoding || "UTF8", this.C);
            this.k(i2(n3));
          }, n2.prototype.k = function(n3) {
            var r2, t2 = this.S >>> 3, e2 = t2 / 4 - 1;
            if (1 !== this.numRounds)
              throw new Error("Cannot set numRounds with MAC");
            if (this.A)
              throw new Error("MAC key already set");
            for (t2 < n3.binLen / 8 && (n3.value = this.K(n3.value, n3.binLen, 0, this.L(this.o), this.U)); n3.value.length <= e2; )
              n3.value.push(0);
            for (r2 = 0; r2 <= e2; r2 += 1)
              this.l[r2] = 909522486 ^ n3.value[r2], this.H[r2] = 1549556828 ^ n3.value[r2];
            this.m = this.R(this.l, this.m), this.v = this.S, this.A = true;
          }, n2.prototype.getHMAC = function(n3, r2) {
            var t2 = s(r2);
            return e(n3, this.U, this.C, t2)(this.Y());
          }, n2.prototype.Y = function() {
            var n3;
            if (!this.A)
              throw new Error("Cannot call getHMAC without first setting MAC key");
            var r2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), this.U);
            return n3 = this.R(this.H, this.L(this.o)), n3 = this.K(r2, this.U, this.S, n3, this.U);
          }, n2;
        }(), c = function(n2, r2) {
          return (c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, r3) {
            n3.__proto__ = r3;
          } || function(n3, r3) {
            for (var t2 in r3)
              Object.prototype.hasOwnProperty.call(r3, t2) && (n3[t2] = r3[t2]);
          })(n2, r2);
        };
        function v(n2, r2) {
          function t2() {
            this.constructor = n2;
          }
          c(n2, r2), n2.prototype = null === r2 ? Object.create(r2) : (t2.prototype = r2.prototype, new t2());
        }
        function A(n2, r2) {
          return n2 << r2 | n2 >>> 32 - r2;
        }
        function E(n2, r2) {
          return n2 >>> r2 | n2 << 32 - r2;
        }
        function l(n2, r2) {
          return n2 >>> r2;
        }
        function b(n2, r2, t2) {
          return n2 ^ r2 ^ t2;
        }
        function H(n2, r2, t2) {
          return n2 & r2 ^ ~n2 & t2;
        }
        function d(n2, r2, t2) {
          return n2 & r2 ^ n2 & t2 ^ r2 & t2;
        }
        function S(n2) {
          return E(n2, 2) ^ E(n2, 13) ^ E(n2, 22);
        }
        function p(n2, r2) {
          var t2 = (65535 & n2) + (65535 & r2);
          return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16)) << 16 | 65535 & t2;
        }
        function m(n2, r2, t2, e2) {
          var i2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2);
          return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16)) << 16 | 65535 & i2;
        }
        function y(n2, r2, t2, e2, i2) {
          var o2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2) + (65535 & i2);
          return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16) + (o2 >>> 16)) << 16 | 65535 & o2;
        }
        function R(n2) {
          return E(n2, 7) ^ E(n2, 18) ^ l(n2, 3);
        }
        function U(n2) {
          return E(n2, 6) ^ E(n2, 11) ^ E(n2, 25);
        }
        function T(n2) {
          return [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        }
        function C(n2, r2) {
          var t2, e2, i2, o2, u2, f2, w2, s2 = [];
          for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], w2 = 0; w2 < 80; w2 += 1)
            s2[w2] = w2 < 16 ? n2[w2] : A(s2[w2 - 3] ^ s2[w2 - 8] ^ s2[w2 - 14] ^ s2[w2 - 16], 1), f2 = w2 < 20 ? y(A(t2, 5), H(e2, i2, o2), u2, 1518500249, s2[w2]) : w2 < 40 ? y(A(t2, 5), b(e2, i2, o2), u2, 1859775393, s2[w2]) : w2 < 60 ? y(A(t2, 5), d(e2, i2, o2), u2, 2400959708, s2[w2]) : y(A(t2, 5), b(e2, i2, o2), u2, 3395469782, s2[w2]), u2 = o2, o2 = i2, i2 = A(e2, 30), e2 = t2, t2 = f2;
          return r2[0] = p(t2, r2[0]), r2[1] = p(e2, r2[1]), r2[2] = p(i2, r2[2]), r2[3] = p(o2, r2[3]), r2[4] = p(u2, r2[4]), r2;
        }
        function F(n2, r2, t2, e2) {
          for (var i2, o2 = 15 + (r2 + 65 >>> 9 << 4), u2 = r2 + t2; n2.length <= o2; )
            n2.push(0);
          for (n2[r2 >>> 5] |= 128 << 24 - r2 % 32, n2[o2] = 4294967295 & u2, n2[o2 - 1] = u2 / 4294967296 | 0, i2 = 0; i2 < n2.length; i2 += 16)
            e2 = C(n2.slice(i2, i2 + 16), e2);
          return e2;
        }
        var K = function(n2) {
          function r2(r3, e2, i2) {
            var o2 = this;
            if ("SHA-1" !== r3)
              throw new Error(f);
            var u2 = i2 || {};
            return (o2 = n2.call(this, r3, e2, i2) || this).g = true, o2.F = o2.Y, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = C, o2.B = function(n3) {
              return n3.slice();
            }, o2.L = T, o2.K = F, o2.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], o2.S = 512, o2.U = 160, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
          }
          return v(r2, n2), r2;
        }(h);
        function B(n2) {
          return "SHA-224" == n2 ? o.slice() : u.slice();
        }
        function L(n2, r2) {
          var t2, e2, o2, u2, f2, w2, s2, a2, h2, c2, v2, A2, b2 = [];
          for (t2 = r2[0], e2 = r2[1], o2 = r2[2], u2 = r2[3], f2 = r2[4], w2 = r2[5], s2 = r2[6], a2 = r2[7], v2 = 0; v2 < 64; v2 += 1)
            b2[v2] = v2 < 16 ? n2[v2] : m(E(A2 = b2[v2 - 2], 17) ^ E(A2, 19) ^ l(A2, 10), b2[v2 - 7], R(b2[v2 - 15]), b2[v2 - 16]), h2 = y(a2, U(f2), H(f2, w2, s2), i[v2], b2[v2]), c2 = p(S(t2), d(t2, e2, o2)), a2 = s2, s2 = w2, w2 = f2, f2 = p(u2, h2), u2 = o2, o2 = e2, e2 = t2, t2 = p(h2, c2);
          return r2[0] = p(t2, r2[0]), r2[1] = p(e2, r2[1]), r2[2] = p(o2, r2[2]), r2[3] = p(u2, r2[3]), r2[4] = p(f2, r2[4]), r2[5] = p(w2, r2[5]), r2[6] = p(s2, r2[6]), r2[7] = p(a2, r2[7]), r2;
        }
        var g = function(n2) {
          function r2(r3, e2, i2) {
            var o2 = this;
            if ("SHA-224" !== r3 && "SHA-256" !== r3)
              throw new Error(f);
            var u2 = i2 || {};
            return (o2 = n2.call(this, r3, e2, i2) || this).F = o2.Y, o2.g = true, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = L, o2.B = function(n3) {
              return n3.slice();
            }, o2.L = B, o2.K = function(n3, t2, e3, i3) {
              return function(n4, r4, t3, e4, i4) {
                for (var o3, u3 = 15 + (r4 + 65 >>> 9 << 4), f2 = r4 + t3; n4.length <= u3; )
                  n4.push(0);
                for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f2, n4[u3 - 1] = f2 / 4294967296 | 0, o3 = 0; o3 < n4.length; o3 += 16)
                  e4 = L(n4.slice(o3, o3 + 16), e4);
                return "SHA-224" === i4 ? [e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]] : e4;
              }(n3, t2, e3, i3, r3);
            }, o2.m = B(r3), o2.S = 512, o2.U = "SHA-224" === r3 ? 224 : 256, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
          }
          return v(r2, n2), r2;
        }(h), k = function(n2, r2) {
          this.N = n2, this.I = r2;
        };
        function Y(n2, r2) {
          var t2;
          return r2 > 32 ? (t2 = 64 - r2, new k(n2.I << r2 | n2.N >>> t2, n2.N << r2 | n2.I >>> t2)) : 0 !== r2 ? (t2 = 32 - r2, new k(n2.N << r2 | n2.I >>> t2, n2.I << r2 | n2.N >>> t2)) : n2;
        }
        function N(n2, r2) {
          var t2;
          return r2 < 32 ? (t2 = 32 - r2, new k(n2.N >>> r2 | n2.I << t2, n2.I >>> r2 | n2.N << t2)) : (t2 = 64 - r2, new k(n2.I >>> r2 | n2.N << t2, n2.N >>> r2 | n2.I << t2));
        }
        function I(n2, r2) {
          return new k(n2.N >>> r2, n2.I >>> r2 | n2.N << 32 - r2);
        }
        function M(n2, r2, t2) {
          return new k(n2.N & r2.N ^ ~n2.N & t2.N, n2.I & r2.I ^ ~n2.I & t2.I);
        }
        function X(n2, r2, t2) {
          return new k(n2.N & r2.N ^ n2.N & t2.N ^ r2.N & t2.N, n2.I & r2.I ^ n2.I & t2.I ^ r2.I & t2.I);
        }
        function z(n2) {
          var r2 = N(n2, 28), t2 = N(n2, 34), e2 = N(n2, 39);
          return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
        }
        function O(n2, r2) {
          var t2, e2;
          t2 = (65535 & n2.I) + (65535 & r2.I);
          var i2 = (65535 & (e2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2 >>> 16))) << 16 | 65535 & t2;
          return t2 = (65535 & n2.N) + (65535 & r2.N) + (e2 >>> 16), e2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2 >>> 16), new k((65535 & e2) << 16 | 65535 & t2, i2);
        }
        function j(n2, r2, t2, e2) {
          var i2, o2;
          i2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I);
          var u2 = (65535 & (o2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2 >>> 16))) << 16 | 65535 & i2;
          return i2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (o2 >>> 16), o2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2 >>> 16), new k((65535 & o2) << 16 | 65535 & i2, u2);
        }
        function _(n2, r2, t2, e2, i2) {
          var o2, u2;
          o2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I) + (65535 & i2.I);
          var f2 = (65535 & (u2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2.I >>> 16) + (o2 >>> 16))) << 16 | 65535 & o2;
          return o2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (65535 & i2.N) + (u2 >>> 16), u2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2.N >>> 16) + (o2 >>> 16), new k((65535 & u2) << 16 | 65535 & o2, f2);
        }
        function P(n2, r2) {
          return new k(n2.N ^ r2.N, n2.I ^ r2.I);
        }
        function x(n2) {
          var r2 = N(n2, 1), t2 = N(n2, 8), e2 = I(n2, 7);
          return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
        }
        function V(n2) {
          var r2 = N(n2, 14), t2 = N(n2, 18), e2 = N(n2, 41);
          return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
        }
        var Z = [new k(i[0], 3609767458), new k(i[1], 602891725), new k(i[2], 3964484399), new k(i[3], 2173295548), new k(i[4], 4081628472), new k(i[5], 3053834265), new k(i[6], 2937671579), new k(i[7], 3664609560), new k(i[8], 2734883394), new k(i[9], 1164996542), new k(i[10], 1323610764), new k(i[11], 3590304994), new k(i[12], 4068182383), new k(i[13], 991336113), new k(i[14], 633803317), new k(i[15], 3479774868), new k(i[16], 2666613458), new k(i[17], 944711139), new k(i[18], 2341262773), new k(i[19], 2007800933), new k(i[20], 1495990901), new k(i[21], 1856431235), new k(i[22], 3175218132), new k(i[23], 2198950837), new k(i[24], 3999719339), new k(i[25], 766784016), new k(i[26], 2566594879), new k(i[27], 3203337956), new k(i[28], 1034457026), new k(i[29], 2466948901), new k(i[30], 3758326383), new k(i[31], 168717936), new k(i[32], 1188179964), new k(i[33], 1546045734), new k(i[34], 1522805485), new k(i[35], 2643833823), new k(i[36], 2343527390), new k(i[37], 1014477480), new k(i[38], 1206759142), new k(i[39], 344077627), new k(i[40], 1290863460), new k(i[41], 3158454273), new k(i[42], 3505952657), new k(i[43], 106217008), new k(i[44], 3606008344), new k(i[45], 1432725776), new k(i[46], 1467031594), new k(i[47], 851169720), new k(i[48], 3100823752), new k(i[49], 1363258195), new k(i[50], 3750685593), new k(i[51], 3785050280), new k(i[52], 3318307427), new k(i[53], 3812723403), new k(i[54], 2003034995), new k(i[55], 3602036899), new k(i[56], 1575990012), new k(i[57], 1125592928), new k(i[58], 2716904306), new k(i[59], 442776044), new k(i[60], 593698344), new k(i[61], 3733110249), new k(i[62], 2999351573), new k(i[63], 3815920427), new k(3391569614, 3928383900), new k(3515267271, 566280711), new k(3940187606, 3454069534), new k(4118630271, 4000239992), new k(116418474, 1914138554), new k(174292421, 2731055270), new k(289380356, 3203993006), new k(460393269, 320620315), new k(685471733, 587496836), new k(852142971, 1086792851), new k(1017036298, 365543100), new k(1126000580, 2618297676), new k(1288033470, 3409855158), new k(1501505948, 4234509866), new k(1607167915, 987167468), new k(1816402316, 1246189591)];
        function q(n2) {
          return "SHA-384" === n2 ? [new k(3418070365, o[0]), new k(1654270250, o[1]), new k(2438529370, o[2]), new k(355462360, o[3]), new k(1731405415, o[4]), new k(41048885895, o[5]), new k(3675008525, o[6]), new k(1203062813, o[7])] : [new k(u[0], 4089235720), new k(u[1], 2227873595), new k(u[2], 4271175723), new k(u[3], 1595750129), new k(u[4], 2917565137), new k(u[5], 725511199), new k(u[6], 4215389547), new k(u[7], 327033209)];
        }
        function D(n2, r2) {
          var t2, e2, i2, o2, u2, f2, w2, s2, a2, h2, c2, v2, A2, E2, l2, b2, H2 = [];
          for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], f2 = r2[5], w2 = r2[6], s2 = r2[7], c2 = 0; c2 < 80; c2 += 1)
            c2 < 16 ? (v2 = 2 * c2, H2[c2] = new k(n2[v2], n2[v2 + 1])) : H2[c2] = j((A2 = H2[c2 - 2], E2 = void 0, l2 = void 0, b2 = void 0, E2 = N(A2, 19), l2 = N(A2, 61), b2 = I(A2, 6), new k(E2.N ^ l2.N ^ b2.N, E2.I ^ l2.I ^ b2.I)), H2[c2 - 7], x(H2[c2 - 15]), H2[c2 - 16]), a2 = _(s2, V(u2), M(u2, f2, w2), Z[c2], H2[c2]), h2 = O(z(t2), X(t2, e2, i2)), s2 = w2, w2 = f2, f2 = u2, u2 = O(o2, a2), o2 = i2, i2 = e2, e2 = t2, t2 = O(a2, h2);
          return r2[0] = O(t2, r2[0]), r2[1] = O(e2, r2[1]), r2[2] = O(i2, r2[2]), r2[3] = O(o2, r2[3]), r2[4] = O(u2, r2[4]), r2[5] = O(f2, r2[5]), r2[6] = O(w2, r2[6]), r2[7] = O(s2, r2[7]), r2;
        }
        var G = function(n2) {
          function r2(r3, e2, i2) {
            var o2 = this;
            if ("SHA-384" !== r3 && "SHA-512" !== r3)
              throw new Error(f);
            var u2 = i2 || {};
            return (o2 = n2.call(this, r3, e2, i2) || this).F = o2.Y, o2.g = true, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = D, o2.B = function(n3) {
              return n3.slice();
            }, o2.L = q, o2.K = function(n3, t2, e3, i3) {
              return function(n4, r4, t3, e4, i4) {
                for (var o3, u3 = 31 + (r4 + 129 >>> 10 << 5), f2 = r4 + t3; n4.length <= u3; )
                  n4.push(0);
                for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f2, n4[u3 - 1] = f2 / 4294967296 | 0, o3 = 0; o3 < n4.length; o3 += 32)
                  e4 = D(n4.slice(o3, o3 + 32), e4);
                return "SHA-384" === i4 ? [(e4 = e4)[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I] : [e4[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I, e4[6].N, e4[6].I, e4[7].N, e4[7].I];
              }(n3, t2, e3, i3, r3);
            }, o2.m = q(r3), o2.S = 1024, o2.U = "SHA-384" === r3 ? 384 : 512, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
          }
          return v(r2, n2), r2;
        }(h), J = [new k(0, 1), new k(0, 32898), new k(2147483648, 32906), new k(2147483648, 2147516416), new k(0, 32907), new k(0, 2147483649), new k(2147483648, 2147516545), new k(2147483648, 32777), new k(0, 138), new k(0, 136), new k(0, 2147516425), new k(0, 2147483658), new k(0, 2147516555), new k(2147483648, 139), new k(2147483648, 32905), new k(2147483648, 32771), new k(2147483648, 32770), new k(2147483648, 128), new k(0, 32778), new k(2147483648, 2147483658), new k(2147483648, 2147516545), new k(2147483648, 32896), new k(0, 2147483649), new k(2147483648, 2147516424)], Q = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
        function W(n2) {
          var r2, t2 = [];
          for (r2 = 0; r2 < 5; r2 += 1)
            t2[r2] = [new k(0, 0), new k(0, 0), new k(0, 0), new k(0, 0), new k(0, 0)];
          return t2;
        }
        function $(n2) {
          var r2, t2 = [];
          for (r2 = 0; r2 < 5; r2 += 1)
            t2[r2] = n2[r2].slice();
          return t2;
        }
        function nn(n2, r2) {
          var t2, e2, i2, o2, u2, f2, w2, s2, a2, h2 = [], c2 = [];
          if (null !== n2)
            for (e2 = 0; e2 < n2.length; e2 += 2)
              r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0] = P(r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0], new k(n2[e2 + 1], n2[e2]));
          for (t2 = 0; t2 < 24; t2 += 1) {
            for (o2 = W(), e2 = 0; e2 < 5; e2 += 1)
              h2[e2] = (u2 = r2[e2][0], f2 = r2[e2][1], w2 = r2[e2][2], s2 = r2[e2][3], a2 = r2[e2][4], new k(u2.N ^ f2.N ^ w2.N ^ s2.N ^ a2.N, u2.I ^ f2.I ^ w2.I ^ s2.I ^ a2.I));
            for (e2 = 0; e2 < 5; e2 += 1)
              c2[e2] = P(h2[(e2 + 4) % 5], Y(h2[(e2 + 1) % 5], 1));
            for (e2 = 0; e2 < 5; e2 += 1)
              for (i2 = 0; i2 < 5; i2 += 1)
                r2[e2][i2] = P(r2[e2][i2], c2[e2]);
            for (e2 = 0; e2 < 5; e2 += 1)
              for (i2 = 0; i2 < 5; i2 += 1)
                o2[i2][(2 * e2 + 3 * i2) % 5] = Y(r2[e2][i2], Q[e2][i2]);
            for (e2 = 0; e2 < 5; e2 += 1)
              for (i2 = 0; i2 < 5; i2 += 1)
                r2[e2][i2] = P(o2[e2][i2], new k(~o2[(e2 + 1) % 5][i2].N & o2[(e2 + 2) % 5][i2].N, ~o2[(e2 + 1) % 5][i2].I & o2[(e2 + 2) % 5][i2].I));
            r2[0][0] = P(r2[0][0], J[t2]);
          }
          return r2;
        }
        function rn(n2) {
          var r2, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n2, n2 / 4294967296 & 2097151];
          for (r2 = 6; r2 >= 0; r2--)
            0 === (t2 = o2[r2 >> 2] >>> 8 * r2 & 255) && 0 === e2 || (i2[e2 + 1 >> 2] |= t2 << 8 * (e2 + 1), e2 += 1);
          return e2 = 0 !== e2 ? e2 : 1, i2[0] |= e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
        }
        function tn(n2) {
          return w(rn(n2.binLen), n2);
        }
        function en(n2, r2) {
          var t2, e2 = rn(r2), i2 = r2 >>> 2, o2 = (i2 - (e2 = w(e2, n2)).value.length % i2) % i2;
          for (t2 = 0; t2 < o2; t2++)
            e2.value.push(0);
          return e2.value;
        }
        var on = function(n2) {
          function r2(r3, e2, i2) {
            var o2 = this, u2 = 6, w2 = 0, s2 = i2 || {};
            if (1 !== (o2 = n2.call(this, r3, e2, i2) || this).numRounds) {
              if (s2.kmacKey || s2.hmacKey)
                throw new Error("Cannot set numRounds with MAC");
              if ("CSHAKE128" === o2.o || "CSHAKE256" === o2.o)
                throw new Error("Cannot set numRounds for CSHAKE variants");
            }
            switch (o2.C = 1, o2.p = t(o2.t, o2.i, o2.C), o2.R = nn, o2.B = $, o2.L = W, o2.m = W(), o2.T = false, r3) {
              case "SHA3-224":
                o2.S = w2 = 1152, o2.U = 224, o2.g = true, o2.F = o2.Y;
                break;
              case "SHA3-256":
                o2.S = w2 = 1088, o2.U = 256, o2.g = true, o2.F = o2.Y;
                break;
              case "SHA3-384":
                o2.S = w2 = 832, o2.U = 384, o2.g = true, o2.F = o2.Y;
                break;
              case "SHA3-512":
                o2.S = w2 = 576, o2.U = 512, o2.g = true, o2.F = o2.Y;
                break;
              case "SHAKE128":
                u2 = 31, o2.S = w2 = 1344, o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
                break;
              case "SHAKE256":
                u2 = 31, o2.S = w2 = 1088, o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
                break;
              case "KMAC128":
                u2 = 4, o2.S = w2 = 1344, o2.M(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = o2.X;
                break;
              case "KMAC256":
                u2 = 4, o2.S = w2 = 1088, o2.M(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = o2.X;
                break;
              case "CSHAKE128":
                o2.S = w2 = 1344, u2 = o2.O(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
                break;
              case "CSHAKE256":
                o2.S = w2 = 1088, u2 = o2.O(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
                break;
              default:
                throw new Error(f);
            }
            return o2.K = function(n3, r4, t2, e3, i3) {
              return function(n4, r5, t3, e4, i4, o3, u3) {
                var f2, w3, s3 = 0, a2 = [], h2 = i4 >>> 5, c2 = r5 >>> 5;
                for (f2 = 0; f2 < c2 && r5 >= i4; f2 += h2)
                  e4 = nn(n4.slice(f2, f2 + h2), e4), r5 -= i4;
                for (n4 = n4.slice(f2), r5 %= i4; n4.length < h2; )
                  n4.push(0);
                for (n4[(f2 = r5 >>> 3) >> 2] ^= o3 << f2 % 4 * 8, n4[h2 - 1] ^= 2147483648, e4 = nn(n4, e4); 32 * a2.length < u3 && (w3 = e4[s3 % 5][s3 / 5 | 0], a2.push(w3.I), !(32 * a2.length >= u3)); )
                  a2.push(w3.N), 0 == 64 * (s3 += 1) % i4 && (nn(null, e4), s3 = 0);
                return a2;
              }(n3, r4, 0, e3, w2, u2, i3);
            }, s2.hmacKey && o2.k(a("hmacKey", s2.hmacKey, o2.C)), o2;
          }
          return v(r2, n2), r2.prototype.O = function(n3, r3) {
            var t2 = function(n4) {
              var r4 = n4 || {};
              return { funcName: a("funcName", r4.funcName, 1, { value: [], binLen: 0 }), customization: a("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
            }(n3 || {});
            r3 && (t2.funcName = r3);
            var e2 = w(tn(t2.funcName), tn(t2.customization));
            if (0 !== t2.customization.binLen || 0 !== t2.funcName.binLen) {
              for (var i2 = en(e2, this.S >>> 3), o2 = 0; o2 < i2.length; o2 += this.S >>> 5)
                this.m = this.R(i2.slice(o2, o2 + (this.S >>> 5)), this.m), this.v += this.S;
              return 4;
            }
            return 31;
          }, r2.prototype.M = function(n3) {
            var r3 = function(n4) {
              var r4 = n4 || {};
              return { kmacKey: a("kmacKey", r4.kmacKey, 1), funcName: { value: [1128353099], binLen: 32 }, customization: a("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
            }(n3 || {});
            this.O(n3, r3.funcName);
            for (var t2 = en(tn(r3.kmacKey), this.S >>> 3), e2 = 0; e2 < t2.length; e2 += this.S >>> 5)
              this.m = this.R(t2.slice(e2, e2 + (this.S >>> 5)), this.m), this.v += this.S;
            this.A = true;
          }, r2.prototype.X = function(n3) {
            var r3 = w({ value: this.u.slice(), binLen: this.s }, function(n4) {
              var r4, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n4, n4 / 4294967296 & 2097151];
              for (r4 = 6; r4 >= 0; r4--)
                0 == (t2 = o2[r4 >> 2] >>> 8 * r4 & 255) && 0 === e2 || (i2[e2 >> 2] |= t2 << 8 * e2, e2 += 1);
              return i2[(e2 = 0 !== e2 ? e2 : 1) >> 2] |= e2 << 8 * e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
            }(n3.outputLen));
            return this.K(r3.value, r3.binLen, this.v, this.B(this.m), n3.outputLen);
          }, r2;
        }(h);
        return function() {
          function n2(n3, r2, t2) {
            if ("SHA-1" == n3)
              this.j = new K(n3, r2, t2);
            else if ("SHA-224" == n3 || "SHA-256" == n3)
              this.j = new g(n3, r2, t2);
            else if ("SHA-384" == n3 || "SHA-512" == n3)
              this.j = new G(n3, r2, t2);
            else {
              if ("SHA3-224" != n3 && "SHA3-256" != n3 && "SHA3-384" != n3 && "SHA3-512" != n3 && "SHAKE128" != n3 && "SHAKE256" != n3 && "CSHAKE128" != n3 && "CSHAKE256" != n3 && "KMAC128" != n3 && "KMAC256" != n3)
                throw new Error(f);
              this.j = new on(n3, r2, t2);
            }
          }
          return n2.prototype.update = function(n3) {
            this.j.update(n3);
          }, n2.prototype.getHash = function(n3, r2) {
            return this.j.getHash(n3, r2);
          }, n2.prototype.setHMACKey = function(n3, r2, t2) {
            this.j.setHMACKey(n3, r2, t2);
          }, n2.prototype.getHMAC = function(n3, r2) {
            return this.j.getHMAC(n3, r2);
          }, n2;
        }();
      });
    }
  });

  // node_modules/ton-crypto-primitives/dist/browser/getSecureRandom.js
  var require_getSecureRandom = __commonJS({
    "node_modules/ton-crypto-primitives/dist/browser/getSecureRandom.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
      function getSecureRandomBytes(size) {
        return Buffer.from(window.crypto.getRandomValues(new Uint8Array(size)));
      }
      exports.getSecureRandomBytes = getSecureRandomBytes;
      function getSecureRandomWords(size) {
        return window.crypto.getRandomValues(new Uint16Array(size));
      }
      exports.getSecureRandomWords = getSecureRandomWords;
    }
  });

  // node_modules/ton-crypto-primitives/dist/browser/hmac_sha512.js
  var require_hmac_sha512 = __commonJS({
    "node_modules/ton-crypto-primitives/dist/browser/hmac_sha512.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hmac_sha512 = void 0;
      function hmac_sha512(key, data) {
        return __async(this, null, function* () {
          let keyBuffer = typeof key === "string" ? Buffer.from(key, "utf-8") : key;
          let dataBuffer = typeof data === "string" ? Buffer.from(data, "utf-8") : data;
          const hmacAlgo = { name: "HMAC", hash: "SHA-512" };
          const hmacKey = yield window.crypto.subtle.importKey("raw", keyBuffer, hmacAlgo, false, ["sign"]);
          return Buffer.from(yield crypto.subtle.sign(hmacAlgo, hmacKey, dataBuffer));
        });
      }
      exports.hmac_sha512 = hmac_sha512;
    }
  });

  // node_modules/ton-crypto-primitives/dist/browser/pbkdf2_sha512.js
  var require_pbkdf2_sha512 = __commonJS({
    "node_modules/ton-crypto-primitives/dist/browser/pbkdf2_sha512.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pbkdf2_sha512 = void 0;
      function pbkdf2_sha512(key, salt, iterations, keyLen) {
        return __async(this, null, function* () {
          const keyBuffer = typeof key === "string" ? Buffer.from(key, "utf-8") : key;
          const saltBuffer = typeof salt === "string" ? Buffer.from(salt, "utf-8") : salt;
          const pbkdf2_key = yield window.crypto.subtle.importKey("raw", keyBuffer, { name: "PBKDF2" }, false, ["deriveBits"]);
          const derivedBits = yield window.crypto.subtle.deriveBits({ name: "PBKDF2", hash: "SHA-512", salt: saltBuffer, iterations }, pbkdf2_key, keyLen * 8);
          return Buffer.from(derivedBits);
        });
      }
      exports.pbkdf2_sha512 = pbkdf2_sha512;
    }
  });

  // node_modules/ton-crypto-primitives/dist/browser/sha256.js
  var require_sha256 = __commonJS({
    "node_modules/ton-crypto-primitives/dist/browser/sha256.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha256 = void 0;
      function sha256(source) {
        return __async(this, null, function* () {
          if (typeof source === "string") {
            return Buffer.from(yield crypto.subtle.digest("SHA-256", Buffer.from(source, "utf-8")));
          }
          return Buffer.from(yield crypto.subtle.digest("SHA-256", source));
        });
      }
      exports.sha256 = sha256;
    }
  });

  // node_modules/ton-crypto-primitives/dist/browser/sha512.js
  var require_sha512 = __commonJS({
    "node_modules/ton-crypto-primitives/dist/browser/sha512.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha512 = void 0;
      function sha512(source) {
        return __async(this, null, function* () {
          if (typeof source === "string") {
            return Buffer.from(yield crypto.subtle.digest("SHA-512", Buffer.from(source, "utf-8")));
          }
          return Buffer.from(yield crypto.subtle.digest("SHA-512", source));
        });
      }
      exports.sha512 = sha512;
    }
  });

  // node_modules/ton-crypto-primitives/dist/browser.js
  var require_browser = __commonJS({
    "node_modules/ton-crypto-primitives/dist/browser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha512 = exports.sha256 = exports.pbkdf2_sha512 = exports.hmac_sha512 = exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
      var getSecureRandom_1 = require_getSecureRandom();
      Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
        return getSecureRandom_1.getSecureRandomBytes;
      } });
      Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
        return getSecureRandom_1.getSecureRandomWords;
      } });
      var hmac_sha512_1 = require_hmac_sha512();
      Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
        return hmac_sha512_1.hmac_sha512;
      } });
      var pbkdf2_sha512_1 = require_pbkdf2_sha512();
      Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
        return pbkdf2_sha512_1.pbkdf2_sha512;
      } });
      var sha256_1 = require_sha256();
      Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
        return sha256_1.sha256;
      } });
      var sha512_1 = require_sha512();
      Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
        return sha512_1.sha512;
      } });
    }
  });

  // node_modules/ton-crypto/dist/primitives/sha256.js
  var require_sha2562 = __commonJS({
    "node_modules/ton-crypto/dist/primitives/sha256.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha256 = exports.sha256_fallback = exports.sha256_sync = void 0;
      var jssha_1 = __importDefault(require_sha());
      var ton_crypto_primitives_1 = require_browser();
      function sha256_sync(source) {
        let src;
        if (typeof source === "string") {
          src = Buffer.from(source, "utf-8").toString("hex");
        } else {
          src = source.toString("hex");
        }
        let hasher = new jssha_1.default("SHA-256", "HEX");
        hasher.update(src);
        let res = hasher.getHash("HEX");
        return Buffer.from(res, "hex");
      }
      exports.sha256_sync = sha256_sync;
      function sha256_fallback(source) {
        return __async(this, null, function* () {
          return sha256_sync(source);
        });
      }
      exports.sha256_fallback = sha256_fallback;
      function sha256(source) {
        return (0, ton_crypto_primitives_1.sha256)(source);
      }
      exports.sha256 = sha256;
    }
  });

  // node_modules/ton-crypto/dist/primitives/sha512.js
  var require_sha5122 = __commonJS({
    "node_modules/ton-crypto/dist/primitives/sha512.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha512 = exports.sha512_fallback = exports.sha512_sync = void 0;
      var jssha_1 = __importDefault(require_sha());
      var ton_crypto_primitives_1 = require_browser();
      function sha512_sync(source) {
        let src;
        if (typeof source === "string") {
          src = Buffer.from(source, "utf-8").toString("hex");
        } else {
          src = source.toString("hex");
        }
        let hasher = new jssha_1.default("SHA-512", "HEX");
        hasher.update(src);
        let res = hasher.getHash("HEX");
        return Buffer.from(res, "hex");
      }
      exports.sha512_sync = sha512_sync;
      function sha512_fallback(source) {
        return __async(this, null, function* () {
          return sha512_sync(source);
        });
      }
      exports.sha512_fallback = sha512_fallback;
      function sha512(source) {
        return __async(this, null, function* () {
          return (0, ton_crypto_primitives_1.sha512)(source);
        });
      }
      exports.sha512 = sha512;
    }
  });

  // node_modules/ton-crypto/dist/primitives/pbkdf2_sha512.js
  var require_pbkdf2_sha5122 = __commonJS({
    "node_modules/ton-crypto/dist/primitives/pbkdf2_sha512.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pbkdf2_sha512 = void 0;
      var ton_crypto_primitives_1 = require_browser();
      function pbkdf2_sha512(key, salt, iterations, keyLen) {
        return (0, ton_crypto_primitives_1.pbkdf2_sha512)(key, salt, iterations, keyLen);
      }
      exports.pbkdf2_sha512 = pbkdf2_sha512;
    }
  });

  // node_modules/ton-crypto/dist/primitives/hmac_sha512.js
  var require_hmac_sha5122 = __commonJS({
    "node_modules/ton-crypto/dist/primitives/hmac_sha512.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hmac_sha512 = exports.hmac_sha512_fallback = void 0;
      var jssha_1 = __importDefault(require_sha());
      var ton_crypto_primitives_1 = require_browser();
      function hmac_sha512_fallback(key, data) {
        return __async(this, null, function* () {
          let keyBuffer = typeof key === "string" ? Buffer.from(key, "utf-8") : key;
          let dataBuffer = typeof data === "string" ? Buffer.from(data, "utf-8") : data;
          const shaObj = new jssha_1.default("SHA-512", "HEX", {
            hmacKey: { value: keyBuffer.toString("hex"), format: "HEX" }
          });
          shaObj.update(dataBuffer.toString("hex"));
          const hmac = shaObj.getHash("HEX");
          return Buffer.from(hmac, "hex");
        });
      }
      exports.hmac_sha512_fallback = hmac_sha512_fallback;
      function hmac_sha512(key, data) {
        return (0, ton_crypto_primitives_1.hmac_sha512)(key, data);
      }
      exports.hmac_sha512 = hmac_sha512;
    }
  });

  // node_modules/ton-crypto/dist/primitives/getSecureRandom.js
  var require_getSecureRandom2 = __commonJS({
    "node_modules/ton-crypto/dist/primitives/getSecureRandom.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getSecureRandomNumber = exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
      var ton_crypto_primitives_1 = require_browser();
      function getSecureRandomBytes(size) {
        return __async(this, null, function* () {
          return (0, ton_crypto_primitives_1.getSecureRandomBytes)(size);
        });
      }
      exports.getSecureRandomBytes = getSecureRandomBytes;
      function getSecureRandomWords(size) {
        return __async(this, null, function* () {
          return getSecureRandomWords(size);
        });
      }
      exports.getSecureRandomWords = getSecureRandomWords;
      function getSecureRandomNumber(min, max) {
        return __async(this, null, function* () {
          let range = max - min;
          var bitsNeeded = Math.ceil(Math.log2(range));
          if (bitsNeeded > 53) {
            throw new Error("Range is too large");
          }
          var bytesNeeded = Math.ceil(bitsNeeded / 8);
          var mask = Math.pow(2, bitsNeeded) - 1;
          while (true) {
            let res = yield getSecureRandomBytes(bitsNeeded);
            let power = (bytesNeeded - 1) * 8;
            let numberValue = 0;
            for (var i = 0; i < bytesNeeded; i++) {
              numberValue += res[i] * Math.pow(2, power);
              power -= 8;
            }
            numberValue = numberValue & mask;
            if (numberValue >= range) {
              continue;
            }
            return min + numberValue;
          }
        });
      }
      exports.getSecureRandomNumber = getSecureRandomNumber;
    }
  });

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // node_modules/tweetnacl/nacl-fast.js
  var require_nacl_fast = __commonJS({
    "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
      (function(nacl) {
        "use strict";
        var gf = function(init) {
          var i, r = new Float64Array(16);
          if (init)
            for (i = 0; i < init.length; i++)
              r[i] = init[i];
          return r;
        };
        var randombytes = function() {
          throw new Error("no PRNG");
        };
        var _0 = new Uint8Array(16);
        var _9 = new Uint8Array(32);
        _9[0] = 9;
        var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
        function ts64(x, i, h, l) {
          x[i] = h >> 24 & 255;
          x[i + 1] = h >> 16 & 255;
          x[i + 2] = h >> 8 & 255;
          x[i + 3] = h & 255;
          x[i + 4] = l >> 24 & 255;
          x[i + 5] = l >> 16 & 255;
          x[i + 6] = l >> 8 & 255;
          x[i + 7] = l & 255;
        }
        function vn(x, xi, y, yi, n) {
          var i, d = 0;
          for (i = 0; i < n; i++)
            d |= x[xi + i] ^ y[yi + i];
          return (1 & d - 1 >>> 8) - 1;
        }
        function crypto_verify_16(x, xi, y, yi) {
          return vn(x, xi, y, yi, 16);
        }
        function crypto_verify_32(x, xi, y, yi) {
          return vn(x, xi, y, yi, 32);
        }
        function core_salsa20(o, p, k, c) {
          var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
          var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
          for (var i = 0; i < 20; i += 2) {
            u = x0 + x12 | 0;
            x4 ^= u << 7 | u >>> 32 - 7;
            u = x4 + x0 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x4 | 0;
            x12 ^= u << 13 | u >>> 32 - 13;
            u = x12 + x8 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x1 | 0;
            x9 ^= u << 7 | u >>> 32 - 7;
            u = x9 + x5 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x9 | 0;
            x1 ^= u << 13 | u >>> 32 - 13;
            u = x1 + x13 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x6 | 0;
            x14 ^= u << 7 | u >>> 32 - 7;
            u = x14 + x10 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x14 | 0;
            x6 ^= u << 13 | u >>> 32 - 13;
            u = x6 + x2 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x11 | 0;
            x3 ^= u << 7 | u >>> 32 - 7;
            u = x3 + x15 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x3 | 0;
            x11 ^= u << 13 | u >>> 32 - 13;
            u = x11 + x7 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
            u = x0 + x3 | 0;
            x1 ^= u << 7 | u >>> 32 - 7;
            u = x1 + x0 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x1 | 0;
            x3 ^= u << 13 | u >>> 32 - 13;
            u = x3 + x2 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x4 | 0;
            x6 ^= u << 7 | u >>> 32 - 7;
            u = x6 + x5 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x6 | 0;
            x4 ^= u << 13 | u >>> 32 - 13;
            u = x4 + x7 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x9 | 0;
            x11 ^= u << 7 | u >>> 32 - 7;
            u = x11 + x10 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x11 | 0;
            x9 ^= u << 13 | u >>> 32 - 13;
            u = x9 + x8 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x14 | 0;
            x12 ^= u << 7 | u >>> 32 - 7;
            u = x12 + x15 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x12 | 0;
            x14 ^= u << 13 | u >>> 32 - 13;
            u = x14 + x13 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
          }
          x0 = x0 + j0 | 0;
          x1 = x1 + j1 | 0;
          x2 = x2 + j2 | 0;
          x3 = x3 + j3 | 0;
          x4 = x4 + j4 | 0;
          x5 = x5 + j5 | 0;
          x6 = x6 + j6 | 0;
          x7 = x7 + j7 | 0;
          x8 = x8 + j8 | 0;
          x9 = x9 + j9 | 0;
          x10 = x10 + j10 | 0;
          x11 = x11 + j11 | 0;
          x12 = x12 + j12 | 0;
          x13 = x13 + j13 | 0;
          x14 = x14 + j14 | 0;
          x15 = x15 + j15 | 0;
          o[0] = x0 >>> 0 & 255;
          o[1] = x0 >>> 8 & 255;
          o[2] = x0 >>> 16 & 255;
          o[3] = x0 >>> 24 & 255;
          o[4] = x1 >>> 0 & 255;
          o[5] = x1 >>> 8 & 255;
          o[6] = x1 >>> 16 & 255;
          o[7] = x1 >>> 24 & 255;
          o[8] = x2 >>> 0 & 255;
          o[9] = x2 >>> 8 & 255;
          o[10] = x2 >>> 16 & 255;
          o[11] = x2 >>> 24 & 255;
          o[12] = x3 >>> 0 & 255;
          o[13] = x3 >>> 8 & 255;
          o[14] = x3 >>> 16 & 255;
          o[15] = x3 >>> 24 & 255;
          o[16] = x4 >>> 0 & 255;
          o[17] = x4 >>> 8 & 255;
          o[18] = x4 >>> 16 & 255;
          o[19] = x4 >>> 24 & 255;
          o[20] = x5 >>> 0 & 255;
          o[21] = x5 >>> 8 & 255;
          o[22] = x5 >>> 16 & 255;
          o[23] = x5 >>> 24 & 255;
          o[24] = x6 >>> 0 & 255;
          o[25] = x6 >>> 8 & 255;
          o[26] = x6 >>> 16 & 255;
          o[27] = x6 >>> 24 & 255;
          o[28] = x7 >>> 0 & 255;
          o[29] = x7 >>> 8 & 255;
          o[30] = x7 >>> 16 & 255;
          o[31] = x7 >>> 24 & 255;
          o[32] = x8 >>> 0 & 255;
          o[33] = x8 >>> 8 & 255;
          o[34] = x8 >>> 16 & 255;
          o[35] = x8 >>> 24 & 255;
          o[36] = x9 >>> 0 & 255;
          o[37] = x9 >>> 8 & 255;
          o[38] = x9 >>> 16 & 255;
          o[39] = x9 >>> 24 & 255;
          o[40] = x10 >>> 0 & 255;
          o[41] = x10 >>> 8 & 255;
          o[42] = x10 >>> 16 & 255;
          o[43] = x10 >>> 24 & 255;
          o[44] = x11 >>> 0 & 255;
          o[45] = x11 >>> 8 & 255;
          o[46] = x11 >>> 16 & 255;
          o[47] = x11 >>> 24 & 255;
          o[48] = x12 >>> 0 & 255;
          o[49] = x12 >>> 8 & 255;
          o[50] = x12 >>> 16 & 255;
          o[51] = x12 >>> 24 & 255;
          o[52] = x13 >>> 0 & 255;
          o[53] = x13 >>> 8 & 255;
          o[54] = x13 >>> 16 & 255;
          o[55] = x13 >>> 24 & 255;
          o[56] = x14 >>> 0 & 255;
          o[57] = x14 >>> 8 & 255;
          o[58] = x14 >>> 16 & 255;
          o[59] = x14 >>> 24 & 255;
          o[60] = x15 >>> 0 & 255;
          o[61] = x15 >>> 8 & 255;
          o[62] = x15 >>> 16 & 255;
          o[63] = x15 >>> 24 & 255;
        }
        function core_hsalsa20(o, p, k, c) {
          var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
          var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
          for (var i = 0; i < 20; i += 2) {
            u = x0 + x12 | 0;
            x4 ^= u << 7 | u >>> 32 - 7;
            u = x4 + x0 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x4 | 0;
            x12 ^= u << 13 | u >>> 32 - 13;
            u = x12 + x8 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x1 | 0;
            x9 ^= u << 7 | u >>> 32 - 7;
            u = x9 + x5 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x9 | 0;
            x1 ^= u << 13 | u >>> 32 - 13;
            u = x1 + x13 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x6 | 0;
            x14 ^= u << 7 | u >>> 32 - 7;
            u = x14 + x10 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x14 | 0;
            x6 ^= u << 13 | u >>> 32 - 13;
            u = x6 + x2 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x11 | 0;
            x3 ^= u << 7 | u >>> 32 - 7;
            u = x3 + x15 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x3 | 0;
            x11 ^= u << 13 | u >>> 32 - 13;
            u = x11 + x7 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
            u = x0 + x3 | 0;
            x1 ^= u << 7 | u >>> 32 - 7;
            u = x1 + x0 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x1 | 0;
            x3 ^= u << 13 | u >>> 32 - 13;
            u = x3 + x2 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x4 | 0;
            x6 ^= u << 7 | u >>> 32 - 7;
            u = x6 + x5 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x6 | 0;
            x4 ^= u << 13 | u >>> 32 - 13;
            u = x4 + x7 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x9 | 0;
            x11 ^= u << 7 | u >>> 32 - 7;
            u = x11 + x10 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x11 | 0;
            x9 ^= u << 13 | u >>> 32 - 13;
            u = x9 + x8 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x14 | 0;
            x12 ^= u << 7 | u >>> 32 - 7;
            u = x12 + x15 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x12 | 0;
            x14 ^= u << 13 | u >>> 32 - 13;
            u = x14 + x13 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
          }
          o[0] = x0 >>> 0 & 255;
          o[1] = x0 >>> 8 & 255;
          o[2] = x0 >>> 16 & 255;
          o[3] = x0 >>> 24 & 255;
          o[4] = x5 >>> 0 & 255;
          o[5] = x5 >>> 8 & 255;
          o[6] = x5 >>> 16 & 255;
          o[7] = x5 >>> 24 & 255;
          o[8] = x10 >>> 0 & 255;
          o[9] = x10 >>> 8 & 255;
          o[10] = x10 >>> 16 & 255;
          o[11] = x10 >>> 24 & 255;
          o[12] = x15 >>> 0 & 255;
          o[13] = x15 >>> 8 & 255;
          o[14] = x15 >>> 16 & 255;
          o[15] = x15 >>> 24 & 255;
          o[16] = x6 >>> 0 & 255;
          o[17] = x6 >>> 8 & 255;
          o[18] = x6 >>> 16 & 255;
          o[19] = x6 >>> 24 & 255;
          o[20] = x7 >>> 0 & 255;
          o[21] = x7 >>> 8 & 255;
          o[22] = x7 >>> 16 & 255;
          o[23] = x7 >>> 24 & 255;
          o[24] = x8 >>> 0 & 255;
          o[25] = x8 >>> 8 & 255;
          o[26] = x8 >>> 16 & 255;
          o[27] = x8 >>> 24 & 255;
          o[28] = x9 >>> 0 & 255;
          o[29] = x9 >>> 8 & 255;
          o[30] = x9 >>> 16 & 255;
          o[31] = x9 >>> 24 & 255;
        }
        function crypto_core_salsa20(out, inp, k, c) {
          core_salsa20(out, inp, k, c);
        }
        function crypto_core_hsalsa20(out, inp, k, c) {
          core_hsalsa20(out, inp, k, c);
        }
        var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
        function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
          var z = new Uint8Array(16), x = new Uint8Array(64);
          var u, i;
          for (i = 0; i < 16; i++)
            z[i] = 0;
          for (i = 0; i < 8; i++)
            z[i] = n[i];
          while (b >= 64) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0; i < 64; i++)
              c[cpos + i] = m[mpos + i] ^ x[i];
            u = 1;
            for (i = 8; i < 16; i++) {
              u = u + (z[i] & 255) | 0;
              z[i] = u & 255;
              u >>>= 8;
            }
            b -= 64;
            cpos += 64;
            mpos += 64;
          }
          if (b > 0) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0; i < b; i++)
              c[cpos + i] = m[mpos + i] ^ x[i];
          }
          return 0;
        }
        function crypto_stream_salsa20(c, cpos, b, n, k) {
          var z = new Uint8Array(16), x = new Uint8Array(64);
          var u, i;
          for (i = 0; i < 16; i++)
            z[i] = 0;
          for (i = 0; i < 8; i++)
            z[i] = n[i];
          while (b >= 64) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0; i < 64; i++)
              c[cpos + i] = x[i];
            u = 1;
            for (i = 8; i < 16; i++) {
              u = u + (z[i] & 255) | 0;
              z[i] = u & 255;
              u >>>= 8;
            }
            b -= 64;
            cpos += 64;
          }
          if (b > 0) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0; i < b; i++)
              c[cpos + i] = x[i];
          }
          return 0;
        }
        function crypto_stream(c, cpos, d, n, k) {
          var s = new Uint8Array(32);
          crypto_core_hsalsa20(s, n, k, sigma);
          var sn = new Uint8Array(8);
          for (var i = 0; i < 8; i++)
            sn[i] = n[i + 16];
          return crypto_stream_salsa20(c, cpos, d, sn, s);
        }
        function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
          var s = new Uint8Array(32);
          crypto_core_hsalsa20(s, n, k, sigma);
          var sn = new Uint8Array(8);
          for (var i = 0; i < 8; i++)
            sn[i] = n[i + 16];
          return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
        }
        var poly1305 = function(key) {
          this.buffer = new Uint8Array(16);
          this.r = new Uint16Array(10);
          this.h = new Uint16Array(10);
          this.pad = new Uint16Array(8);
          this.leftover = 0;
          this.fin = 0;
          var t0, t1, t2, t3, t4, t5, t6, t7;
          t0 = key[0] & 255 | (key[1] & 255) << 8;
          this.r[0] = t0 & 8191;
          t1 = key[2] & 255 | (key[3] & 255) << 8;
          this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
          t2 = key[4] & 255 | (key[5] & 255) << 8;
          this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
          t3 = key[6] & 255 | (key[7] & 255) << 8;
          this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
          t4 = key[8] & 255 | (key[9] & 255) << 8;
          this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
          this.r[5] = t4 >>> 1 & 8190;
          t5 = key[10] & 255 | (key[11] & 255) << 8;
          this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
          t6 = key[12] & 255 | (key[13] & 255) << 8;
          this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
          t7 = key[14] & 255 | (key[15] & 255) << 8;
          this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
          this.r[9] = t7 >>> 5 & 127;
          this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
          this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
          this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
          this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
          this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
          this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
          this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
          this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
        };
        poly1305.prototype.blocks = function(m, mpos, bytes) {
          var hibit = this.fin ? 0 : 1 << 11;
          var t0, t1, t2, t3, t4, t5, t6, t7, c;
          var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
          var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
          var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
          while (bytes >= 16) {
            t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
            h0 += t0 & 8191;
            t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 8191;
            t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
            h2 += (t1 >>> 10 | t2 << 6) & 8191;
            t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
            h3 += (t2 >>> 7 | t3 << 9) & 8191;
            t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
            h4 += (t3 >>> 4 | t4 << 12) & 8191;
            h5 += t4 >>> 1 & 8191;
            t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 8191;
            t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 8191;
            t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 8191;
            h9 += t7 >>> 5 | hibit;
            c = 0;
            d0 = c;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c = d0 >>> 13;
            d0 &= 8191;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c += d0 >>> 13;
            d0 &= 8191;
            d1 = c;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c = d1 >>> 13;
            d1 &= 8191;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c += d1 >>> 13;
            d1 &= 8191;
            d2 = c;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c = d2 >>> 13;
            d2 &= 8191;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c += d2 >>> 13;
            d2 &= 8191;
            d3 = c;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c = d3 >>> 13;
            d3 &= 8191;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c += d3 >>> 13;
            d3 &= 8191;
            d4 = c;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c = d4 >>> 13;
            d4 &= 8191;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c += d4 >>> 13;
            d4 &= 8191;
            d5 = c;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c = d5 >>> 13;
            d5 &= 8191;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c += d5 >>> 13;
            d5 &= 8191;
            d6 = c;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c = d6 >>> 13;
            d6 &= 8191;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c += d6 >>> 13;
            d6 &= 8191;
            d7 = c;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c = d7 >>> 13;
            d7 &= 8191;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c += d7 >>> 13;
            d7 &= 8191;
            d8 = c;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c = d8 >>> 13;
            d8 &= 8191;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c += d8 >>> 13;
            d8 &= 8191;
            d9 = c;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c = d9 >>> 13;
            d9 &= 8191;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c += d9 >>> 13;
            d9 &= 8191;
            c = (c << 2) + c | 0;
            c = c + d0 | 0;
            d0 = c & 8191;
            c = c >>> 13;
            d1 += c;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
          }
          this.h[0] = h0;
          this.h[1] = h1;
          this.h[2] = h2;
          this.h[3] = h3;
          this.h[4] = h4;
          this.h[5] = h5;
          this.h[6] = h6;
          this.h[7] = h7;
          this.h[8] = h8;
          this.h[9] = h9;
        };
        poly1305.prototype.finish = function(mac, macpos) {
          var g = new Uint16Array(10);
          var c, mask, f, i;
          if (this.leftover) {
            i = this.leftover;
            this.buffer[i++] = 1;
            for (; i < 16; i++)
              this.buffer[i] = 0;
            this.fin = 1;
            this.blocks(this.buffer, 0, 16);
          }
          c = this.h[1] >>> 13;
          this.h[1] &= 8191;
          for (i = 2; i < 10; i++) {
            this.h[i] += c;
            c = this.h[i] >>> 13;
            this.h[i] &= 8191;
          }
          this.h[0] += c * 5;
          c = this.h[0] >>> 13;
          this.h[0] &= 8191;
          this.h[1] += c;
          c = this.h[1] >>> 13;
          this.h[1] &= 8191;
          this.h[2] += c;
          g[0] = this.h[0] + 5;
          c = g[0] >>> 13;
          g[0] &= 8191;
          for (i = 1; i < 10; i++) {
            g[i] = this.h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 8191;
          }
          g[9] -= 1 << 13;
          mask = (c ^ 1) - 1;
          for (i = 0; i < 10; i++)
            g[i] &= mask;
          mask = ~mask;
          for (i = 0; i < 10; i++)
            this.h[i] = this.h[i] & mask | g[i];
          this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
          this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
          this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
          this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
          this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
          this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
          this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
          this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
          f = this.h[0] + this.pad[0];
          this.h[0] = f & 65535;
          for (i = 1; i < 8; i++) {
            f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
            this.h[i] = f & 65535;
          }
          mac[macpos + 0] = this.h[0] >>> 0 & 255;
          mac[macpos + 1] = this.h[0] >>> 8 & 255;
          mac[macpos + 2] = this.h[1] >>> 0 & 255;
          mac[macpos + 3] = this.h[1] >>> 8 & 255;
          mac[macpos + 4] = this.h[2] >>> 0 & 255;
          mac[macpos + 5] = this.h[2] >>> 8 & 255;
          mac[macpos + 6] = this.h[3] >>> 0 & 255;
          mac[macpos + 7] = this.h[3] >>> 8 & 255;
          mac[macpos + 8] = this.h[4] >>> 0 & 255;
          mac[macpos + 9] = this.h[4] >>> 8 & 255;
          mac[macpos + 10] = this.h[5] >>> 0 & 255;
          mac[macpos + 11] = this.h[5] >>> 8 & 255;
          mac[macpos + 12] = this.h[6] >>> 0 & 255;
          mac[macpos + 13] = this.h[6] >>> 8 & 255;
          mac[macpos + 14] = this.h[7] >>> 0 & 255;
          mac[macpos + 15] = this.h[7] >>> 8 & 255;
        };
        poly1305.prototype.update = function(m, mpos, bytes) {
          var i, want;
          if (this.leftover) {
            want = 16 - this.leftover;
            if (want > bytes)
              want = bytes;
            for (i = 0; i < want; i++)
              this.buffer[this.leftover + i] = m[mpos + i];
            bytes -= want;
            mpos += want;
            this.leftover += want;
            if (this.leftover < 16)
              return;
            this.blocks(this.buffer, 0, 16);
            this.leftover = 0;
          }
          if (bytes >= 16) {
            want = bytes - bytes % 16;
            this.blocks(m, mpos, want);
            mpos += want;
            bytes -= want;
          }
          if (bytes) {
            for (i = 0; i < bytes; i++)
              this.buffer[this.leftover + i] = m[mpos + i];
            this.leftover += bytes;
          }
        };
        function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
          var s = new poly1305(k);
          s.update(m, mpos, n);
          s.finish(out, outpos);
          return 0;
        }
        function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
          var x = new Uint8Array(16);
          crypto_onetimeauth(x, 0, m, mpos, n, k);
          return crypto_verify_16(h, hpos, x, 0);
        }
        function crypto_secretbox(c, m, d, n, k) {
          var i;
          if (d < 32)
            return -1;
          crypto_stream_xor(c, 0, m, 0, d, n, k);
          crypto_onetimeauth(c, 16, c, 32, d - 32, c);
          for (i = 0; i < 16; i++)
            c[i] = 0;
          return 0;
        }
        function crypto_secretbox_open(m, c, d, n, k) {
          var i;
          var x = new Uint8Array(32);
          if (d < 32)
            return -1;
          crypto_stream(x, 0, 32, n, k);
          if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
            return -1;
          crypto_stream_xor(m, 0, c, 0, d, n, k);
          for (i = 0; i < 32; i++)
            m[i] = 0;
          return 0;
        }
        function set25519(r, a) {
          var i;
          for (i = 0; i < 16; i++)
            r[i] = a[i] | 0;
        }
        function car25519(o) {
          var i, v, c = 1;
          for (i = 0; i < 16; i++) {
            v = o[i] + c + 65535;
            c = Math.floor(v / 65536);
            o[i] = v - c * 65536;
          }
          o[0] += c - 1 + 37 * (c - 1);
        }
        function sel25519(p, q, b) {
          var t, c = ~(b - 1);
          for (var i = 0; i < 16; i++) {
            t = c & (p[i] ^ q[i]);
            p[i] ^= t;
            q[i] ^= t;
          }
        }
        function pack25519(o, n) {
          var i, j, b;
          var m = gf(), t = gf();
          for (i = 0; i < 16; i++)
            t[i] = n[i];
          car25519(t);
          car25519(t);
          car25519(t);
          for (j = 0; j < 2; j++) {
            m[0] = t[0] - 65517;
            for (i = 1; i < 15; i++) {
              m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
              m[i - 1] &= 65535;
            }
            m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
            b = m[15] >> 16 & 1;
            m[14] &= 65535;
            sel25519(t, m, 1 - b);
          }
          for (i = 0; i < 16; i++) {
            o[2 * i] = t[i] & 255;
            o[2 * i + 1] = t[i] >> 8;
          }
        }
        function neq25519(a, b) {
          var c = new Uint8Array(32), d = new Uint8Array(32);
          pack25519(c, a);
          pack25519(d, b);
          return crypto_verify_32(c, 0, d, 0);
        }
        function par25519(a) {
          var d = new Uint8Array(32);
          pack25519(d, a);
          return d[0] & 1;
        }
        function unpack25519(o, n) {
          var i;
          for (i = 0; i < 16; i++)
            o[i] = n[2 * i] + (n[2 * i + 1] << 8);
          o[15] &= 32767;
        }
        function A(o, a, b) {
          for (var i = 0; i < 16; i++)
            o[i] = a[i] + b[i];
        }
        function Z(o, a, b) {
          for (var i = 0; i < 16; i++)
            o[i] = a[i] - b[i];
        }
        function M(o, a, b) {
          var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
          v = a[0];
          t0 += v * b0;
          t1 += v * b1;
          t2 += v * b2;
          t3 += v * b3;
          t4 += v * b4;
          t5 += v * b5;
          t6 += v * b6;
          t7 += v * b7;
          t8 += v * b8;
          t9 += v * b9;
          t10 += v * b10;
          t11 += v * b11;
          t12 += v * b12;
          t13 += v * b13;
          t14 += v * b14;
          t15 += v * b15;
          v = a[1];
          t1 += v * b0;
          t2 += v * b1;
          t3 += v * b2;
          t4 += v * b3;
          t5 += v * b4;
          t6 += v * b5;
          t7 += v * b6;
          t8 += v * b7;
          t9 += v * b8;
          t10 += v * b9;
          t11 += v * b10;
          t12 += v * b11;
          t13 += v * b12;
          t14 += v * b13;
          t15 += v * b14;
          t16 += v * b15;
          v = a[2];
          t2 += v * b0;
          t3 += v * b1;
          t4 += v * b2;
          t5 += v * b3;
          t6 += v * b4;
          t7 += v * b5;
          t8 += v * b6;
          t9 += v * b7;
          t10 += v * b8;
          t11 += v * b9;
          t12 += v * b10;
          t13 += v * b11;
          t14 += v * b12;
          t15 += v * b13;
          t16 += v * b14;
          t17 += v * b15;
          v = a[3];
          t3 += v * b0;
          t4 += v * b1;
          t5 += v * b2;
          t6 += v * b3;
          t7 += v * b4;
          t8 += v * b5;
          t9 += v * b6;
          t10 += v * b7;
          t11 += v * b8;
          t12 += v * b9;
          t13 += v * b10;
          t14 += v * b11;
          t15 += v * b12;
          t16 += v * b13;
          t17 += v * b14;
          t18 += v * b15;
          v = a[4];
          t4 += v * b0;
          t5 += v * b1;
          t6 += v * b2;
          t7 += v * b3;
          t8 += v * b4;
          t9 += v * b5;
          t10 += v * b6;
          t11 += v * b7;
          t12 += v * b8;
          t13 += v * b9;
          t14 += v * b10;
          t15 += v * b11;
          t16 += v * b12;
          t17 += v * b13;
          t18 += v * b14;
          t19 += v * b15;
          v = a[5];
          t5 += v * b0;
          t6 += v * b1;
          t7 += v * b2;
          t8 += v * b3;
          t9 += v * b4;
          t10 += v * b5;
          t11 += v * b6;
          t12 += v * b7;
          t13 += v * b8;
          t14 += v * b9;
          t15 += v * b10;
          t16 += v * b11;
          t17 += v * b12;
          t18 += v * b13;
          t19 += v * b14;
          t20 += v * b15;
          v = a[6];
          t6 += v * b0;
          t7 += v * b1;
          t8 += v * b2;
          t9 += v * b3;
          t10 += v * b4;
          t11 += v * b5;
          t12 += v * b6;
          t13 += v * b7;
          t14 += v * b8;
          t15 += v * b9;
          t16 += v * b10;
          t17 += v * b11;
          t18 += v * b12;
          t19 += v * b13;
          t20 += v * b14;
          t21 += v * b15;
          v = a[7];
          t7 += v * b0;
          t8 += v * b1;
          t9 += v * b2;
          t10 += v * b3;
          t11 += v * b4;
          t12 += v * b5;
          t13 += v * b6;
          t14 += v * b7;
          t15 += v * b8;
          t16 += v * b9;
          t17 += v * b10;
          t18 += v * b11;
          t19 += v * b12;
          t20 += v * b13;
          t21 += v * b14;
          t22 += v * b15;
          v = a[8];
          t8 += v * b0;
          t9 += v * b1;
          t10 += v * b2;
          t11 += v * b3;
          t12 += v * b4;
          t13 += v * b5;
          t14 += v * b6;
          t15 += v * b7;
          t16 += v * b8;
          t17 += v * b9;
          t18 += v * b10;
          t19 += v * b11;
          t20 += v * b12;
          t21 += v * b13;
          t22 += v * b14;
          t23 += v * b15;
          v = a[9];
          t9 += v * b0;
          t10 += v * b1;
          t11 += v * b2;
          t12 += v * b3;
          t13 += v * b4;
          t14 += v * b5;
          t15 += v * b6;
          t16 += v * b7;
          t17 += v * b8;
          t18 += v * b9;
          t19 += v * b10;
          t20 += v * b11;
          t21 += v * b12;
          t22 += v * b13;
          t23 += v * b14;
          t24 += v * b15;
          v = a[10];
          t10 += v * b0;
          t11 += v * b1;
          t12 += v * b2;
          t13 += v * b3;
          t14 += v * b4;
          t15 += v * b5;
          t16 += v * b6;
          t17 += v * b7;
          t18 += v * b8;
          t19 += v * b9;
          t20 += v * b10;
          t21 += v * b11;
          t22 += v * b12;
          t23 += v * b13;
          t24 += v * b14;
          t25 += v * b15;
          v = a[11];
          t11 += v * b0;
          t12 += v * b1;
          t13 += v * b2;
          t14 += v * b3;
          t15 += v * b4;
          t16 += v * b5;
          t17 += v * b6;
          t18 += v * b7;
          t19 += v * b8;
          t20 += v * b9;
          t21 += v * b10;
          t22 += v * b11;
          t23 += v * b12;
          t24 += v * b13;
          t25 += v * b14;
          t26 += v * b15;
          v = a[12];
          t12 += v * b0;
          t13 += v * b1;
          t14 += v * b2;
          t15 += v * b3;
          t16 += v * b4;
          t17 += v * b5;
          t18 += v * b6;
          t19 += v * b7;
          t20 += v * b8;
          t21 += v * b9;
          t22 += v * b10;
          t23 += v * b11;
          t24 += v * b12;
          t25 += v * b13;
          t26 += v * b14;
          t27 += v * b15;
          v = a[13];
          t13 += v * b0;
          t14 += v * b1;
          t15 += v * b2;
          t16 += v * b3;
          t17 += v * b4;
          t18 += v * b5;
          t19 += v * b6;
          t20 += v * b7;
          t21 += v * b8;
          t22 += v * b9;
          t23 += v * b10;
          t24 += v * b11;
          t25 += v * b12;
          t26 += v * b13;
          t27 += v * b14;
          t28 += v * b15;
          v = a[14];
          t14 += v * b0;
          t15 += v * b1;
          t16 += v * b2;
          t17 += v * b3;
          t18 += v * b4;
          t19 += v * b5;
          t20 += v * b6;
          t21 += v * b7;
          t22 += v * b8;
          t23 += v * b9;
          t24 += v * b10;
          t25 += v * b11;
          t26 += v * b12;
          t27 += v * b13;
          t28 += v * b14;
          t29 += v * b15;
          v = a[15];
          t15 += v * b0;
          t16 += v * b1;
          t17 += v * b2;
          t18 += v * b3;
          t19 += v * b4;
          t20 += v * b5;
          t21 += v * b6;
          t22 += v * b7;
          t23 += v * b8;
          t24 += v * b9;
          t25 += v * b10;
          t26 += v * b11;
          t27 += v * b12;
          t28 += v * b13;
          t29 += v * b14;
          t30 += v * b15;
          t0 += 38 * t16;
          t1 += 38 * t17;
          t2 += 38 * t18;
          t3 += 38 * t19;
          t4 += 38 * t20;
          t5 += 38 * t21;
          t6 += 38 * t22;
          t7 += 38 * t23;
          t8 += 38 * t24;
          t9 += 38 * t25;
          t10 += 38 * t26;
          t11 += 38 * t27;
          t12 += 38 * t28;
          t13 += 38 * t29;
          t14 += 38 * t30;
          c = 1;
          v = t0 + c + 65535;
          c = Math.floor(v / 65536);
          t0 = v - c * 65536;
          v = t1 + c + 65535;
          c = Math.floor(v / 65536);
          t1 = v - c * 65536;
          v = t2 + c + 65535;
          c = Math.floor(v / 65536);
          t2 = v - c * 65536;
          v = t3 + c + 65535;
          c = Math.floor(v / 65536);
          t3 = v - c * 65536;
          v = t4 + c + 65535;
          c = Math.floor(v / 65536);
          t4 = v - c * 65536;
          v = t5 + c + 65535;
          c = Math.floor(v / 65536);
          t5 = v - c * 65536;
          v = t6 + c + 65535;
          c = Math.floor(v / 65536);
          t6 = v - c * 65536;
          v = t7 + c + 65535;
          c = Math.floor(v / 65536);
          t7 = v - c * 65536;
          v = t8 + c + 65535;
          c = Math.floor(v / 65536);
          t8 = v - c * 65536;
          v = t9 + c + 65535;
          c = Math.floor(v / 65536);
          t9 = v - c * 65536;
          v = t10 + c + 65535;
          c = Math.floor(v / 65536);
          t10 = v - c * 65536;
          v = t11 + c + 65535;
          c = Math.floor(v / 65536);
          t11 = v - c * 65536;
          v = t12 + c + 65535;
          c = Math.floor(v / 65536);
          t12 = v - c * 65536;
          v = t13 + c + 65535;
          c = Math.floor(v / 65536);
          t13 = v - c * 65536;
          v = t14 + c + 65535;
          c = Math.floor(v / 65536);
          t14 = v - c * 65536;
          v = t15 + c + 65535;
          c = Math.floor(v / 65536);
          t15 = v - c * 65536;
          t0 += c - 1 + 37 * (c - 1);
          c = 1;
          v = t0 + c + 65535;
          c = Math.floor(v / 65536);
          t0 = v - c * 65536;
          v = t1 + c + 65535;
          c = Math.floor(v / 65536);
          t1 = v - c * 65536;
          v = t2 + c + 65535;
          c = Math.floor(v / 65536);
          t2 = v - c * 65536;
          v = t3 + c + 65535;
          c = Math.floor(v / 65536);
          t3 = v - c * 65536;
          v = t4 + c + 65535;
          c = Math.floor(v / 65536);
          t4 = v - c * 65536;
          v = t5 + c + 65535;
          c = Math.floor(v / 65536);
          t5 = v - c * 65536;
          v = t6 + c + 65535;
          c = Math.floor(v / 65536);
          t6 = v - c * 65536;
          v = t7 + c + 65535;
          c = Math.floor(v / 65536);
          t7 = v - c * 65536;
          v = t8 + c + 65535;
          c = Math.floor(v / 65536);
          t8 = v - c * 65536;
          v = t9 + c + 65535;
          c = Math.floor(v / 65536);
          t9 = v - c * 65536;
          v = t10 + c + 65535;
          c = Math.floor(v / 65536);
          t10 = v - c * 65536;
          v = t11 + c + 65535;
          c = Math.floor(v / 65536);
          t11 = v - c * 65536;
          v = t12 + c + 65535;
          c = Math.floor(v / 65536);
          t12 = v - c * 65536;
          v = t13 + c + 65535;
          c = Math.floor(v / 65536);
          t13 = v - c * 65536;
          v = t14 + c + 65535;
          c = Math.floor(v / 65536);
          t14 = v - c * 65536;
          v = t15 + c + 65535;
          c = Math.floor(v / 65536);
          t15 = v - c * 65536;
          t0 += c - 1 + 37 * (c - 1);
          o[0] = t0;
          o[1] = t1;
          o[2] = t2;
          o[3] = t3;
          o[4] = t4;
          o[5] = t5;
          o[6] = t6;
          o[7] = t7;
          o[8] = t8;
          o[9] = t9;
          o[10] = t10;
          o[11] = t11;
          o[12] = t12;
          o[13] = t13;
          o[14] = t14;
          o[15] = t15;
        }
        function S(o, a) {
          M(o, a, a);
        }
        function inv25519(o, i) {
          var c = gf();
          var a;
          for (a = 0; a < 16; a++)
            c[a] = i[a];
          for (a = 253; a >= 0; a--) {
            S(c, c);
            if (a !== 2 && a !== 4)
              M(c, c, i);
          }
          for (a = 0; a < 16; a++)
            o[a] = c[a];
        }
        function pow2523(o, i) {
          var c = gf();
          var a;
          for (a = 0; a < 16; a++)
            c[a] = i[a];
          for (a = 250; a >= 0; a--) {
            S(c, c);
            if (a !== 1)
              M(c, c, i);
          }
          for (a = 0; a < 16; a++)
            o[a] = c[a];
        }
        function crypto_scalarmult(q, n, p) {
          var z = new Uint8Array(32);
          var x = new Float64Array(80), r, i;
          var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
          for (i = 0; i < 31; i++)
            z[i] = n[i];
          z[31] = n[31] & 127 | 64;
          z[0] &= 248;
          unpack25519(x, p);
          for (i = 0; i < 16; i++) {
            b[i] = x[i];
            d[i] = a[i] = c[i] = 0;
          }
          a[0] = d[0] = 1;
          for (i = 254; i >= 0; --i) {
            r = z[i >>> 3] >>> (i & 7) & 1;
            sel25519(a, b, r);
            sel25519(c, d, r);
            A(e, a, c);
            Z(a, a, c);
            A(c, b, d);
            Z(b, b, d);
            S(d, e);
            S(f, a);
            M(a, c, a);
            M(c, b, e);
            A(e, a, c);
            Z(a, a, c);
            S(b, a);
            Z(c, d, f);
            M(a, c, _121665);
            A(a, a, d);
            M(c, c, a);
            M(a, d, f);
            M(d, b, x);
            S(b, e);
            sel25519(a, b, r);
            sel25519(c, d, r);
          }
          for (i = 0; i < 16; i++) {
            x[i + 16] = a[i];
            x[i + 32] = c[i];
            x[i + 48] = b[i];
            x[i + 64] = d[i];
          }
          var x32 = x.subarray(32);
          var x16 = x.subarray(16);
          inv25519(x32, x32);
          M(x16, x16, x32);
          pack25519(q, x16);
          return 0;
        }
        function crypto_scalarmult_base(q, n) {
          return crypto_scalarmult(q, n, _9);
        }
        function crypto_box_keypair(y, x) {
          randombytes(x, 32);
          return crypto_scalarmult_base(y, x);
        }
        function crypto_box_beforenm(k, y, x) {
          var s = new Uint8Array(32);
          crypto_scalarmult(s, x, y);
          return crypto_core_hsalsa20(k, _0, s, sigma);
        }
        var crypto_box_afternm = crypto_secretbox;
        var crypto_box_open_afternm = crypto_secretbox_open;
        function crypto_box(c, m, d, n, y, x) {
          var k = new Uint8Array(32);
          crypto_box_beforenm(k, y, x);
          return crypto_box_afternm(c, m, d, n, k);
        }
        function crypto_box_open(m, c, d, n, y, x) {
          var k = new Uint8Array(32);
          crypto_box_beforenm(k, y, x);
          return crypto_box_open_afternm(m, c, d, n, k);
        }
        var K = [
          1116352408,
          3609767458,
          1899447441,
          602891725,
          3049323471,
          3964484399,
          3921009573,
          2173295548,
          961987163,
          4081628472,
          1508970993,
          3053834265,
          2453635748,
          2937671579,
          2870763221,
          3664609560,
          3624381080,
          2734883394,
          310598401,
          1164996542,
          607225278,
          1323610764,
          1426881987,
          3590304994,
          1925078388,
          4068182383,
          2162078206,
          991336113,
          2614888103,
          633803317,
          3248222580,
          3479774868,
          3835390401,
          2666613458,
          4022224774,
          944711139,
          264347078,
          2341262773,
          604807628,
          2007800933,
          770255983,
          1495990901,
          1249150122,
          1856431235,
          1555081692,
          3175218132,
          1996064986,
          2198950837,
          2554220882,
          3999719339,
          2821834349,
          766784016,
          2952996808,
          2566594879,
          3210313671,
          3203337956,
          3336571891,
          1034457026,
          3584528711,
          2466948901,
          113926993,
          3758326383,
          338241895,
          168717936,
          666307205,
          1188179964,
          773529912,
          1546045734,
          1294757372,
          1522805485,
          1396182291,
          2643833823,
          1695183700,
          2343527390,
          1986661051,
          1014477480,
          2177026350,
          1206759142,
          2456956037,
          344077627,
          2730485921,
          1290863460,
          2820302411,
          3158454273,
          3259730800,
          3505952657,
          3345764771,
          106217008,
          3516065817,
          3606008344,
          3600352804,
          1432725776,
          4094571909,
          1467031594,
          275423344,
          851169720,
          430227734,
          3100823752,
          506948616,
          1363258195,
          659060556,
          3750685593,
          883997877,
          3785050280,
          958139571,
          3318307427,
          1322822218,
          3812723403,
          1537002063,
          2003034995,
          1747873779,
          3602036899,
          1955562222,
          1575990012,
          2024104815,
          1125592928,
          2227730452,
          2716904306,
          2361852424,
          442776044,
          2428436474,
          593698344,
          2756734187,
          3733110249,
          3204031479,
          2999351573,
          3329325298,
          3815920427,
          3391569614,
          3928383900,
          3515267271,
          566280711,
          3940187606,
          3454069534,
          4118630271,
          4000239992,
          116418474,
          1914138554,
          174292421,
          2731055270,
          289380356,
          3203993006,
          460393269,
          320620315,
          685471733,
          587496836,
          852142971,
          1086792851,
          1017036298,
          365543100,
          1126000580,
          2618297676,
          1288033470,
          3409855158,
          1501505948,
          4234509866,
          1607167915,
          987167468,
          1816402316,
          1246189591
        ];
        function crypto_hashblocks_hl(hh, hl, m, n) {
          var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
          var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
          var pos = 0;
          while (n >= 128) {
            for (i = 0; i < 16; i++) {
              j = 8 * i + pos;
              wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
              wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
            }
            for (i = 0; i < 80; i++) {
              bh0 = ah0;
              bh1 = ah1;
              bh2 = ah2;
              bh3 = ah3;
              bh4 = ah4;
              bh5 = ah5;
              bh6 = ah6;
              bh7 = ah7;
              bl0 = al0;
              bl1 = al1;
              bl2 = al2;
              bl3 = al3;
              bl4 = al4;
              bl5 = al5;
              bl6 = al6;
              bl7 = al7;
              h = ah7;
              l = al7;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
              l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = ah4 & ah5 ^ ~ah4 & ah6;
              l = al4 & al5 ^ ~al4 & al6;
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = K[i * 2];
              l = K[i * 2 + 1];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = wh[i % 16];
              l = wl[i % 16];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              th = c & 65535 | d << 16;
              tl = a & 65535 | b << 16;
              h = th;
              l = tl;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
              l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
              l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              bh7 = c & 65535 | d << 16;
              bl7 = a & 65535 | b << 16;
              h = bh3;
              l = bl3;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = th;
              l = tl;
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              bh3 = c & 65535 | d << 16;
              bl3 = a & 65535 | b << 16;
              ah1 = bh0;
              ah2 = bh1;
              ah3 = bh2;
              ah4 = bh3;
              ah5 = bh4;
              ah6 = bh5;
              ah7 = bh6;
              ah0 = bh7;
              al1 = bl0;
              al2 = bl1;
              al3 = bl2;
              al4 = bl3;
              al5 = bl4;
              al6 = bl5;
              al7 = bl6;
              al0 = bl7;
              if (i % 16 === 15) {
                for (j = 0; j < 16; j++) {
                  h = wh[j];
                  l = wl[j];
                  a = l & 65535;
                  b = l >>> 16;
                  c = h & 65535;
                  d = h >>> 16;
                  h = wh[(j + 9) % 16];
                  l = wl[(j + 9) % 16];
                  a += l & 65535;
                  b += l >>> 16;
                  c += h & 65535;
                  d += h >>> 16;
                  th = wh[(j + 1) % 16];
                  tl = wl[(j + 1) % 16];
                  h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                  l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                  a += l & 65535;
                  b += l >>> 16;
                  c += h & 65535;
                  d += h >>> 16;
                  th = wh[(j + 14) % 16];
                  tl = wl[(j + 14) % 16];
                  h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                  l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                  a += l & 65535;
                  b += l >>> 16;
                  c += h & 65535;
                  d += h >>> 16;
                  b += a >>> 16;
                  c += b >>> 16;
                  d += c >>> 16;
                  wh[j] = c & 65535 | d << 16;
                  wl[j] = a & 65535 | b << 16;
                }
              }
            }
            h = ah0;
            l = al0;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[0];
            l = hl[0];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[0] = ah0 = c & 65535 | d << 16;
            hl[0] = al0 = a & 65535 | b << 16;
            h = ah1;
            l = al1;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[1];
            l = hl[1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[1] = ah1 = c & 65535 | d << 16;
            hl[1] = al1 = a & 65535 | b << 16;
            h = ah2;
            l = al2;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[2];
            l = hl[2];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[2] = ah2 = c & 65535 | d << 16;
            hl[2] = al2 = a & 65535 | b << 16;
            h = ah3;
            l = al3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[3];
            l = hl[3];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[3] = ah3 = c & 65535 | d << 16;
            hl[3] = al3 = a & 65535 | b << 16;
            h = ah4;
            l = al4;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[4];
            l = hl[4];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[4] = ah4 = c & 65535 | d << 16;
            hl[4] = al4 = a & 65535 | b << 16;
            h = ah5;
            l = al5;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[5];
            l = hl[5];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[5] = ah5 = c & 65535 | d << 16;
            hl[5] = al5 = a & 65535 | b << 16;
            h = ah6;
            l = al6;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[6];
            l = hl[6];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[6] = ah6 = c & 65535 | d << 16;
            hl[6] = al6 = a & 65535 | b << 16;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[7];
            l = hl[7];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[7] = ah7 = c & 65535 | d << 16;
            hl[7] = al7 = a & 65535 | b << 16;
            pos += 128;
            n -= 128;
          }
          return n;
        }
        function crypto_hash(out, m, n) {
          var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
          hh[0] = 1779033703;
          hh[1] = 3144134277;
          hh[2] = 1013904242;
          hh[3] = 2773480762;
          hh[4] = 1359893119;
          hh[5] = 2600822924;
          hh[6] = 528734635;
          hh[7] = 1541459225;
          hl[0] = 4089235720;
          hl[1] = 2227873595;
          hl[2] = 4271175723;
          hl[3] = 1595750129;
          hl[4] = 2917565137;
          hl[5] = 725511199;
          hl[6] = 4215389547;
          hl[7] = 327033209;
          crypto_hashblocks_hl(hh, hl, m, n);
          n %= 128;
          for (i = 0; i < n; i++)
            x[i] = m[b - n + i];
          x[n] = 128;
          n = 256 - 128 * (n < 112 ? 1 : 0);
          x[n - 9] = 0;
          ts64(x, n - 8, b / 536870912 | 0, b << 3);
          crypto_hashblocks_hl(hh, hl, x, n);
          for (i = 0; i < 8; i++)
            ts64(out, 8 * i, hh[i], hl[i]);
          return 0;
        }
        function add(p, q) {
          var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
          Z(a, p[1], p[0]);
          Z(t, q[1], q[0]);
          M(a, a, t);
          A(b, p[0], p[1]);
          A(t, q[0], q[1]);
          M(b, b, t);
          M(c, p[3], q[3]);
          M(c, c, D2);
          M(d, p[2], q[2]);
          A(d, d, d);
          Z(e, b, a);
          Z(f, d, c);
          A(g, d, c);
          A(h, b, a);
          M(p[0], e, f);
          M(p[1], h, g);
          M(p[2], g, f);
          M(p[3], e, h);
        }
        function cswap(p, q, b) {
          var i;
          for (i = 0; i < 4; i++) {
            sel25519(p[i], q[i], b);
          }
        }
        function pack(r, p) {
          var tx = gf(), ty = gf(), zi = gf();
          inv25519(zi, p[2]);
          M(tx, p[0], zi);
          M(ty, p[1], zi);
          pack25519(r, ty);
          r[31] ^= par25519(tx) << 7;
        }
        function scalarmult(p, q, s) {
          var b, i;
          set25519(p[0], gf0);
          set25519(p[1], gf1);
          set25519(p[2], gf1);
          set25519(p[3], gf0);
          for (i = 255; i >= 0; --i) {
            b = s[i / 8 | 0] >> (i & 7) & 1;
            cswap(p, q, b);
            add(q, p);
            add(p, p);
            cswap(p, q, b);
          }
        }
        function scalarbase(p, s) {
          var q = [gf(), gf(), gf(), gf()];
          set25519(q[0], X);
          set25519(q[1], Y);
          set25519(q[2], gf1);
          M(q[3], X, Y);
          scalarmult(p, q, s);
        }
        function crypto_sign_keypair(pk, sk, seeded) {
          var d = new Uint8Array(64);
          var p = [gf(), gf(), gf(), gf()];
          var i;
          if (!seeded)
            randombytes(sk, 32);
          crypto_hash(d, sk, 32);
          d[0] &= 248;
          d[31] &= 127;
          d[31] |= 64;
          scalarbase(p, d);
          pack(pk, p);
          for (i = 0; i < 32; i++)
            sk[i + 32] = pk[i];
          return 0;
        }
        var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
        function modL(r, x) {
          var carry, i, j, k;
          for (i = 63; i >= 32; --i) {
            carry = 0;
            for (j = i - 32, k = i - 12; j < k; ++j) {
              x[j] += carry - 16 * x[i] * L[j - (i - 32)];
              carry = Math.floor((x[j] + 128) / 256);
              x[j] -= carry * 256;
            }
            x[j] += carry;
            x[i] = 0;
          }
          carry = 0;
          for (j = 0; j < 32; j++) {
            x[j] += carry - (x[31] >> 4) * L[j];
            carry = x[j] >> 8;
            x[j] &= 255;
          }
          for (j = 0; j < 32; j++)
            x[j] -= carry * L[j];
          for (i = 0; i < 32; i++) {
            x[i + 1] += x[i] >> 8;
            r[i] = x[i] & 255;
          }
        }
        function reduce(r) {
          var x = new Float64Array(64), i;
          for (i = 0; i < 64; i++)
            x[i] = r[i];
          for (i = 0; i < 64; i++)
            r[i] = 0;
          modL(r, x);
        }
        function crypto_sign(sm, m, n, sk) {
          var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
          var i, j, x = new Float64Array(64);
          var p = [gf(), gf(), gf(), gf()];
          crypto_hash(d, sk, 32);
          d[0] &= 248;
          d[31] &= 127;
          d[31] |= 64;
          var smlen = n + 64;
          for (i = 0; i < n; i++)
            sm[64 + i] = m[i];
          for (i = 0; i < 32; i++)
            sm[32 + i] = d[32 + i];
          crypto_hash(r, sm.subarray(32), n + 32);
          reduce(r);
          scalarbase(p, r);
          pack(sm, p);
          for (i = 32; i < 64; i++)
            sm[i] = sk[i];
          crypto_hash(h, sm, n + 64);
          reduce(h);
          for (i = 0; i < 64; i++)
            x[i] = 0;
          for (i = 0; i < 32; i++)
            x[i] = r[i];
          for (i = 0; i < 32; i++) {
            for (j = 0; j < 32; j++) {
              x[i + j] += h[i] * d[j];
            }
          }
          modL(sm.subarray(32), x);
          return smlen;
        }
        function unpackneg(r, p) {
          var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
          set25519(r[2], gf1);
          unpack25519(r[1], p);
          S(num, r[1]);
          M(den, num, D);
          Z(num, num, r[2]);
          A(den, r[2], den);
          S(den2, den);
          S(den4, den2);
          M(den6, den4, den2);
          M(t, den6, num);
          M(t, t, den);
          pow2523(t, t);
          M(t, t, num);
          M(t, t, den);
          M(t, t, den);
          M(r[0], t, den);
          S(chk, r[0]);
          M(chk, chk, den);
          if (neq25519(chk, num))
            M(r[0], r[0], I);
          S(chk, r[0]);
          M(chk, chk, den);
          if (neq25519(chk, num))
            return -1;
          if (par25519(r[0]) === p[31] >> 7)
            Z(r[0], gf0, r[0]);
          M(r[3], r[0], r[1]);
          return 0;
        }
        function crypto_sign_open(m, sm, n, pk) {
          var i;
          var t = new Uint8Array(32), h = new Uint8Array(64);
          var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
          if (n < 64)
            return -1;
          if (unpackneg(q, pk))
            return -1;
          for (i = 0; i < n; i++)
            m[i] = sm[i];
          for (i = 0; i < 32; i++)
            m[i + 32] = pk[i];
          crypto_hash(h, m, n);
          reduce(h);
          scalarmult(p, q, h);
          scalarbase(q, sm.subarray(32));
          add(p, q);
          pack(t, p);
          n -= 64;
          if (crypto_verify_32(sm, 0, t, 0)) {
            for (i = 0; i < n; i++)
              m[i] = 0;
            return -1;
          }
          for (i = 0; i < n; i++)
            m[i] = sm[i + 64];
          return n;
        }
        var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
        nacl.lowlevel = {
          crypto_core_hsalsa20,
          crypto_stream_xor,
          crypto_stream,
          crypto_stream_salsa20_xor,
          crypto_stream_salsa20,
          crypto_onetimeauth,
          crypto_onetimeauth_verify,
          crypto_verify_16,
          crypto_verify_32,
          crypto_secretbox,
          crypto_secretbox_open,
          crypto_scalarmult,
          crypto_scalarmult_base,
          crypto_box_beforenm,
          crypto_box_afternm,
          crypto_box,
          crypto_box_open,
          crypto_box_keypair,
          crypto_hash,
          crypto_sign,
          crypto_sign_keypair,
          crypto_sign_open,
          crypto_secretbox_KEYBYTES,
          crypto_secretbox_NONCEBYTES,
          crypto_secretbox_ZEROBYTES,
          crypto_secretbox_BOXZEROBYTES,
          crypto_scalarmult_BYTES,
          crypto_scalarmult_SCALARBYTES,
          crypto_box_PUBLICKEYBYTES,
          crypto_box_SECRETKEYBYTES,
          crypto_box_BEFORENMBYTES,
          crypto_box_NONCEBYTES,
          crypto_box_ZEROBYTES,
          crypto_box_BOXZEROBYTES,
          crypto_sign_BYTES,
          crypto_sign_PUBLICKEYBYTES,
          crypto_sign_SECRETKEYBYTES,
          crypto_sign_SEEDBYTES,
          crypto_hash_BYTES,
          gf,
          D,
          L,
          pack25519,
          unpack25519,
          M,
          A,
          S,
          Z,
          pow2523,
          add,
          set25519,
          modL,
          scalarmult,
          scalarbase
        };
        function checkLengths(k, n) {
          if (k.length !== crypto_secretbox_KEYBYTES)
            throw new Error("bad key size");
          if (n.length !== crypto_secretbox_NONCEBYTES)
            throw new Error("bad nonce size");
        }
        function checkBoxLengths(pk, sk) {
          if (pk.length !== crypto_box_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          if (sk.length !== crypto_box_SECRETKEYBYTES)
            throw new Error("bad secret key size");
        }
        function checkArrayTypes() {
          for (var i = 0; i < arguments.length; i++) {
            if (!(arguments[i] instanceof Uint8Array))
              throw new TypeError("unexpected type, use Uint8Array");
          }
        }
        function cleanup(arr) {
          for (var i = 0; i < arr.length; i++)
            arr[i] = 0;
        }
        nacl.randomBytes = function(n) {
          var b = new Uint8Array(n);
          randombytes(b, n);
          return b;
        };
        nacl.secretbox = function(msg, nonce, key) {
          checkArrayTypes(msg, nonce, key);
          checkLengths(key, nonce);
          var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
          var c = new Uint8Array(m.length);
          for (var i = 0; i < msg.length; i++)
            m[i + crypto_secretbox_ZEROBYTES] = msg[i];
          crypto_secretbox(c, m, m.length, nonce, key);
          return c.subarray(crypto_secretbox_BOXZEROBYTES);
        };
        nacl.secretbox.open = function(box, nonce, key) {
          checkArrayTypes(box, nonce, key);
          checkLengths(key, nonce);
          var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
          var m = new Uint8Array(c.length);
          for (var i = 0; i < box.length; i++)
            c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
          if (c.length < 32)
            return null;
          if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
            return null;
          return m.subarray(crypto_secretbox_ZEROBYTES);
        };
        nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
        nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
        nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
        nacl.scalarMult = function(n, p) {
          checkArrayTypes(n, p);
          if (n.length !== crypto_scalarmult_SCALARBYTES)
            throw new Error("bad n size");
          if (p.length !== crypto_scalarmult_BYTES)
            throw new Error("bad p size");
          var q = new Uint8Array(crypto_scalarmult_BYTES);
          crypto_scalarmult(q, n, p);
          return q;
        };
        nacl.scalarMult.base = function(n) {
          checkArrayTypes(n);
          if (n.length !== crypto_scalarmult_SCALARBYTES)
            throw new Error("bad n size");
          var q = new Uint8Array(crypto_scalarmult_BYTES);
          crypto_scalarmult_base(q, n);
          return q;
        };
        nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
        nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
        nacl.box = function(msg, nonce, publicKey, secretKey) {
          var k = nacl.box.before(publicKey, secretKey);
          return nacl.secretbox(msg, nonce, k);
        };
        nacl.box.before = function(publicKey, secretKey) {
          checkArrayTypes(publicKey, secretKey);
          checkBoxLengths(publicKey, secretKey);
          var k = new Uint8Array(crypto_box_BEFORENMBYTES);
          crypto_box_beforenm(k, publicKey, secretKey);
          return k;
        };
        nacl.box.after = nacl.secretbox;
        nacl.box.open = function(msg, nonce, publicKey, secretKey) {
          var k = nacl.box.before(publicKey, secretKey);
          return nacl.secretbox.open(msg, nonce, k);
        };
        nacl.box.open.after = nacl.secretbox.open;
        nacl.box.keyPair = function() {
          var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
          crypto_box_keypair(pk, sk);
          return { publicKey: pk, secretKey: sk };
        };
        nacl.box.keyPair.fromSecretKey = function(secretKey) {
          checkArrayTypes(secretKey);
          if (secretKey.length !== crypto_box_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
          crypto_scalarmult_base(pk, secretKey);
          return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
        };
        nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
        nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
        nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
        nacl.box.nonceLength = crypto_box_NONCEBYTES;
        nacl.box.overheadLength = nacl.secretbox.overheadLength;
        nacl.sign = function(msg, secretKey) {
          checkArrayTypes(msg, secretKey);
          if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
          crypto_sign(signedMsg, msg, msg.length, secretKey);
          return signedMsg;
        };
        nacl.sign.open = function(signedMsg, publicKey) {
          checkArrayTypes(signedMsg, publicKey);
          if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          var tmp = new Uint8Array(signedMsg.length);
          var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
          if (mlen < 0)
            return null;
          var m = new Uint8Array(mlen);
          for (var i = 0; i < m.length; i++)
            m[i] = tmp[i];
          return m;
        };
        nacl.sign.detached = function(msg, secretKey) {
          var signedMsg = nacl.sign(msg, secretKey);
          var sig = new Uint8Array(crypto_sign_BYTES);
          for (var i = 0; i < sig.length; i++)
            sig[i] = signedMsg[i];
          return sig;
        };
        nacl.sign.detached.verify = function(msg, sig, publicKey) {
          checkArrayTypes(msg, sig, publicKey);
          if (sig.length !== crypto_sign_BYTES)
            throw new Error("bad signature size");
          if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
          var m = new Uint8Array(crypto_sign_BYTES + msg.length);
          var i;
          for (i = 0; i < crypto_sign_BYTES; i++)
            sm[i] = sig[i];
          for (i = 0; i < msg.length; i++)
            sm[i + crypto_sign_BYTES] = msg[i];
          return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
        };
        nacl.sign.keyPair = function() {
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
          crypto_sign_keypair(pk, sk);
          return { publicKey: pk, secretKey: sk };
        };
        nacl.sign.keyPair.fromSecretKey = function(secretKey) {
          checkArrayTypes(secretKey);
          if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          for (var i = 0; i < pk.length; i++)
            pk[i] = secretKey[32 + i];
          return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
        };
        nacl.sign.keyPair.fromSeed = function(seed) {
          checkArrayTypes(seed);
          if (seed.length !== crypto_sign_SEEDBYTES)
            throw new Error("bad seed size");
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
          for (var i = 0; i < 32; i++)
            sk[i] = seed[i];
          crypto_sign_keypair(pk, sk, true);
          return { publicKey: pk, secretKey: sk };
        };
        nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
        nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
        nacl.sign.seedLength = crypto_sign_SEEDBYTES;
        nacl.sign.signatureLength = crypto_sign_BYTES;
        nacl.hash = function(msg) {
          checkArrayTypes(msg);
          var h = new Uint8Array(crypto_hash_BYTES);
          crypto_hash(h, msg, msg.length);
          return h;
        };
        nacl.hash.hashLength = crypto_hash_BYTES;
        nacl.verify = function(x, y) {
          checkArrayTypes(x, y);
          if (x.length === 0 || y.length === 0)
            return false;
          if (x.length !== y.length)
            return false;
          return vn(x, 0, y, 0, x.length) === 0 ? true : false;
        };
        nacl.setPRNG = function(fn) {
          randombytes = fn;
        };
        (function() {
          var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
          if (crypto2 && crypto2.getRandomValues) {
            var QUOTA = 65536;
            nacl.setPRNG(function(x, n) {
              var i, v = new Uint8Array(n);
              for (i = 0; i < n; i += QUOTA) {
                crypto2.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
              }
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          } else if (typeof __require !== "undefined") {
            crypto2 = require_crypto();
            if (crypto2 && crypto2.randomBytes) {
              nacl.setPRNG(function(x, n) {
                var i, v = crypto2.randomBytes(n);
                for (i = 0; i < n; i++)
                  x[i] = v[i];
                cleanup(v);
              });
            }
          }
        })();
      })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
    }
  });

  // node_modules/ton-crypto/dist/mnemonic/wordlist.js
  var require_wordlist = __commonJS({
    "node_modules/ton-crypto/dist/mnemonic/wordlist.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.wordlist = void 0;
      var EN = [
        "abandon",
        "ability",
        "able",
        "about",
        "above",
        "absent",
        "absorb",
        "abstract",
        "absurd",
        "abuse",
        "access",
        "accident",
        "account",
        "accuse",
        "achieve",
        "acid",
        "acoustic",
        "acquire",
        "across",
        "act",
        "action",
        "actor",
        "actress",
        "actual",
        "adapt",
        "add",
        "addict",
        "address",
        "adjust",
        "admit",
        "adult",
        "advance",
        "advice",
        "aerobic",
        "affair",
        "afford",
        "afraid",
        "again",
        "age",
        "agent",
        "agree",
        "ahead",
        "aim",
        "air",
        "airport",
        "aisle",
        "alarm",
        "album",
        "alcohol",
        "alert",
        "alien",
        "all",
        "alley",
        "allow",
        "almost",
        "alone",
        "alpha",
        "already",
        "also",
        "alter",
        "always",
        "amateur",
        "amazing",
        "among",
        "amount",
        "amused",
        "analyst",
        "anchor",
        "ancient",
        "anger",
        "angle",
        "angry",
        "animal",
        "ankle",
        "announce",
        "annual",
        "another",
        "answer",
        "antenna",
        "antique",
        "anxiety",
        "any",
        "apart",
        "apology",
        "appear",
        "apple",
        "approve",
        "april",
        "arch",
        "arctic",
        "area",
        "arena",
        "argue",
        "arm",
        "armed",
        "armor",
        "army",
        "around",
        "arrange",
        "arrest",
        "arrive",
        "arrow",
        "art",
        "artefact",
        "artist",
        "artwork",
        "ask",
        "aspect",
        "assault",
        "asset",
        "assist",
        "assume",
        "asthma",
        "athlete",
        "atom",
        "attack",
        "attend",
        "attitude",
        "attract",
        "auction",
        "audit",
        "august",
        "aunt",
        "author",
        "auto",
        "autumn",
        "average",
        "avocado",
        "avoid",
        "awake",
        "aware",
        "away",
        "awesome",
        "awful",
        "awkward",
        "axis",
        "baby",
        "bachelor",
        "bacon",
        "badge",
        "bag",
        "balance",
        "balcony",
        "ball",
        "bamboo",
        "banana",
        "banner",
        "bar",
        "barely",
        "bargain",
        "barrel",
        "base",
        "basic",
        "basket",
        "battle",
        "beach",
        "bean",
        "beauty",
        "because",
        "become",
        "beef",
        "before",
        "begin",
        "behave",
        "behind",
        "believe",
        "below",
        "belt",
        "bench",
        "benefit",
        "best",
        "betray",
        "better",
        "between",
        "beyond",
        "bicycle",
        "bid",
        "bike",
        "bind",
        "biology",
        "bird",
        "birth",
        "bitter",
        "black",
        "blade",
        "blame",
        "blanket",
        "blast",
        "bleak",
        "bless",
        "blind",
        "blood",
        "blossom",
        "blouse",
        "blue",
        "blur",
        "blush",
        "board",
        "boat",
        "body",
        "boil",
        "bomb",
        "bone",
        "bonus",
        "book",
        "boost",
        "border",
        "boring",
        "borrow",
        "boss",
        "bottom",
        "bounce",
        "box",
        "boy",
        "bracket",
        "brain",
        "brand",
        "brass",
        "brave",
        "bread",
        "breeze",
        "brick",
        "bridge",
        "brief",
        "bright",
        "bring",
        "brisk",
        "broccoli",
        "broken",
        "bronze",
        "broom",
        "brother",
        "brown",
        "brush",
        "bubble",
        "buddy",
        "budget",
        "buffalo",
        "build",
        "bulb",
        "bulk",
        "bullet",
        "bundle",
        "bunker",
        "burden",
        "burger",
        "burst",
        "bus",
        "business",
        "busy",
        "butter",
        "buyer",
        "buzz",
        "cabbage",
        "cabin",
        "cable",
        "cactus",
        "cage",
        "cake",
        "call",
        "calm",
        "camera",
        "camp",
        "can",
        "canal",
        "cancel",
        "candy",
        "cannon",
        "canoe",
        "canvas",
        "canyon",
        "capable",
        "capital",
        "captain",
        "car",
        "carbon",
        "card",
        "cargo",
        "carpet",
        "carry",
        "cart",
        "case",
        "cash",
        "casino",
        "castle",
        "casual",
        "cat",
        "catalog",
        "catch",
        "category",
        "cattle",
        "caught",
        "cause",
        "caution",
        "cave",
        "ceiling",
        "celery",
        "cement",
        "census",
        "century",
        "cereal",
        "certain",
        "chair",
        "chalk",
        "champion",
        "change",
        "chaos",
        "chapter",
        "charge",
        "chase",
        "chat",
        "cheap",
        "check",
        "cheese",
        "chef",
        "cherry",
        "chest",
        "chicken",
        "chief",
        "child",
        "chimney",
        "choice",
        "choose",
        "chronic",
        "chuckle",
        "chunk",
        "churn",
        "cigar",
        "cinnamon",
        "circle",
        "citizen",
        "city",
        "civil",
        "claim",
        "clap",
        "clarify",
        "claw",
        "clay",
        "clean",
        "clerk",
        "clever",
        "click",
        "client",
        "cliff",
        "climb",
        "clinic",
        "clip",
        "clock",
        "clog",
        "close",
        "cloth",
        "cloud",
        "clown",
        "club",
        "clump",
        "cluster",
        "clutch",
        "coach",
        "coast",
        "coconut",
        "code",
        "coffee",
        "coil",
        "coin",
        "collect",
        "color",
        "column",
        "combine",
        "come",
        "comfort",
        "comic",
        "common",
        "company",
        "concert",
        "conduct",
        "confirm",
        "congress",
        "connect",
        "consider",
        "control",
        "convince",
        "cook",
        "cool",
        "copper",
        "copy",
        "coral",
        "core",
        "corn",
        "correct",
        "cost",
        "cotton",
        "couch",
        "country",
        "couple",
        "course",
        "cousin",
        "cover",
        "coyote",
        "crack",
        "cradle",
        "craft",
        "cram",
        "crane",
        "crash",
        "crater",
        "crawl",
        "crazy",
        "cream",
        "credit",
        "creek",
        "crew",
        "cricket",
        "crime",
        "crisp",
        "critic",
        "crop",
        "cross",
        "crouch",
        "crowd",
        "crucial",
        "cruel",
        "cruise",
        "crumble",
        "crunch",
        "crush",
        "cry",
        "crystal",
        "cube",
        "culture",
        "cup",
        "cupboard",
        "curious",
        "current",
        "curtain",
        "curve",
        "cushion",
        "custom",
        "cute",
        "cycle",
        "dad",
        "damage",
        "damp",
        "dance",
        "danger",
        "daring",
        "dash",
        "daughter",
        "dawn",
        "day",
        "deal",
        "debate",
        "debris",
        "decade",
        "december",
        "decide",
        "decline",
        "decorate",
        "decrease",
        "deer",
        "defense",
        "define",
        "defy",
        "degree",
        "delay",
        "deliver",
        "demand",
        "demise",
        "denial",
        "dentist",
        "deny",
        "depart",
        "depend",
        "deposit",
        "depth",
        "deputy",
        "derive",
        "describe",
        "desert",
        "design",
        "desk",
        "despair",
        "destroy",
        "detail",
        "detect",
        "develop",
        "device",
        "devote",
        "diagram",
        "dial",
        "diamond",
        "diary",
        "dice",
        "diesel",
        "diet",
        "differ",
        "digital",
        "dignity",
        "dilemma",
        "dinner",
        "dinosaur",
        "direct",
        "dirt",
        "disagree",
        "discover",
        "disease",
        "dish",
        "dismiss",
        "disorder",
        "display",
        "distance",
        "divert",
        "divide",
        "divorce",
        "dizzy",
        "doctor",
        "document",
        "dog",
        "doll",
        "dolphin",
        "domain",
        "donate",
        "donkey",
        "donor",
        "door",
        "dose",
        "double",
        "dove",
        "draft",
        "dragon",
        "drama",
        "drastic",
        "draw",
        "dream",
        "dress",
        "drift",
        "drill",
        "drink",
        "drip",
        "drive",
        "drop",
        "drum",
        "dry",
        "duck",
        "dumb",
        "dune",
        "during",
        "dust",
        "dutch",
        "duty",
        "dwarf",
        "dynamic",
        "eager",
        "eagle",
        "early",
        "earn",
        "earth",
        "easily",
        "east",
        "easy",
        "echo",
        "ecology",
        "economy",
        "edge",
        "edit",
        "educate",
        "effort",
        "egg",
        "eight",
        "either",
        "elbow",
        "elder",
        "electric",
        "elegant",
        "element",
        "elephant",
        "elevator",
        "elite",
        "else",
        "embark",
        "embody",
        "embrace",
        "emerge",
        "emotion",
        "employ",
        "empower",
        "empty",
        "enable",
        "enact",
        "end",
        "endless",
        "endorse",
        "enemy",
        "energy",
        "enforce",
        "engage",
        "engine",
        "enhance",
        "enjoy",
        "enlist",
        "enough",
        "enrich",
        "enroll",
        "ensure",
        "enter",
        "entire",
        "entry",
        "envelope",
        "episode",
        "equal",
        "equip",
        "era",
        "erase",
        "erode",
        "erosion",
        "error",
        "erupt",
        "escape",
        "essay",
        "essence",
        "estate",
        "eternal",
        "ethics",
        "evidence",
        "evil",
        "evoke",
        "evolve",
        "exact",
        "example",
        "excess",
        "exchange",
        "excite",
        "exclude",
        "excuse",
        "execute",
        "exercise",
        "exhaust",
        "exhibit",
        "exile",
        "exist",
        "exit",
        "exotic",
        "expand",
        "expect",
        "expire",
        "explain",
        "expose",
        "express",
        "extend",
        "extra",
        "eye",
        "eyebrow",
        "fabric",
        "face",
        "faculty",
        "fade",
        "faint",
        "faith",
        "fall",
        "false",
        "fame",
        "family",
        "famous",
        "fan",
        "fancy",
        "fantasy",
        "farm",
        "fashion",
        "fat",
        "fatal",
        "father",
        "fatigue",
        "fault",
        "favorite",
        "feature",
        "february",
        "federal",
        "fee",
        "feed",
        "feel",
        "female",
        "fence",
        "festival",
        "fetch",
        "fever",
        "few",
        "fiber",
        "fiction",
        "field",
        "figure",
        "file",
        "film",
        "filter",
        "final",
        "find",
        "fine",
        "finger",
        "finish",
        "fire",
        "firm",
        "first",
        "fiscal",
        "fish",
        "fit",
        "fitness",
        "fix",
        "flag",
        "flame",
        "flash",
        "flat",
        "flavor",
        "flee",
        "flight",
        "flip",
        "float",
        "flock",
        "floor",
        "flower",
        "fluid",
        "flush",
        "fly",
        "foam",
        "focus",
        "fog",
        "foil",
        "fold",
        "follow",
        "food",
        "foot",
        "force",
        "forest",
        "forget",
        "fork",
        "fortune",
        "forum",
        "forward",
        "fossil",
        "foster",
        "found",
        "fox",
        "fragile",
        "frame",
        "frequent",
        "fresh",
        "friend",
        "fringe",
        "frog",
        "front",
        "frost",
        "frown",
        "frozen",
        "fruit",
        "fuel",
        "fun",
        "funny",
        "furnace",
        "fury",
        "future",
        "gadget",
        "gain",
        "galaxy",
        "gallery",
        "game",
        "gap",
        "garage",
        "garbage",
        "garden",
        "garlic",
        "garment",
        "gas",
        "gasp",
        "gate",
        "gather",
        "gauge",
        "gaze",
        "general",
        "genius",
        "genre",
        "gentle",
        "genuine",
        "gesture",
        "ghost",
        "giant",
        "gift",
        "giggle",
        "ginger",
        "giraffe",
        "girl",
        "give",
        "glad",
        "glance",
        "glare",
        "glass",
        "glide",
        "glimpse",
        "globe",
        "gloom",
        "glory",
        "glove",
        "glow",
        "glue",
        "goat",
        "goddess",
        "gold",
        "good",
        "goose",
        "gorilla",
        "gospel",
        "gossip",
        "govern",
        "gown",
        "grab",
        "grace",
        "grain",
        "grant",
        "grape",
        "grass",
        "gravity",
        "great",
        "green",
        "grid",
        "grief",
        "grit",
        "grocery",
        "group",
        "grow",
        "grunt",
        "guard",
        "guess",
        "guide",
        "guilt",
        "guitar",
        "gun",
        "gym",
        "habit",
        "hair",
        "half",
        "hammer",
        "hamster",
        "hand",
        "happy",
        "harbor",
        "hard",
        "harsh",
        "harvest",
        "hat",
        "have",
        "hawk",
        "hazard",
        "head",
        "health",
        "heart",
        "heavy",
        "hedgehog",
        "height",
        "hello",
        "helmet",
        "help",
        "hen",
        "hero",
        "hidden",
        "high",
        "hill",
        "hint",
        "hip",
        "hire",
        "history",
        "hobby",
        "hockey",
        "hold",
        "hole",
        "holiday",
        "hollow",
        "home",
        "honey",
        "hood",
        "hope",
        "horn",
        "horror",
        "horse",
        "hospital",
        "host",
        "hotel",
        "hour",
        "hover",
        "hub",
        "huge",
        "human",
        "humble",
        "humor",
        "hundred",
        "hungry",
        "hunt",
        "hurdle",
        "hurry",
        "hurt",
        "husband",
        "hybrid",
        "ice",
        "icon",
        "idea",
        "identify",
        "idle",
        "ignore",
        "ill",
        "illegal",
        "illness",
        "image",
        "imitate",
        "immense",
        "immune",
        "impact",
        "impose",
        "improve",
        "impulse",
        "inch",
        "include",
        "income",
        "increase",
        "index",
        "indicate",
        "indoor",
        "industry",
        "infant",
        "inflict",
        "inform",
        "inhale",
        "inherit",
        "initial",
        "inject",
        "injury",
        "inmate",
        "inner",
        "innocent",
        "input",
        "inquiry",
        "insane",
        "insect",
        "inside",
        "inspire",
        "install",
        "intact",
        "interest",
        "into",
        "invest",
        "invite",
        "involve",
        "iron",
        "island",
        "isolate",
        "issue",
        "item",
        "ivory",
        "jacket",
        "jaguar",
        "jar",
        "jazz",
        "jealous",
        "jeans",
        "jelly",
        "jewel",
        "job",
        "join",
        "joke",
        "journey",
        "joy",
        "judge",
        "juice",
        "jump",
        "jungle",
        "junior",
        "junk",
        "just",
        "kangaroo",
        "keen",
        "keep",
        "ketchup",
        "key",
        "kick",
        "kid",
        "kidney",
        "kind",
        "kingdom",
        "kiss",
        "kit",
        "kitchen",
        "kite",
        "kitten",
        "kiwi",
        "knee",
        "knife",
        "knock",
        "know",
        "lab",
        "label",
        "labor",
        "ladder",
        "lady",
        "lake",
        "lamp",
        "language",
        "laptop",
        "large",
        "later",
        "latin",
        "laugh",
        "laundry",
        "lava",
        "law",
        "lawn",
        "lawsuit",
        "layer",
        "lazy",
        "leader",
        "leaf",
        "learn",
        "leave",
        "lecture",
        "left",
        "leg",
        "legal",
        "legend",
        "leisure",
        "lemon",
        "lend",
        "length",
        "lens",
        "leopard",
        "lesson",
        "letter",
        "level",
        "liar",
        "liberty",
        "library",
        "license",
        "life",
        "lift",
        "light",
        "like",
        "limb",
        "limit",
        "link",
        "lion",
        "liquid",
        "list",
        "little",
        "live",
        "lizard",
        "load",
        "loan",
        "lobster",
        "local",
        "lock",
        "logic",
        "lonely",
        "long",
        "loop",
        "lottery",
        "loud",
        "lounge",
        "love",
        "loyal",
        "lucky",
        "luggage",
        "lumber",
        "lunar",
        "lunch",
        "luxury",
        "lyrics",
        "machine",
        "mad",
        "magic",
        "magnet",
        "maid",
        "mail",
        "main",
        "major",
        "make",
        "mammal",
        "man",
        "manage",
        "mandate",
        "mango",
        "mansion",
        "manual",
        "maple",
        "marble",
        "march",
        "margin",
        "marine",
        "market",
        "marriage",
        "mask",
        "mass",
        "master",
        "match",
        "material",
        "math",
        "matrix",
        "matter",
        "maximum",
        "maze",
        "meadow",
        "mean",
        "measure",
        "meat",
        "mechanic",
        "medal",
        "media",
        "melody",
        "melt",
        "member",
        "memory",
        "mention",
        "menu",
        "mercy",
        "merge",
        "merit",
        "merry",
        "mesh",
        "message",
        "metal",
        "method",
        "middle",
        "midnight",
        "milk",
        "million",
        "mimic",
        "mind",
        "minimum",
        "minor",
        "minute",
        "miracle",
        "mirror",
        "misery",
        "miss",
        "mistake",
        "mix",
        "mixed",
        "mixture",
        "mobile",
        "model",
        "modify",
        "mom",
        "moment",
        "monitor",
        "monkey",
        "monster",
        "month",
        "moon",
        "moral",
        "more",
        "morning",
        "mosquito",
        "mother",
        "motion",
        "motor",
        "mountain",
        "mouse",
        "move",
        "movie",
        "much",
        "muffin",
        "mule",
        "multiply",
        "muscle",
        "museum",
        "mushroom",
        "music",
        "must",
        "mutual",
        "myself",
        "mystery",
        "myth",
        "naive",
        "name",
        "napkin",
        "narrow",
        "nasty",
        "nation",
        "nature",
        "near",
        "neck",
        "need",
        "negative",
        "neglect",
        "neither",
        "nephew",
        "nerve",
        "nest",
        "net",
        "network",
        "neutral",
        "never",
        "news",
        "next",
        "nice",
        "night",
        "noble",
        "noise",
        "nominee",
        "noodle",
        "normal",
        "north",
        "nose",
        "notable",
        "note",
        "nothing",
        "notice",
        "novel",
        "now",
        "nuclear",
        "number",
        "nurse",
        "nut",
        "oak",
        "obey",
        "object",
        "oblige",
        "obscure",
        "observe",
        "obtain",
        "obvious",
        "occur",
        "ocean",
        "october",
        "odor",
        "off",
        "offer",
        "office",
        "often",
        "oil",
        "okay",
        "old",
        "olive",
        "olympic",
        "omit",
        "once",
        "one",
        "onion",
        "online",
        "only",
        "open",
        "opera",
        "opinion",
        "oppose",
        "option",
        "orange",
        "orbit",
        "orchard",
        "order",
        "ordinary",
        "organ",
        "orient",
        "original",
        "orphan",
        "ostrich",
        "other",
        "outdoor",
        "outer",
        "output",
        "outside",
        "oval",
        "oven",
        "over",
        "own",
        "owner",
        "oxygen",
        "oyster",
        "ozone",
        "pact",
        "paddle",
        "page",
        "pair",
        "palace",
        "palm",
        "panda",
        "panel",
        "panic",
        "panther",
        "paper",
        "parade",
        "parent",
        "park",
        "parrot",
        "party",
        "pass",
        "patch",
        "path",
        "patient",
        "patrol",
        "pattern",
        "pause",
        "pave",
        "payment",
        "peace",
        "peanut",
        "pear",
        "peasant",
        "pelican",
        "pen",
        "penalty",
        "pencil",
        "people",
        "pepper",
        "perfect",
        "permit",
        "person",
        "pet",
        "phone",
        "photo",
        "phrase",
        "physical",
        "piano",
        "picnic",
        "picture",
        "piece",
        "pig",
        "pigeon",
        "pill",
        "pilot",
        "pink",
        "pioneer",
        "pipe",
        "pistol",
        "pitch",
        "pizza",
        "place",
        "planet",
        "plastic",
        "plate",
        "play",
        "please",
        "pledge",
        "pluck",
        "plug",
        "plunge",
        "poem",
        "poet",
        "point",
        "polar",
        "pole",
        "police",
        "pond",
        "pony",
        "pool",
        "popular",
        "portion",
        "position",
        "possible",
        "post",
        "potato",
        "pottery",
        "poverty",
        "powder",
        "power",
        "practice",
        "praise",
        "predict",
        "prefer",
        "prepare",
        "present",
        "pretty",
        "prevent",
        "price",
        "pride",
        "primary",
        "print",
        "priority",
        "prison",
        "private",
        "prize",
        "problem",
        "process",
        "produce",
        "profit",
        "program",
        "project",
        "promote",
        "proof",
        "property",
        "prosper",
        "protect",
        "proud",
        "provide",
        "public",
        "pudding",
        "pull",
        "pulp",
        "pulse",
        "pumpkin",
        "punch",
        "pupil",
        "puppy",
        "purchase",
        "purity",
        "purpose",
        "purse",
        "push",
        "put",
        "puzzle",
        "pyramid",
        "quality",
        "quantum",
        "quarter",
        "question",
        "quick",
        "quit",
        "quiz",
        "quote",
        "rabbit",
        "raccoon",
        "race",
        "rack",
        "radar",
        "radio",
        "rail",
        "rain",
        "raise",
        "rally",
        "ramp",
        "ranch",
        "random",
        "range",
        "rapid",
        "rare",
        "rate",
        "rather",
        "raven",
        "raw",
        "razor",
        "ready",
        "real",
        "reason",
        "rebel",
        "rebuild",
        "recall",
        "receive",
        "recipe",
        "record",
        "recycle",
        "reduce",
        "reflect",
        "reform",
        "refuse",
        "region",
        "regret",
        "regular",
        "reject",
        "relax",
        "release",
        "relief",
        "rely",
        "remain",
        "remember",
        "remind",
        "remove",
        "render",
        "renew",
        "rent",
        "reopen",
        "repair",
        "repeat",
        "replace",
        "report",
        "require",
        "rescue",
        "resemble",
        "resist",
        "resource",
        "response",
        "result",
        "retire",
        "retreat",
        "return",
        "reunion",
        "reveal",
        "review",
        "reward",
        "rhythm",
        "rib",
        "ribbon",
        "rice",
        "rich",
        "ride",
        "ridge",
        "rifle",
        "right",
        "rigid",
        "ring",
        "riot",
        "ripple",
        "risk",
        "ritual",
        "rival",
        "river",
        "road",
        "roast",
        "robot",
        "robust",
        "rocket",
        "romance",
        "roof",
        "rookie",
        "room",
        "rose",
        "rotate",
        "rough",
        "round",
        "route",
        "royal",
        "rubber",
        "rude",
        "rug",
        "rule",
        "run",
        "runway",
        "rural",
        "sad",
        "saddle",
        "sadness",
        "safe",
        "sail",
        "salad",
        "salmon",
        "salon",
        "salt",
        "salute",
        "same",
        "sample",
        "sand",
        "satisfy",
        "satoshi",
        "sauce",
        "sausage",
        "save",
        "say",
        "scale",
        "scan",
        "scare",
        "scatter",
        "scene",
        "scheme",
        "school",
        "science",
        "scissors",
        "scorpion",
        "scout",
        "scrap",
        "screen",
        "script",
        "scrub",
        "sea",
        "search",
        "season",
        "seat",
        "second",
        "secret",
        "section",
        "security",
        "seed",
        "seek",
        "segment",
        "select",
        "sell",
        "seminar",
        "senior",
        "sense",
        "sentence",
        "series",
        "service",
        "session",
        "settle",
        "setup",
        "seven",
        "shadow",
        "shaft",
        "shallow",
        "share",
        "shed",
        "shell",
        "sheriff",
        "shield",
        "shift",
        "shine",
        "ship",
        "shiver",
        "shock",
        "shoe",
        "shoot",
        "shop",
        "short",
        "shoulder",
        "shove",
        "shrimp",
        "shrug",
        "shuffle",
        "shy",
        "sibling",
        "sick",
        "side",
        "siege",
        "sight",
        "sign",
        "silent",
        "silk",
        "silly",
        "silver",
        "similar",
        "simple",
        "since",
        "sing",
        "siren",
        "sister",
        "situate",
        "six",
        "size",
        "skate",
        "sketch",
        "ski",
        "skill",
        "skin",
        "skirt",
        "skull",
        "slab",
        "slam",
        "sleep",
        "slender",
        "slice",
        "slide",
        "slight",
        "slim",
        "slogan",
        "slot",
        "slow",
        "slush",
        "small",
        "smart",
        "smile",
        "smoke",
        "smooth",
        "snack",
        "snake",
        "snap",
        "sniff",
        "snow",
        "soap",
        "soccer",
        "social",
        "sock",
        "soda",
        "soft",
        "solar",
        "soldier",
        "solid",
        "solution",
        "solve",
        "someone",
        "song",
        "soon",
        "sorry",
        "sort",
        "soul",
        "sound",
        "soup",
        "source",
        "south",
        "space",
        "spare",
        "spatial",
        "spawn",
        "speak",
        "special",
        "speed",
        "spell",
        "spend",
        "sphere",
        "spice",
        "spider",
        "spike",
        "spin",
        "spirit",
        "split",
        "spoil",
        "sponsor",
        "spoon",
        "sport",
        "spot",
        "spray",
        "spread",
        "spring",
        "spy",
        "square",
        "squeeze",
        "squirrel",
        "stable",
        "stadium",
        "staff",
        "stage",
        "stairs",
        "stamp",
        "stand",
        "start",
        "state",
        "stay",
        "steak",
        "steel",
        "stem",
        "step",
        "stereo",
        "stick",
        "still",
        "sting",
        "stock",
        "stomach",
        "stone",
        "stool",
        "story",
        "stove",
        "strategy",
        "street",
        "strike",
        "strong",
        "struggle",
        "student",
        "stuff",
        "stumble",
        "style",
        "subject",
        "submit",
        "subway",
        "success",
        "such",
        "sudden",
        "suffer",
        "sugar",
        "suggest",
        "suit",
        "summer",
        "sun",
        "sunny",
        "sunset",
        "super",
        "supply",
        "supreme",
        "sure",
        "surface",
        "surge",
        "surprise",
        "surround",
        "survey",
        "suspect",
        "sustain",
        "swallow",
        "swamp",
        "swap",
        "swarm",
        "swear",
        "sweet",
        "swift",
        "swim",
        "swing",
        "switch",
        "sword",
        "symbol",
        "symptom",
        "syrup",
        "system",
        "table",
        "tackle",
        "tag",
        "tail",
        "talent",
        "talk",
        "tank",
        "tape",
        "target",
        "task",
        "taste",
        "tattoo",
        "taxi",
        "teach",
        "team",
        "tell",
        "ten",
        "tenant",
        "tennis",
        "tent",
        "term",
        "test",
        "text",
        "thank",
        "that",
        "theme",
        "then",
        "theory",
        "there",
        "they",
        "thing",
        "this",
        "thought",
        "three",
        "thrive",
        "throw",
        "thumb",
        "thunder",
        "ticket",
        "tide",
        "tiger",
        "tilt",
        "timber",
        "time",
        "tiny",
        "tip",
        "tired",
        "tissue",
        "title",
        "toast",
        "tobacco",
        "today",
        "toddler",
        "toe",
        "together",
        "toilet",
        "token",
        "tomato",
        "tomorrow",
        "tone",
        "tongue",
        "tonight",
        "tool",
        "tooth",
        "top",
        "topic",
        "topple",
        "torch",
        "tornado",
        "tortoise",
        "toss",
        "total",
        "tourist",
        "toward",
        "tower",
        "town",
        "toy",
        "track",
        "trade",
        "traffic",
        "tragic",
        "train",
        "transfer",
        "trap",
        "trash",
        "travel",
        "tray",
        "treat",
        "tree",
        "trend",
        "trial",
        "tribe",
        "trick",
        "trigger",
        "trim",
        "trip",
        "trophy",
        "trouble",
        "truck",
        "true",
        "truly",
        "trumpet",
        "trust",
        "truth",
        "try",
        "tube",
        "tuition",
        "tumble",
        "tuna",
        "tunnel",
        "turkey",
        "turn",
        "turtle",
        "twelve",
        "twenty",
        "twice",
        "twin",
        "twist",
        "two",
        "type",
        "typical",
        "ugly",
        "umbrella",
        "unable",
        "unaware",
        "uncle",
        "uncover",
        "under",
        "undo",
        "unfair",
        "unfold",
        "unhappy",
        "uniform",
        "unique",
        "unit",
        "universe",
        "unknown",
        "unlock",
        "until",
        "unusual",
        "unveil",
        "update",
        "upgrade",
        "uphold",
        "upon",
        "upper",
        "upset",
        "urban",
        "urge",
        "usage",
        "use",
        "used",
        "useful",
        "useless",
        "usual",
        "utility",
        "vacant",
        "vacuum",
        "vague",
        "valid",
        "valley",
        "valve",
        "van",
        "vanish",
        "vapor",
        "various",
        "vast",
        "vault",
        "vehicle",
        "velvet",
        "vendor",
        "venture",
        "venue",
        "verb",
        "verify",
        "version",
        "very",
        "vessel",
        "veteran",
        "viable",
        "vibrant",
        "vicious",
        "victory",
        "video",
        "view",
        "village",
        "vintage",
        "violin",
        "virtual",
        "virus",
        "visa",
        "visit",
        "visual",
        "vital",
        "vivid",
        "vocal",
        "voice",
        "void",
        "volcano",
        "volume",
        "vote",
        "voyage",
        "wage",
        "wagon",
        "wait",
        "walk",
        "wall",
        "walnut",
        "want",
        "warfare",
        "warm",
        "warrior",
        "wash",
        "wasp",
        "waste",
        "water",
        "wave",
        "way",
        "wealth",
        "weapon",
        "wear",
        "weasel",
        "weather",
        "web",
        "wedding",
        "weekend",
        "weird",
        "welcome",
        "west",
        "wet",
        "whale",
        "what",
        "wheat",
        "wheel",
        "when",
        "where",
        "whip",
        "whisper",
        "wide",
        "width",
        "wife",
        "wild",
        "will",
        "win",
        "window",
        "wine",
        "wing",
        "wink",
        "winner",
        "winter",
        "wire",
        "wisdom",
        "wise",
        "wish",
        "witness",
        "wolf",
        "woman",
        "wonder",
        "wood",
        "wool",
        "word",
        "work",
        "world",
        "worry",
        "worth",
        "wrap",
        "wreck",
        "wrestle",
        "wrist",
        "write",
        "wrong",
        "yard",
        "year",
        "yellow",
        "you",
        "young",
        "youth",
        "zebra",
        "zero",
        "zone",
        "zoo"
      ];
      exports.wordlist = EN;
    }
  });

  // node_modules/ton-crypto/dist/mnemonic/mnemonic.js
  var require_mnemonic = __commonJS({
    "node_modules/ton-crypto/dist/mnemonic/mnemonic.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mnemonicNew = exports.mnemonicValidate = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicToSeed = exports.mnemonicToEntropy = void 0;
      var tweetnacl_1 = __importDefault(require_nacl_fast());
      var getSecureRandom_1 = require_getSecureRandom2();
      var hmac_sha512_1 = require_hmac_sha5122();
      var pbkdf2_sha512_1 = require_pbkdf2_sha5122();
      var wordlist_1 = require_wordlist();
      var PBKDF_ITERATIONS = 1e5;
      function isPasswordNeeded(mnemonicArray) {
        return __async(this, null, function* () {
          const passlessEntropy = yield mnemonicToEntropy(mnemonicArray);
          return (yield isPasswordSeed(passlessEntropy)) && !(yield isBasicSeed(passlessEntropy));
        });
      }
      function normalizeMnemonic(src) {
        return src.map((v) => v.toLowerCase().trim());
      }
      function isBasicSeed(entropy) {
        return __async(this, null, function* () {
          const seed = yield (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON seed version", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64);
          return seed[0] == 0;
        });
      }
      function isPasswordSeed(entropy) {
        return __async(this, null, function* () {
          const seed = yield (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON fast seed version", 1, 64);
          return seed[0] == 1;
        });
      }
      function mnemonicToEntropy(mnemonicArray, password) {
        return __async(this, null, function* () {
          return yield (0, hmac_sha512_1.hmac_sha512)(mnemonicArray.join(" "), password && password.length > 0 ? password : "");
        });
      }
      exports.mnemonicToEntropy = mnemonicToEntropy;
      function mnemonicToSeed(mnemonicArray, seed, password) {
        return __async(this, null, function* () {
          const entropy = yield mnemonicToEntropy(mnemonicArray, password);
          const res = yield (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, seed, PBKDF_ITERATIONS, 64);
          return res.slice(0, 32);
        });
      }
      exports.mnemonicToSeed = mnemonicToSeed;
      function mnemonicToPrivateKey(mnemonicArray, password) {
        return __async(this, null, function* () {
          mnemonicArray = normalizeMnemonic(mnemonicArray);
          const seed = yield mnemonicToSeed(mnemonicArray, "TON default seed", password);
          let keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seed);
          return {
            publicKey: Buffer.from(keyPair.publicKey),
            secretKey: Buffer.from(keyPair.secretKey)
          };
        });
      }
      exports.mnemonicToPrivateKey = mnemonicToPrivateKey;
      function mnemonicToWalletKey(mnemonicArray, password) {
        return __async(this, null, function* () {
          let seedPk = yield mnemonicToPrivateKey(mnemonicArray, password);
          let seedSecret = seedPk.secretKey.slice(0, 32);
          const keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seedSecret);
          return {
            publicKey: Buffer.from(keyPair.publicKey),
            secretKey: Buffer.from(keyPair.secretKey)
          };
        });
      }
      exports.mnemonicToWalletKey = mnemonicToWalletKey;
      function mnemonicValidate(mnemonicArray, password) {
        return __async(this, null, function* () {
          mnemonicArray = normalizeMnemonic(mnemonicArray);
          for (let word of mnemonicArray) {
            if (wordlist_1.wordlist.indexOf(word) < 0) {
              return false;
            }
          }
          if (password && password.length > 0) {
            if (!(yield isPasswordNeeded(mnemonicArray))) {
              return false;
            }
          }
          return yield isBasicSeed(yield mnemonicToEntropy(mnemonicArray, password));
        });
      }
      exports.mnemonicValidate = mnemonicValidate;
      function mnemonicNew(wordsCount = 24, password) {
        return __async(this, null, function* () {
          let mnemonicArray = [];
          while (true) {
            mnemonicArray = [];
            for (let i = 0; i < wordsCount; i++) {
              let ind = yield (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);
              mnemonicArray.push(wordlist_1.wordlist[ind]);
            }
            if (password && password.length > 0) {
              if (!(yield isPasswordNeeded(mnemonicArray))) {
                continue;
              }
            }
            if (!(yield isBasicSeed(yield mnemonicToEntropy(mnemonicArray, password)))) {
              continue;
            }
            break;
          }
          return mnemonicArray;
        });
      }
      exports.mnemonicNew = mnemonicNew;
    }
  });

  // node_modules/ton-crypto/dist/primitives/nacl.js
  var require_nacl = __commonJS({
    "node_modules/ton-crypto/dist/primitives/nacl.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.openBox = exports.sealBox = exports.signVerify = exports.sign = exports.keyPairFromSeed = exports.keyPairFromSecretKey = void 0;
      var tweetnacl_1 = __importDefault(require_nacl_fast());
      function keyPairFromSecretKey(secretKey) {
        let res = tweetnacl_1.default.sign.keyPair.fromSecretKey(new Uint8Array(secretKey));
        return {
          publicKey: Buffer.from(res.publicKey),
          secretKey: Buffer.from(res.secretKey)
        };
      }
      exports.keyPairFromSecretKey = keyPairFromSecretKey;
      function keyPairFromSeed(secretKey) {
        let res = tweetnacl_1.default.sign.keyPair.fromSeed(new Uint8Array(secretKey));
        return {
          publicKey: Buffer.from(res.publicKey),
          secretKey: Buffer.from(res.secretKey)
        };
      }
      exports.keyPairFromSeed = keyPairFromSeed;
      function sign(data, secretKey) {
        return Buffer.from(tweetnacl_1.default.sign.detached(new Uint8Array(data), new Uint8Array(secretKey)));
      }
      exports.sign = sign;
      function signVerify(data, signature, publicKey) {
        return tweetnacl_1.default.sign.detached.verify(new Uint8Array(data), new Uint8Array(signature), new Uint8Array(publicKey));
      }
      exports.signVerify = signVerify;
      function sealBox(data, nonce, key) {
        return Buffer.from(tweetnacl_1.default.secretbox(data, nonce, key));
      }
      exports.sealBox = sealBox;
      function openBox(data, nonce, key) {
        let res = tweetnacl_1.default.secretbox.open(data, nonce, key);
        if (!res) {
          return null;
        }
        return Buffer.from(res);
      }
      exports.openBox = openBox;
    }
  });

  // node_modules/ton-crypto/dist/passwords/wordlist.js
  var require_wordlist2 = __commonJS({
    "node_modules/ton-crypto/dist/passwords/wordlist.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.wordlist = void 0;
      exports.wordlist = [
        "abacus",
        "abdomen",
        "abdominal",
        "abide",
        "abiding",
        "ability",
        "ablaze",
        "able",
        "abnormal",
        "abrasion",
        "abrasive",
        "abreast",
        "abridge",
        "abroad",
        "abruptly",
        "absence",
        "absentee",
        "absently",
        "absinthe",
        "absolute",
        "absolve",
        "abstain",
        "abstract",
        "absurd",
        "accent",
        "acclaim",
        "acclimate",
        "accompany",
        "account",
        "accuracy",
        "accurate",
        "accustom",
        "acetone",
        "achiness",
        "aching",
        "acid",
        "acorn",
        "acquaint",
        "acquire",
        "acre",
        "acrobat",
        "acronym",
        "acting",
        "action",
        "activate",
        "activator",
        "active",
        "activism",
        "activist",
        "activity",
        "actress",
        "acts",
        "acutely",
        "acuteness",
        "aeration",
        "aerobics",
        "aerosol",
        "aerospace",
        "afar",
        "affair",
        "affected",
        "affecting",
        "affection",
        "affidavit",
        "affiliate",
        "affirm",
        "affix",
        "afflicted",
        "affluent",
        "afford",
        "affront",
        "aflame",
        "afloat",
        "aflutter",
        "afoot",
        "afraid",
        "afterglow",
        "afterlife",
        "aftermath",
        "aftermost",
        "afternoon",
        "aged",
        "ageless",
        "agency",
        "agenda",
        "agent",
        "aggregate",
        "aghast",
        "agile",
        "agility",
        "aging",
        "agnostic",
        "agonize",
        "agonizing",
        "agony",
        "agreeable",
        "agreeably",
        "agreed",
        "agreeing",
        "agreement",
        "aground",
        "ahead",
        "ahoy",
        "aide",
        "aids",
        "aim",
        "ajar",
        "alabaster",
        "alarm",
        "albatross",
        "album",
        "alfalfa",
        "algebra",
        "algorithm",
        "alias",
        "alibi",
        "alienable",
        "alienate",
        "aliens",
        "alike",
        "alive",
        "alkaline",
        "alkalize",
        "almanac",
        "almighty",
        "almost",
        "aloe",
        "aloft",
        "aloha",
        "alone",
        "alongside",
        "aloof",
        "alphabet",
        "alright",
        "although",
        "altitude",
        "alto",
        "aluminum",
        "alumni",
        "always",
        "amaretto",
        "amaze",
        "amazingly",
        "amber",
        "ambiance",
        "ambiguity",
        "ambiguous",
        "ambition",
        "ambitious",
        "ambulance",
        "ambush",
        "amendable",
        "amendment",
        "amends",
        "amenity",
        "amiable",
        "amicably",
        "amid",
        "amigo",
        "amino",
        "amiss",
        "ammonia",
        "ammonium",
        "amnesty",
        "amniotic",
        "among",
        "amount",
        "amperage",
        "ample",
        "amplifier",
        "amplify",
        "amply",
        "amuck",
        "amulet",
        "amusable",
        "amused",
        "amusement",
        "amuser",
        "amusing",
        "anaconda",
        "anaerobic",
        "anagram",
        "anatomist",
        "anatomy",
        "anchor",
        "anchovy",
        "ancient",
        "android",
        "anemia",
        "anemic",
        "aneurism",
        "anew",
        "angelfish",
        "angelic",
        "anger",
        "angled",
        "angler",
        "angles",
        "angling",
        "angrily",
        "angriness",
        "anguished",
        "angular",
        "animal",
        "animate",
        "animating",
        "animation",
        "animator",
        "anime",
        "animosity",
        "ankle",
        "annex",
        "annotate",
        "announcer",
        "annoying",
        "annually",
        "annuity",
        "anointer",
        "another",
        "answering",
        "antacid",
        "antarctic",
        "anteater",
        "antelope",
        "antennae",
        "anthem",
        "anthill",
        "anthology",
        "antibody",
        "antics",
        "antidote",
        "antihero",
        "antiquely",
        "antiques",
        "antiquity",
        "antirust",
        "antitoxic",
        "antitrust",
        "antiviral",
        "antivirus",
        "antler",
        "antonym",
        "antsy",
        "anvil",
        "anybody",
        "anyhow",
        "anymore",
        "anyone",
        "anyplace",
        "anything",
        "anytime",
        "anyway",
        "anywhere",
        "aorta",
        "apache",
        "apostle",
        "appealing",
        "appear",
        "appease",
        "appeasing",
        "appendage",
        "appendix",
        "appetite",
        "appetizer",
        "applaud",
        "applause",
        "apple",
        "appliance",
        "applicant",
        "applied",
        "apply",
        "appointee",
        "appraisal",
        "appraiser",
        "apprehend",
        "approach",
        "approval",
        "approve",
        "apricot",
        "april",
        "apron",
        "aptitude",
        "aptly",
        "aqua",
        "aqueduct",
        "arbitrary",
        "arbitrate",
        "ardently",
        "area",
        "arena",
        "arguable",
        "arguably",
        "argue",
        "arise",
        "armadillo",
        "armband",
        "armchair",
        "armed",
        "armful",
        "armhole",
        "arming",
        "armless",
        "armoire",
        "armored",
        "armory",
        "armrest",
        "army",
        "aroma",
        "arose",
        "around",
        "arousal",
        "arrange",
        "array",
        "arrest",
        "arrival",
        "arrive",
        "arrogance",
        "arrogant",
        "arson",
        "art",
        "ascend",
        "ascension",
        "ascent",
        "ascertain",
        "ashamed",
        "ashen",
        "ashes",
        "ashy",
        "aside",
        "askew",
        "asleep",
        "asparagus",
        "aspect",
        "aspirate",
        "aspire",
        "aspirin",
        "astonish",
        "astound",
        "astride",
        "astrology",
        "astronaut",
        "astronomy",
        "astute",
        "atlantic",
        "atlas",
        "atom",
        "atonable",
        "atop",
        "atrium",
        "atrocious",
        "atrophy",
        "attach",
        "attain",
        "attempt",
        "attendant",
        "attendee",
        "attention",
        "attentive",
        "attest",
        "attic",
        "attire",
        "attitude",
        "attractor",
        "attribute",
        "atypical",
        "auction",
        "audacious",
        "audacity",
        "audible",
        "audibly",
        "audience",
        "audio",
        "audition",
        "augmented",
        "august",
        "authentic",
        "author",
        "autism",
        "autistic",
        "autograph",
        "automaker",
        "automated",
        "automatic",
        "autopilot",
        "available",
        "avalanche",
        "avatar",
        "avenge",
        "avenging",
        "avenue",
        "average",
        "aversion",
        "avert",
        "aviation",
        "aviator",
        "avid",
        "avoid",
        "await",
        "awaken",
        "award",
        "aware",
        "awhile",
        "awkward",
        "awning",
        "awoke",
        "awry",
        "axis",
        "babble",
        "babbling",
        "babied",
        "baboon",
        "backache",
        "backboard",
        "backboned",
        "backdrop",
        "backed",
        "backer",
        "backfield",
        "backfire",
        "backhand",
        "backing",
        "backlands",
        "backlash",
        "backless",
        "backlight",
        "backlit",
        "backlog",
        "backpack",
        "backpedal",
        "backrest",
        "backroom",
        "backshift",
        "backside",
        "backslid",
        "backspace",
        "backspin",
        "backstab",
        "backstage",
        "backtalk",
        "backtrack",
        "backup",
        "backward",
        "backwash",
        "backwater",
        "backyard",
        "bacon",
        "bacteria",
        "bacterium",
        "badass",
        "badge",
        "badland",
        "badly",
        "badness",
        "baffle",
        "baffling",
        "bagel",
        "bagful",
        "baggage",
        "bagged",
        "baggie",
        "bagginess",
        "bagging",
        "baggy",
        "bagpipe",
        "baguette",
        "baked",
        "bakery",
        "bakeshop",
        "baking",
        "balance",
        "balancing",
        "balcony",
        "balmy",
        "balsamic",
        "bamboo",
        "banana",
        "banish",
        "banister",
        "banjo",
        "bankable",
        "bankbook",
        "banked",
        "banker",
        "banking",
        "banknote",
        "bankroll",
        "banner",
        "bannister",
        "banshee",
        "banter",
        "barbecue",
        "barbed",
        "barbell",
        "barber",
        "barcode",
        "barge",
        "bargraph",
        "barista",
        "baritone",
        "barley",
        "barmaid",
        "barman",
        "barn",
        "barometer",
        "barrack",
        "barracuda",
        "barrel",
        "barrette",
        "barricade",
        "barrier",
        "barstool",
        "bartender",
        "barterer",
        "bash",
        "basically",
        "basics",
        "basil",
        "basin",
        "basis",
        "basket",
        "batboy",
        "batch",
        "bath",
        "baton",
        "bats",
        "battalion",
        "battered",
        "battering",
        "battery",
        "batting",
        "battle",
        "bauble",
        "bazooka",
        "blabber",
        "bladder",
        "blade",
        "blah",
        "blame",
        "blaming",
        "blanching",
        "blandness",
        "blank",
        "blaspheme",
        "blasphemy",
        "blast",
        "blatancy",
        "blatantly",
        "blazer",
        "blazing",
        "bleach",
        "bleak",
        "bleep",
        "blemish",
        "blend",
        "bless",
        "blighted",
        "blimp",
        "bling",
        "blinked",
        "blinker",
        "blinking",
        "blinks",
        "blip",
        "blissful",
        "blitz",
        "blizzard",
        "bloated",
        "bloating",
        "blob",
        "blog",
        "bloomers",
        "blooming",
        "blooper",
        "blot",
        "blouse",
        "blubber",
        "bluff",
        "bluish",
        "blunderer",
        "blunt",
        "blurb",
        "blurred",
        "blurry",
        "blurt",
        "blush",
        "blustery",
        "boaster",
        "boastful",
        "boasting",
        "boat",
        "bobbed",
        "bobbing",
        "bobble",
        "bobcat",
        "bobsled",
        "bobtail",
        "bodacious",
        "body",
        "bogged",
        "boggle",
        "bogus",
        "boil",
        "bok",
        "bolster",
        "bolt",
        "bonanza",
        "bonded",
        "bonding",
        "bondless",
        "boned",
        "bonehead",
        "boneless",
        "bonelike",
        "boney",
        "bonfire",
        "bonnet",
        "bonsai",
        "bonus",
        "bony",
        "boogeyman",
        "boogieman",
        "book",
        "boondocks",
        "booted",
        "booth",
        "bootie",
        "booting",
        "bootlace",
        "bootleg",
        "boots",
        "boozy",
        "borax",
        "boring",
        "borough",
        "borrower",
        "borrowing",
        "boss",
        "botanical",
        "botanist",
        "botany",
        "botch",
        "both",
        "bottle",
        "bottling",
        "bottom",
        "bounce",
        "bouncing",
        "bouncy",
        "bounding",
        "boundless",
        "bountiful",
        "bovine",
        "boxcar",
        "boxer",
        "boxing",
        "boxlike",
        "boxy",
        "breach",
        "breath",
        "breeches",
        "breeching",
        "breeder",
        "breeding",
        "breeze",
        "breezy",
        "brethren",
        "brewery",
        "brewing",
        "briar",
        "bribe",
        "brick",
        "bride",
        "bridged",
        "brigade",
        "bright",
        "brilliant",
        "brim",
        "bring",
        "brink",
        "brisket",
        "briskly",
        "briskness",
        "bristle",
        "brittle",
        "broadband",
        "broadcast",
        "broaden",
        "broadly",
        "broadness",
        "broadside",
        "broadways",
        "broiler",
        "broiling",
        "broken",
        "broker",
        "bronchial",
        "bronco",
        "bronze",
        "bronzing",
        "brook",
        "broom",
        "brought",
        "browbeat",
        "brownnose",
        "browse",
        "browsing",
        "bruising",
        "brunch",
        "brunette",
        "brunt",
        "brush",
        "brussels",
        "brute",
        "brutishly",
        "bubble",
        "bubbling",
        "bubbly",
        "buccaneer",
        "bucked",
        "bucket",
        "buckle",
        "buckshot",
        "buckskin",
        "bucktooth",
        "buckwheat",
        "buddhism",
        "buddhist",
        "budding",
        "buddy",
        "budget",
        "buffalo",
        "buffed",
        "buffer",
        "buffing",
        "buffoon",
        "buggy",
        "bulb",
        "bulge",
        "bulginess",
        "bulgur",
        "bulk",
        "bulldog",
        "bulldozer",
        "bullfight",
        "bullfrog",
        "bullhorn",
        "bullion",
        "bullish",
        "bullpen",
        "bullring",
        "bullseye",
        "bullwhip",
        "bully",
        "bunch",
        "bundle",
        "bungee",
        "bunion",
        "bunkbed",
        "bunkhouse",
        "bunkmate",
        "bunny",
        "bunt",
        "busboy",
        "bush",
        "busily",
        "busload",
        "bust",
        "busybody",
        "buzz",
        "cabana",
        "cabbage",
        "cabbie",
        "cabdriver",
        "cable",
        "caboose",
        "cache",
        "cackle",
        "cacti",
        "cactus",
        "caddie",
        "caddy",
        "cadet",
        "cadillac",
        "cadmium",
        "cage",
        "cahoots",
        "cake",
        "calamari",
        "calamity",
        "calcium",
        "calculate",
        "calculus",
        "caliber",
        "calibrate",
        "calm",
        "caloric",
        "calorie",
        "calzone",
        "camcorder",
        "cameo",
        "camera",
        "camisole",
        "camper",
        "campfire",
        "camping",
        "campsite",
        "campus",
        "canal",
        "canary",
        "cancel",
        "candied",
        "candle",
        "candy",
        "cane",
        "canine",
        "canister",
        "cannabis",
        "canned",
        "canning",
        "cannon",
        "cannot",
        "canola",
        "canon",
        "canopener",
        "canopy",
        "canteen",
        "canyon",
        "capable",
        "capably",
        "capacity",
        "cape",
        "capillary",
        "capital",
        "capitol",
        "capped",
        "capricorn",
        "capsize",
        "capsule",
        "caption",
        "captivate",
        "captive",
        "captivity",
        "capture",
        "caramel",
        "carat",
        "caravan",
        "carbon",
        "cardboard",
        "carded",
        "cardiac",
        "cardigan",
        "cardinal",
        "cardstock",
        "carefully",
        "caregiver",
        "careless",
        "caress",
        "caretaker",
        "cargo",
        "caring",
        "carless",
        "carload",
        "carmaker",
        "carnage",
        "carnation",
        "carnival",
        "carnivore",
        "carol",
        "carpenter",
        "carpentry",
        "carpool",
        "carport",
        "carried",
        "carrot",
        "carrousel",
        "carry",
        "cartel",
        "cartload",
        "carton",
        "cartoon",
        "cartridge",
        "cartwheel",
        "carve",
        "carving",
        "carwash",
        "cascade",
        "case",
        "cash",
        "casing",
        "casino",
        "casket",
        "cassette",
        "casually",
        "casualty",
        "catacomb",
        "catalog",
        "catalyst",
        "catalyze",
        "catapult",
        "cataract",
        "catatonic",
        "catcall",
        "catchable",
        "catcher",
        "catching",
        "catchy",
        "caterer",
        "catering",
        "catfight",
        "catfish",
        "cathedral",
        "cathouse",
        "catlike",
        "catnap",
        "catnip",
        "catsup",
        "cattail",
        "cattishly",
        "cattle",
        "catty",
        "catwalk",
        "caucasian",
        "caucus",
        "causal",
        "causation",
        "cause",
        "causing",
        "cauterize",
        "caution",
        "cautious",
        "cavalier",
        "cavalry",
        "caviar",
        "cavity",
        "cedar",
        "celery",
        "celestial",
        "celibacy",
        "celibate",
        "celtic",
        "cement",
        "census",
        "ceramics",
        "ceremony",
        "certainly",
        "certainty",
        "certified",
        "certify",
        "cesarean",
        "cesspool",
        "chafe",
        "chaffing",
        "chain",
        "chair",
        "chalice",
        "challenge",
        "chamber",
        "chamomile",
        "champion",
        "chance",
        "change",
        "channel",
        "chant",
        "chaos",
        "chaperone",
        "chaplain",
        "chapped",
        "chaps",
        "chapter",
        "character",
        "charbroil",
        "charcoal",
        "charger",
        "charging",
        "chariot",
        "charity",
        "charm",
        "charred",
        "charter",
        "charting",
        "chase",
        "chasing",
        "chaste",
        "chastise",
        "chastity",
        "chatroom",
        "chatter",
        "chatting",
        "chatty",
        "cheating",
        "cheddar",
        "cheek",
        "cheer",
        "cheese",
        "cheesy",
        "chef",
        "chemicals",
        "chemist",
        "chemo",
        "cherisher",
        "cherub",
        "chess",
        "chest",
        "chevron",
        "chevy",
        "chewable",
        "chewer",
        "chewing",
        "chewy",
        "chief",
        "chihuahua",
        "childcare",
        "childhood",
        "childish",
        "childless",
        "childlike",
        "chili",
        "chill",
        "chimp",
        "chip",
        "chirping",
        "chirpy",
        "chitchat",
        "chivalry",
        "chive",
        "chloride",
        "chlorine",
        "choice",
        "chokehold",
        "choking",
        "chomp",
        "chooser",
        "choosing",
        "choosy",
        "chop",
        "chosen",
        "chowder",
        "chowtime",
        "chrome",
        "chubby",
        "chuck",
        "chug",
        "chummy",
        "chump",
        "chunk",
        "churn",
        "chute",
        "cider",
        "cilantro",
        "cinch",
        "cinema",
        "cinnamon",
        "circle",
        "circling",
        "circular",
        "circulate",
        "circus",
        "citable",
        "citadel",
        "citation",
        "citizen",
        "citric",
        "citrus",
        "city",
        "civic",
        "civil",
        "clad",
        "claim",
        "clambake",
        "clammy",
        "clamor",
        "clamp",
        "clamshell",
        "clang",
        "clanking",
        "clapped",
        "clapper",
        "clapping",
        "clarify",
        "clarinet",
        "clarity",
        "clash",
        "clasp",
        "class",
        "clatter",
        "clause",
        "clavicle",
        "claw",
        "clay",
        "clean",
        "clear",
        "cleat",
        "cleaver",
        "cleft",
        "clench",
        "clergyman",
        "clerical",
        "clerk",
        "clever",
        "clicker",
        "client",
        "climate",
        "climatic",
        "cling",
        "clinic",
        "clinking",
        "clip",
        "clique",
        "cloak",
        "clobber",
        "clock",
        "clone",
        "cloning",
        "closable",
        "closure",
        "clothes",
        "clothing",
        "cloud",
        "clover",
        "clubbed",
        "clubbing",
        "clubhouse",
        "clump",
        "clumsily",
        "clumsy",
        "clunky",
        "clustered",
        "clutch",
        "clutter",
        "coach",
        "coagulant",
        "coastal",
        "coaster",
        "coasting",
        "coastland",
        "coastline",
        "coat",
        "coauthor",
        "cobalt",
        "cobbler",
        "cobweb",
        "cocoa",
        "coconut",
        "cod",
        "coeditor",
        "coerce",
        "coexist",
        "coffee",
        "cofounder",
        "cognition",
        "cognitive",
        "cogwheel",
        "coherence",
        "coherent",
        "cohesive",
        "coil",
        "coke",
        "cola",
        "cold",
        "coleslaw",
        "coliseum",
        "collage",
        "collapse",
        "collar",
        "collected",
        "collector",
        "collide",
        "collie",
        "collision",
        "colonial",
        "colonist",
        "colonize",
        "colony",
        "colossal",
        "colt",
        "coma",
        "come",
        "comfort",
        "comfy",
        "comic",
        "coming",
        "comma",
        "commence",
        "commend",
        "comment",
        "commerce",
        "commode",
        "commodity",
        "commodore",
        "common",
        "commotion",
        "commute",
        "commuting",
        "compacted",
        "compacter",
        "compactly",
        "compactor",
        "companion",
        "company",
        "compare",
        "compel",
        "compile",
        "comply",
        "component",
        "composed",
        "composer",
        "composite",
        "compost",
        "composure",
        "compound",
        "compress",
        "comprised",
        "computer",
        "computing",
        "comrade",
        "concave",
        "conceal",
        "conceded",
        "concept",
        "concerned",
        "concert",
        "conch",
        "concierge",
        "concise",
        "conclude",
        "concrete",
        "concur",
        "condense",
        "condiment",
        "condition",
        "condone",
        "conducive",
        "conductor",
        "conduit",
        "cone",
        "confess",
        "confetti",
        "confidant",
        "confident",
        "confider",
        "confiding",
        "configure",
        "confined",
        "confining",
        "confirm",
        "conflict",
        "conform",
        "confound",
        "confront",
        "confused",
        "confusing",
        "confusion",
        "congenial",
        "congested",
        "congrats",
        "congress",
        "conical",
        "conjoined",
        "conjure",
        "conjuror",
        "connected",
        "connector",
        "consensus",
        "consent",
        "console",
        "consoling",
        "consonant",
        "constable",
        "constant",
        "constrain",
        "constrict",
        "construct",
        "consult",
        "consumer",
        "consuming",
        "contact",
        "container",
        "contempt",
        "contend",
        "contented",
        "contently",
        "contents",
        "contest",
        "context",
        "contort",
        "contour",
        "contrite",
        "control",
        "contusion",
        "convene",
        "convent",
        "copartner",
        "cope",
        "copied",
        "copier",
        "copilot",
        "coping",
        "copious",
        "copper",
        "copy",
        "coral",
        "cork",
        "cornball",
        "cornbread",
        "corncob",
        "cornea",
        "corned",
        "corner",
        "cornfield",
        "cornflake",
        "cornhusk",
        "cornmeal",
        "cornstalk",
        "corny",
        "coronary",
        "coroner",
        "corporal",
        "corporate",
        "corral",
        "correct",
        "corridor",
        "corrode",
        "corroding",
        "corrosive",
        "corsage",
        "corset",
        "cortex",
        "cosigner",
        "cosmetics",
        "cosmic",
        "cosmos",
        "cosponsor",
        "cost",
        "cottage",
        "cotton",
        "couch",
        "cough",
        "could",
        "countable",
        "countdown",
        "counting",
        "countless",
        "country",
        "county",
        "courier",
        "covenant",
        "cover",
        "coveted",
        "coveting",
        "coyness",
        "cozily",
        "coziness",
        "cozy",
        "crabbing",
        "crabgrass",
        "crablike",
        "crabmeat",
        "cradle",
        "cradling",
        "crafter",
        "craftily",
        "craftsman",
        "craftwork",
        "crafty",
        "cramp",
        "cranberry",
        "crane",
        "cranial",
        "cranium",
        "crank",
        "crate",
        "crave",
        "craving",
        "crawfish",
        "crawlers",
        "crawling",
        "crayfish",
        "crayon",
        "crazed",
        "crazily",
        "craziness",
        "crazy",
        "creamed",
        "creamer",
        "creamlike",
        "crease",
        "creasing",
        "creatable",
        "create",
        "creation",
        "creative",
        "creature",
        "credible",
        "credibly",
        "credit",
        "creed",
        "creme",
        "creole",
        "crepe",
        "crept",
        "crescent",
        "crested",
        "cresting",
        "crestless",
        "crevice",
        "crewless",
        "crewman",
        "crewmate",
        "crib",
        "cricket",
        "cried",
        "crier",
        "crimp",
        "crimson",
        "cringe",
        "cringing",
        "crinkle",
        "crinkly",
        "crisped",
        "crisping",
        "crisply",
        "crispness",
        "crispy",
        "criteria",
        "critter",
        "croak",
        "crock",
        "crook",
        "croon",
        "crop",
        "cross",
        "crouch",
        "crouton",
        "crowbar",
        "crowd",
        "crown",
        "crucial",
        "crudely",
        "crudeness",
        "cruelly",
        "cruelness",
        "cruelty",
        "crumb",
        "crummiest",
        "crummy",
        "crumpet",
        "crumpled",
        "cruncher",
        "crunching",
        "crunchy",
        "crusader",
        "crushable",
        "crushed",
        "crusher",
        "crushing",
        "crust",
        "crux",
        "crying",
        "cryptic",
        "crystal",
        "cubbyhole",
        "cube",
        "cubical",
        "cubicle",
        "cucumber",
        "cuddle",
        "cuddly",
        "cufflink",
        "culinary",
        "culminate",
        "culpable",
        "culprit",
        "cultivate",
        "cultural",
        "culture",
        "cupbearer",
        "cupcake",
        "cupid",
        "cupped",
        "cupping",
        "curable",
        "curator",
        "curdle",
        "cure",
        "curfew",
        "curing",
        "curled",
        "curler",
        "curliness",
        "curling",
        "curly",
        "curry",
        "curse",
        "cursive",
        "cursor",
        "curtain",
        "curtly",
        "curtsy",
        "curvature",
        "curve",
        "curvy",
        "cushy",
        "cusp",
        "cussed",
        "custard",
        "custodian",
        "custody",
        "customary",
        "customer",
        "customize",
        "customs",
        "cut",
        "cycle",
        "cyclic",
        "cycling",
        "cyclist",
        "cylinder",
        "cymbal",
        "cytoplasm",
        "cytoplast",
        "dab",
        "dad",
        "daffodil",
        "dagger",
        "daily",
        "daintily",
        "dainty",
        "dairy",
        "daisy",
        "dallying",
        "dance",
        "dancing",
        "dandelion",
        "dander",
        "dandruff",
        "dandy",
        "danger",
        "dangle",
        "dangling",
        "daredevil",
        "dares",
        "daringly",
        "darkened",
        "darkening",
        "darkish",
        "darkness",
        "darkroom",
        "darling",
        "darn",
        "dart",
        "darwinism",
        "dash",
        "dastardly",
        "data",
        "datebook",
        "dating",
        "daughter",
        "daunting",
        "dawdler",
        "dawn",
        "daybed",
        "daybreak",
        "daycare",
        "daydream",
        "daylight",
        "daylong",
        "dayroom",
        "daytime",
        "dazzler",
        "dazzling",
        "deacon",
        "deafening",
        "deafness",
        "dealer",
        "dealing",
        "dealmaker",
        "dealt",
        "dean",
        "debatable",
        "debate",
        "debating",
        "debit",
        "debrief",
        "debtless",
        "debtor",
        "debug",
        "debunk",
        "decade",
        "decaf",
        "decal",
        "decathlon",
        "decay",
        "deceased",
        "deceit",
        "deceiver",
        "deceiving",
        "december",
        "decency",
        "decent",
        "deception",
        "deceptive",
        "decibel",
        "decidable",
        "decimal",
        "decimeter",
        "decipher",
        "deck",
        "declared",
        "decline",
        "decode",
        "decompose",
        "decorated",
        "decorator",
        "decoy",
        "decrease",
        "decree",
        "dedicate",
        "dedicator",
        "deduce",
        "deduct",
        "deed",
        "deem",
        "deepen",
        "deeply",
        "deepness",
        "deface",
        "defacing",
        "defame",
        "default",
        "defeat",
        "defection",
        "defective",
        "defendant",
        "defender",
        "defense",
        "defensive",
        "deferral",
        "deferred",
        "defiance",
        "defiant",
        "defile",
        "defiling",
        "define",
        "definite",
        "deflate",
        "deflation",
        "deflator",
        "deflected",
        "deflector",
        "defog",
        "deforest",
        "defraud",
        "defrost",
        "deftly",
        "defuse",
        "defy",
        "degraded",
        "degrading",
        "degrease",
        "degree",
        "dehydrate",
        "deity",
        "dejected",
        "delay",
        "delegate",
        "delegator",
        "delete",
        "deletion",
        "delicacy",
        "delicate",
        "delicious",
        "delighted",
        "delirious",
        "delirium",
        "deliverer",
        "delivery",
        "delouse",
        "delta",
        "deluge",
        "delusion",
        "deluxe",
        "demanding",
        "demeaning",
        "demeanor",
        "demise",
        "democracy",
        "democrat",
        "demote",
        "demotion",
        "demystify",
        "denatured",
        "deniable",
        "denial",
        "denim",
        "denote",
        "dense",
        "density",
        "dental",
        "dentist",
        "denture",
        "deny",
        "deodorant",
        "deodorize",
        "departed",
        "departure",
        "depict",
        "deplete",
        "depletion",
        "deplored",
        "deploy",
        "deport",
        "depose",
        "depraved",
        "depravity",
        "deprecate",
        "depress",
        "deprive",
        "depth",
        "deputize",
        "deputy",
        "derail",
        "deranged",
        "derby",
        "derived",
        "desecrate",
        "deserve",
        "deserving",
        "designate",
        "designed",
        "designer",
        "designing",
        "deskbound",
        "desktop",
        "deskwork",
        "desolate",
        "despair",
        "despise",
        "despite",
        "destiny",
        "destitute",
        "destruct",
        "detached",
        "detail",
        "detection",
        "detective",
        "detector",
        "detention",
        "detergent",
        "detest",
        "detonate",
        "detonator",
        "detoxify",
        "detract",
        "deuce",
        "devalue",
        "deviancy",
        "deviant",
        "deviate",
        "deviation",
        "deviator",
        "device",
        "devious",
        "devotedly",
        "devotee",
        "devotion",
        "devourer",
        "devouring",
        "devoutly",
        "dexterity",
        "dexterous",
        "diabetes",
        "diabetic",
        "diabolic",
        "diagnoses",
        "diagnosis",
        "diagram",
        "dial",
        "diameter",
        "diaper",
        "diaphragm",
        "diary",
        "dice",
        "dicing",
        "dictate",
        "dictation",
        "dictator",
        "difficult",
        "diffused",
        "diffuser",
        "diffusion",
        "diffusive",
        "dig",
        "dilation",
        "diligence",
        "diligent",
        "dill",
        "dilute",
        "dime",
        "diminish",
        "dimly",
        "dimmed",
        "dimmer",
        "dimness",
        "dimple",
        "diner",
        "dingbat",
        "dinghy",
        "dinginess",
        "dingo",
        "dingy",
        "dining",
        "dinner",
        "diocese",
        "dioxide",
        "diploma",
        "dipped",
        "dipper",
        "dipping",
        "directed",
        "direction",
        "directive",
        "directly",
        "directory",
        "direness",
        "dirtiness",
        "disabled",
        "disagree",
        "disallow",
        "disarm",
        "disarray",
        "disaster",
        "disband",
        "disbelief",
        "disburse",
        "discard",
        "discern",
        "discharge",
        "disclose",
        "discolor",
        "discount",
        "discourse",
        "discover",
        "discuss",
        "disdain",
        "disengage",
        "disfigure",
        "disgrace",
        "dish",
        "disinfect",
        "disjoin",
        "disk",
        "dislike",
        "disliking",
        "dislocate",
        "dislodge",
        "disloyal",
        "dismantle",
        "dismay",
        "dismiss",
        "dismount",
        "disobey",
        "disorder",
        "disown",
        "disparate",
        "disparity",
        "dispatch",
        "dispense",
        "dispersal",
        "dispersed",
        "disperser",
        "displace",
        "display",
        "displease",
        "disposal",
        "dispose",
        "disprove",
        "dispute",
        "disregard",
        "disrupt",
        "dissuade",
        "distance",
        "distant",
        "distaste",
        "distill",
        "distinct",
        "distort",
        "distract",
        "distress",
        "district",
        "distrust",
        "ditch",
        "ditto",
        "ditzy",
        "dividable",
        "divided",
        "dividend",
        "dividers",
        "dividing",
        "divinely",
        "diving",
        "divinity",
        "divisible",
        "divisibly",
        "division",
        "divisive",
        "divorcee",
        "dizziness",
        "dizzy",
        "doable",
        "docile",
        "dock",
        "doctrine",
        "document",
        "dodge",
        "dodgy",
        "doily",
        "doing",
        "dole",
        "dollar",
        "dollhouse",
        "dollop",
        "dolly",
        "dolphin",
        "domain",
        "domelike",
        "domestic",
        "dominion",
        "dominoes",
        "donated",
        "donation",
        "donator",
        "donor",
        "donut",
        "doodle",
        "doorbell",
        "doorframe",
        "doorknob",
        "doorman",
        "doormat",
        "doornail",
        "doorpost",
        "doorstep",
        "doorstop",
        "doorway",
        "doozy",
        "dork",
        "dormitory",
        "dorsal",
        "dosage",
        "dose",
        "dotted",
        "doubling",
        "douche",
        "dove",
        "down",
        "dowry",
        "doze",
        "drab",
        "dragging",
        "dragonfly",
        "dragonish",
        "dragster",
        "drainable",
        "drainage",
        "drained",
        "drainer",
        "drainpipe",
        "dramatic",
        "dramatize",
        "drank",
        "drapery",
        "drastic",
        "draw",
        "dreaded",
        "dreadful",
        "dreadlock",
        "dreamboat",
        "dreamily",
        "dreamland",
        "dreamless",
        "dreamlike",
        "dreamt",
        "dreamy",
        "drearily",
        "dreary",
        "drench",
        "dress",
        "drew",
        "dribble",
        "dried",
        "drier",
        "drift",
        "driller",
        "drilling",
        "drinkable",
        "drinking",
        "dripping",
        "drippy",
        "drivable",
        "driven",
        "driver",
        "driveway",
        "driving",
        "drizzle",
        "drizzly",
        "drone",
        "drool",
        "droop",
        "drop-down",
        "dropbox",
        "dropkick",
        "droplet",
        "dropout",
        "dropper",
        "drove",
        "drown",
        "drowsily",
        "drudge",
        "drum",
        "dry",
        "dubbed",
        "dubiously",
        "duchess",
        "duckbill",
        "ducking",
        "duckling",
        "ducktail",
        "ducky",
        "duct",
        "dude",
        "duffel",
        "dugout",
        "duh",
        "duke",
        "duller",
        "dullness",
        "duly",
        "dumping",
        "dumpling",
        "dumpster",
        "duo",
        "dupe",
        "duplex",
        "duplicate",
        "duplicity",
        "durable",
        "durably",
        "duration",
        "duress",
        "during",
        "dusk",
        "dust",
        "dutiful",
        "duty",
        "duvet",
        "dwarf",
        "dweeb",
        "dwelled",
        "dweller",
        "dwelling",
        "dwindle",
        "dwindling",
        "dynamic",
        "dynamite",
        "dynasty",
        "dyslexia",
        "dyslexic",
        "each",
        "eagle",
        "earache",
        "eardrum",
        "earflap",
        "earful",
        "earlobe",
        "early",
        "earmark",
        "earmuff",
        "earphone",
        "earpiece",
        "earplugs",
        "earring",
        "earshot",
        "earthen",
        "earthlike",
        "earthling",
        "earthly",
        "earthworm",
        "earthy",
        "earwig",
        "easeful",
        "easel",
        "easiest",
        "easily",
        "easiness",
        "easing",
        "eastbound",
        "eastcoast",
        "easter",
        "eastward",
        "eatable",
        "eaten",
        "eatery",
        "eating",
        "eats",
        "ebay",
        "ebony",
        "ebook",
        "ecard",
        "eccentric",
        "echo",
        "eclair",
        "eclipse",
        "ecologist",
        "ecology",
        "economic",
        "economist",
        "economy",
        "ecosphere",
        "ecosystem",
        "edge",
        "edginess",
        "edging",
        "edgy",
        "edition",
        "editor",
        "educated",
        "education",
        "educator",
        "eel",
        "effective",
        "effects",
        "efficient",
        "effort",
        "eggbeater",
        "egging",
        "eggnog",
        "eggplant",
        "eggshell",
        "egomaniac",
        "egotism",
        "egotistic",
        "either",
        "eject",
        "elaborate",
        "elastic",
        "elated",
        "elbow",
        "eldercare",
        "elderly",
        "eldest",
        "electable",
        "election",
        "elective",
        "elephant",
        "elevate",
        "elevating",
        "elevation",
        "elevator",
        "eleven",
        "elf",
        "eligible",
        "eligibly",
        "eliminate",
        "elite",
        "elitism",
        "elixir",
        "elk",
        "ellipse",
        "elliptic",
        "elm",
        "elongated",
        "elope",
        "eloquence",
        "eloquent",
        "elsewhere",
        "elude",
        "elusive",
        "elves",
        "email",
        "embargo",
        "embark",
        "embassy",
        "embattled",
        "embellish",
        "ember",
        "embezzle",
        "emblaze",
        "emblem",
        "embody",
        "embolism",
        "emboss",
        "embroider",
        "emcee",
        "emerald",
        "emergency",
        "emission",
        "emit",
        "emote",
        "emoticon",
        "emotion",
        "empathic",
        "empathy",
        "emperor",
        "emphases",
        "emphasis",
        "emphasize",
        "emphatic",
        "empirical",
        "employed",
        "employee",
        "employer",
        "emporium",
        "empower",
        "emptier",
        "emptiness",
        "empty",
        "emu",
        "enable",
        "enactment",
        "enamel",
        "enchanted",
        "enchilada",
        "encircle",
        "enclose",
        "enclosure",
        "encode",
        "encore",
        "encounter",
        "encourage",
        "encroach",
        "encrust",
        "encrypt",
        "endanger",
        "endeared",
        "endearing",
        "ended",
        "ending",
        "endless",
        "endnote",
        "endocrine",
        "endorphin",
        "endorse",
        "endowment",
        "endpoint",
        "endurable",
        "endurance",
        "enduring",
        "energetic",
        "energize",
        "energy",
        "enforced",
        "enforcer",
        "engaged",
        "engaging",
        "engine",
        "engorge",
        "engraved",
        "engraver",
        "engraving",
        "engross",
        "engulf",
        "enhance",
        "enigmatic",
        "enjoyable",
        "enjoyably",
        "enjoyer",
        "enjoying",
        "enjoyment",
        "enlarged",
        "enlarging",
        "enlighten",
        "enlisted",
        "enquirer",
        "enrage",
        "enrich",
        "enroll",
        "enslave",
        "ensnare",
        "ensure",
        "entail",
        "entangled",
        "entering",
        "entertain",
        "enticing",
        "entire",
        "entitle",
        "entity",
        "entomb",
        "entourage",
        "entrap",
        "entree",
        "entrench",
        "entrust",
        "entryway",
        "entwine",
        "enunciate",
        "envelope",
        "enviable",
        "enviably",
        "envious",
        "envision",
        "envoy",
        "envy",
        "enzyme",
        "epic",
        "epidemic",
        "epidermal",
        "epidermis",
        "epidural",
        "epilepsy",
        "epileptic",
        "epilogue",
        "epiphany",
        "episode",
        "equal",
        "equate",
        "equation",
        "equator",
        "equinox",
        "equipment",
        "equity",
        "equivocal",
        "eradicate",
        "erasable",
        "erased",
        "eraser",
        "erasure",
        "ergonomic",
        "errand",
        "errant",
        "erratic",
        "error",
        "erupt",
        "escalate",
        "escalator",
        "escapable",
        "escapade",
        "escapist",
        "escargot",
        "eskimo",
        "esophagus",
        "espionage",
        "espresso",
        "esquire",
        "essay",
        "essence",
        "essential",
        "establish",
        "estate",
        "esteemed",
        "estimate",
        "estimator",
        "estranged",
        "estrogen",
        "etching",
        "eternal",
        "eternity",
        "ethanol",
        "ether",
        "ethically",
        "ethics",
        "euphemism",
        "evacuate",
        "evacuee",
        "evade",
        "evaluate",
        "evaluator",
        "evaporate",
        "evasion",
        "evasive",
        "even",
        "everglade",
        "evergreen",
        "everybody",
        "everyday",
        "everyone",
        "evict",
        "evidence",
        "evident",
        "evil",
        "evoke",
        "evolution",
        "evolve",
        "exact",
        "exalted",
        "example",
        "excavate",
        "excavator",
        "exceeding",
        "exception",
        "excess",
        "exchange",
        "excitable",
        "exciting",
        "exclaim",
        "exclude",
        "excluding",
        "exclusion",
        "exclusive",
        "excretion",
        "excretory",
        "excursion",
        "excusable",
        "excusably",
        "excuse",
        "exemplary",
        "exemplify",
        "exemption",
        "exerciser",
        "exert",
        "exes",
        "exfoliate",
        "exhale",
        "exhaust",
        "exhume",
        "exile",
        "existing",
        "exit",
        "exodus",
        "exonerate",
        "exorcism",
        "exorcist",
        "expand",
        "expanse",
        "expansion",
        "expansive",
        "expectant",
        "expedited",
        "expediter",
        "expel",
        "expend",
        "expenses",
        "expensive",
        "expert",
        "expire",
        "expiring",
        "explain",
        "expletive",
        "explicit",
        "explode",
        "exploit",
        "explore",
        "exploring",
        "exponent",
        "exporter",
        "exposable",
        "expose",
        "exposure",
        "express",
        "expulsion",
        "exquisite",
        "extended",
        "extending",
        "extent",
        "extenuate",
        "exterior",
        "external",
        "extinct",
        "extortion",
        "extradite",
        "extras",
        "extrovert",
        "extrude",
        "extruding",
        "exuberant",
        "fable",
        "fabric",
        "fabulous",
        "facebook",
        "facecloth",
        "facedown",
        "faceless",
        "facelift",
        "faceplate",
        "faceted",
        "facial",
        "facility",
        "facing",
        "facsimile",
        "faction",
        "factoid",
        "factor",
        "factsheet",
        "factual",
        "faculty",
        "fade",
        "fading",
        "failing",
        "falcon",
        "fall",
        "false",
        "falsify",
        "fame",
        "familiar",
        "family",
        "famine",
        "famished",
        "fanatic",
        "fancied",
        "fanciness",
        "fancy",
        "fanfare",
        "fang",
        "fanning",
        "fantasize",
        "fantastic",
        "fantasy",
        "fascism",
        "fastball",
        "faster",
        "fasting",
        "fastness",
        "faucet",
        "favorable",
        "favorably",
        "favored",
        "favoring",
        "favorite",
        "fax",
        "feast",
        "federal",
        "fedora",
        "feeble",
        "feed",
        "feel",
        "feisty",
        "feline",
        "felt-tip",
        "feminine",
        "feminism",
        "feminist",
        "feminize",
        "femur",
        "fence",
        "fencing",
        "fender",
        "ferment",
        "fernlike",
        "ferocious",
        "ferocity",
        "ferret",
        "ferris",
        "ferry",
        "fervor",
        "fester",
        "festival",
        "festive",
        "festivity",
        "fetal",
        "fetch",
        "fever",
        "fiber",
        "fiction",
        "fiddle",
        "fiddling",
        "fidelity",
        "fidgeting",
        "fidgety",
        "fifteen",
        "fifth",
        "fiftieth",
        "fifty",
        "figment",
        "figure",
        "figurine",
        "filing",
        "filled",
        "filler",
        "filling",
        "film",
        "filter",
        "filth",
        "filtrate",
        "finale",
        "finalist",
        "finalize",
        "finally",
        "finance",
        "financial",
        "finch",
        "fineness",
        "finer",
        "finicky",
        "finished",
        "finisher",
        "finishing",
        "finite",
        "finless",
        "finlike",
        "fiscally",
        "fit",
        "five",
        "flaccid",
        "flagman",
        "flagpole",
        "flagship",
        "flagstick",
        "flagstone",
        "flail",
        "flakily",
        "flaky",
        "flame",
        "flammable",
        "flanked",
        "flanking",
        "flannels",
        "flap",
        "flaring",
        "flashback",
        "flashbulb",
        "flashcard",
        "flashily",
        "flashing",
        "flashy",
        "flask",
        "flatbed",
        "flatfoot",
        "flatly",
        "flatness",
        "flatten",
        "flattered",
        "flatterer",
        "flattery",
        "flattop",
        "flatware",
        "flatworm",
        "flavored",
        "flavorful",
        "flavoring",
        "flaxseed",
        "fled",
        "fleshed",
        "fleshy",
        "flick",
        "flier",
        "flight",
        "flinch",
        "fling",
        "flint",
        "flip",
        "flirt",
        "float",
        "flock",
        "flogging",
        "flop",
        "floral",
        "florist",
        "floss",
        "flounder",
        "flyable",
        "flyaway",
        "flyer",
        "flying",
        "flyover",
        "flypaper",
        "foam",
        "foe",
        "fog",
        "foil",
        "folic",
        "folk",
        "follicle",
        "follow",
        "fondling",
        "fondly",
        "fondness",
        "fondue",
        "font",
        "food",
        "fool",
        "footage",
        "football",
        "footbath",
        "footboard",
        "footer",
        "footgear",
        "foothill",
        "foothold",
        "footing",
        "footless",
        "footman",
        "footnote",
        "footpad",
        "footpath",
        "footprint",
        "footrest",
        "footsie",
        "footsore",
        "footwear",
        "footwork",
        "fossil",
        "foster",
        "founder",
        "founding",
        "fountain",
        "fox",
        "foyer",
        "fraction",
        "fracture",
        "fragile",
        "fragility",
        "fragment",
        "fragrance",
        "fragrant",
        "frail",
        "frame",
        "framing",
        "frantic",
        "fraternal",
        "frayed",
        "fraying",
        "frays",
        "freckled",
        "freckles",
        "freebase",
        "freebee",
        "freebie",
        "freedom",
        "freefall",
        "freehand",
        "freeing",
        "freeload",
        "freely",
        "freemason",
        "freeness",
        "freestyle",
        "freeware",
        "freeway",
        "freewill",
        "freezable",
        "freezing",
        "freight",
        "french",
        "frenzied",
        "frenzy",
        "frequency",
        "frequent",
        "fresh",
        "fretful",
        "fretted",
        "friction",
        "friday",
        "fridge",
        "fried",
        "friend",
        "frighten",
        "frightful",
        "frigidity",
        "frigidly",
        "frill",
        "fringe",
        "frisbee",
        "frisk",
        "fritter",
        "frivolous",
        "frolic",
        "from",
        "front",
        "frostbite",
        "frosted",
        "frostily",
        "frosting",
        "frostlike",
        "frosty",
        "froth",
        "frown",
        "frozen",
        "fructose",
        "frugality",
        "frugally",
        "fruit",
        "frustrate",
        "frying",
        "gab",
        "gaffe",
        "gag",
        "gainfully",
        "gaining",
        "gains",
        "gala",
        "gallantly",
        "galleria",
        "gallery",
        "galley",
        "gallon",
        "gallows",
        "gallstone",
        "galore",
        "galvanize",
        "gambling",
        "game",
        "gaming",
        "gamma",
        "gander",
        "gangly",
        "gangrene",
        "gangway",
        "gap",
        "garage",
        "garbage",
        "garden",
        "gargle",
        "garland",
        "garlic",
        "garment",
        "garnet",
        "garnish",
        "garter",
        "gas",
        "gatherer",
        "gathering",
        "gating",
        "gauging",
        "gauntlet",
        "gauze",
        "gave",
        "gawk",
        "gazing",
        "gear",
        "gecko",
        "geek",
        "geiger",
        "gem",
        "gender",
        "generic",
        "generous",
        "genetics",
        "genre",
        "gentile",
        "gentleman",
        "gently",
        "gents",
        "geography",
        "geologic",
        "geologist",
        "geology",
        "geometric",
        "geometry",
        "geranium",
        "gerbil",
        "geriatric",
        "germicide",
        "germinate",
        "germless",
        "germproof",
        "gestate",
        "gestation",
        "gesture",
        "getaway",
        "getting",
        "getup",
        "giant",
        "gibberish",
        "giblet",
        "giddily",
        "giddiness",
        "giddy",
        "gift",
        "gigabyte",
        "gigahertz",
        "gigantic",
        "giggle",
        "giggling",
        "giggly",
        "gigolo",
        "gilled",
        "gills",
        "gimmick",
        "girdle",
        "giveaway",
        "given",
        "giver",
        "giving",
        "gizmo",
        "gizzard",
        "glacial",
        "glacier",
        "glade",
        "gladiator",
        "gladly",
        "glamorous",
        "glamour",
        "glance",
        "glancing",
        "glandular",
        "glare",
        "glaring",
        "glass",
        "glaucoma",
        "glazing",
        "gleaming",
        "gleeful",
        "glider",
        "gliding",
        "glimmer",
        "glimpse",
        "glisten",
        "glitch",
        "glitter",
        "glitzy",
        "gloater",
        "gloating",
        "gloomily",
        "gloomy",
        "glorified",
        "glorifier",
        "glorify",
        "glorious",
        "glory",
        "gloss",
        "glove",
        "glowing",
        "glowworm",
        "glucose",
        "glue",
        "gluten",
        "glutinous",
        "glutton",
        "gnarly",
        "gnat",
        "goal",
        "goatskin",
        "goes",
        "goggles",
        "going",
        "goldfish",
        "goldmine",
        "goldsmith",
        "golf",
        "goliath",
        "gonad",
        "gondola",
        "gone",
        "gong",
        "good",
        "gooey",
        "goofball",
        "goofiness",
        "goofy",
        "google",
        "goon",
        "gopher",
        "gore",
        "gorged",
        "gorgeous",
        "gory",
        "gosling",
        "gossip",
        "gothic",
        "gotten",
        "gout",
        "gown",
        "grab",
        "graceful",
        "graceless",
        "gracious",
        "gradation",
        "graded",
        "grader",
        "gradient",
        "grading",
        "gradually",
        "graduate",
        "graffiti",
        "grafted",
        "grafting",
        "grain",
        "granddad",
        "grandkid",
        "grandly",
        "grandma",
        "grandpa",
        "grandson",
        "granite",
        "granny",
        "granola",
        "grant",
        "granular",
        "grape",
        "graph",
        "grapple",
        "grappling",
        "grasp",
        "grass",
        "gratified",
        "gratify",
        "grating",
        "gratitude",
        "gratuity",
        "gravel",
        "graveness",
        "graves",
        "graveyard",
        "gravitate",
        "gravity",
        "gravy",
        "gray",
        "grazing",
        "greasily",
        "greedily",
        "greedless",
        "greedy",
        "green",
        "greeter",
        "greeting",
        "grew",
        "greyhound",
        "grid",
        "grief",
        "grievance",
        "grieving",
        "grievous",
        "grill",
        "grimace",
        "grimacing",
        "grime",
        "griminess",
        "grimy",
        "grinch",
        "grinning",
        "grip",
        "gristle",
        "grit",
        "groggily",
        "groggy",
        "groin",
        "groom",
        "groove",
        "grooving",
        "groovy",
        "grope",
        "ground",
        "grouped",
        "grout",
        "grove",
        "grower",
        "growing",
        "growl",
        "grub",
        "grudge",
        "grudging",
        "grueling",
        "gruffly",
        "grumble",
        "grumbling",
        "grumbly",
        "grumpily",
        "grunge",
        "grunt",
        "guacamole",
        "guidable",
        "guidance",
        "guide",
        "guiding",
        "guileless",
        "guise",
        "gulf",
        "gullible",
        "gully",
        "gulp",
        "gumball",
        "gumdrop",
        "gumminess",
        "gumming",
        "gummy",
        "gurgle",
        "gurgling",
        "guru",
        "gush",
        "gusto",
        "gusty",
        "gutless",
        "guts",
        "gutter",
        "guy",
        "guzzler",
        "gyration",
        "habitable",
        "habitant",
        "habitat",
        "habitual",
        "hacked",
        "hacker",
        "hacking",
        "hacksaw",
        "had",
        "haggler",
        "haiku",
        "half",
        "halogen",
        "halt",
        "halved",
        "halves",
        "hamburger",
        "hamlet",
        "hammock",
        "hamper",
        "hamster",
        "hamstring",
        "handbag",
        "handball",
        "handbook",
        "handbrake",
        "handcart",
        "handclap",
        "handclasp",
        "handcraft",
        "handcuff",
        "handed",
        "handful",
        "handgrip",
        "handgun",
        "handheld",
        "handiness",
        "handiwork",
        "handlebar",
        "handled",
        "handler",
        "handling",
        "handmade",
        "handoff",
        "handpick",
        "handprint",
        "handrail",
        "handsaw",
        "handset",
        "handsfree",
        "handshake",
        "handstand",
        "handwash",
        "handwork",
        "handwoven",
        "handwrite",
        "handyman",
        "hangnail",
        "hangout",
        "hangover",
        "hangup",
        "hankering",
        "hankie",
        "hanky",
        "haphazard",
        "happening",
        "happier",
        "happiest",
        "happily",
        "happiness",
        "happy",
        "harbor",
        "hardcopy",
        "hardcore",
        "hardcover",
        "harddisk",
        "hardened",
        "hardener",
        "hardening",
        "hardhat",
        "hardhead",
        "hardiness",
        "hardly",
        "hardness",
        "hardship",
        "hardware",
        "hardwired",
        "hardwood",
        "hardy",
        "harmful",
        "harmless",
        "harmonica",
        "harmonics",
        "harmonize",
        "harmony",
        "harness",
        "harpist",
        "harsh",
        "harvest",
        "hash",
        "hassle",
        "haste",
        "hastily",
        "hastiness",
        "hasty",
        "hatbox",
        "hatchback",
        "hatchery",
        "hatchet",
        "hatching",
        "hatchling",
        "hate",
        "hatless",
        "hatred",
        "haunt",
        "haven",
        "hazard",
        "hazelnut",
        "hazily",
        "haziness",
        "hazing",
        "hazy",
        "headache",
        "headband",
        "headboard",
        "headcount",
        "headdress",
        "headed",
        "header",
        "headfirst",
        "headgear",
        "heading",
        "headlamp",
        "headless",
        "headlock",
        "headphone",
        "headpiece",
        "headrest",
        "headroom",
        "headscarf",
        "headset",
        "headsman",
        "headstand",
        "headstone",
        "headway",
        "headwear",
        "heap",
        "heat",
        "heave",
        "heavily",
        "heaviness",
        "heaving",
        "hedge",
        "hedging",
        "heftiness",
        "hefty",
        "helium",
        "helmet",
        "helper",
        "helpful",
        "helping",
        "helpless",
        "helpline",
        "hemlock",
        "hemstitch",
        "hence",
        "henchman",
        "henna",
        "herald",
        "herbal",
        "herbicide",
        "herbs",
        "heritage",
        "hermit",
        "heroics",
        "heroism",
        "herring",
        "herself",
        "hertz",
        "hesitancy",
        "hesitant",
        "hesitate",
        "hexagon",
        "hexagram",
        "hubcap",
        "huddle",
        "huddling",
        "huff",
        "hug",
        "hula",
        "hulk",
        "hull",
        "human",
        "humble",
        "humbling",
        "humbly",
        "humid",
        "humiliate",
        "humility",
        "humming",
        "hummus",
        "humongous",
        "humorist",
        "humorless",
        "humorous",
        "humpback",
        "humped",
        "humvee",
        "hunchback",
        "hundredth",
        "hunger",
        "hungrily",
        "hungry",
        "hunk",
        "hunter",
        "hunting",
        "huntress",
        "huntsman",
        "hurdle",
        "hurled",
        "hurler",
        "hurling",
        "hurray",
        "hurricane",
        "hurried",
        "hurry",
        "hurt",
        "husband",
        "hush",
        "husked",
        "huskiness",
        "hut",
        "hybrid",
        "hydrant",
        "hydrated",
        "hydration",
        "hydrogen",
        "hydroxide",
        "hyperlink",
        "hypertext",
        "hyphen",
        "hypnoses",
        "hypnosis",
        "hypnotic",
        "hypnotism",
        "hypnotist",
        "hypnotize",
        "hypocrisy",
        "hypocrite",
        "ibuprofen",
        "ice",
        "iciness",
        "icing",
        "icky",
        "icon",
        "icy",
        "idealism",
        "idealist",
        "idealize",
        "ideally",
        "idealness",
        "identical",
        "identify",
        "identity",
        "ideology",
        "idiocy",
        "idiom",
        "idly",
        "igloo",
        "ignition",
        "ignore",
        "iguana",
        "illicitly",
        "illusion",
        "illusive",
        "image",
        "imaginary",
        "imagines",
        "imaging",
        "imbecile",
        "imitate",
        "imitation",
        "immature",
        "immerse",
        "immersion",
        "imminent",
        "immobile",
        "immodest",
        "immorally",
        "immortal",
        "immovable",
        "immovably",
        "immunity",
        "immunize",
        "impaired",
        "impale",
        "impart",
        "impatient",
        "impeach",
        "impeding",
        "impending",
        "imperfect",
        "imperial",
        "impish",
        "implant",
        "implement",
        "implicate",
        "implicit",
        "implode",
        "implosion",
        "implosive",
        "imply",
        "impolite",
        "important",
        "importer",
        "impose",
        "imposing",
        "impotence",
        "impotency",
        "impotent",
        "impound",
        "imprecise",
        "imprint",
        "imprison",
        "impromptu",
        "improper",
        "improve",
        "improving",
        "improvise",
        "imprudent",
        "impulse",
        "impulsive",
        "impure",
        "impurity",
        "iodine",
        "iodize",
        "ion",
        "ipad",
        "iphone",
        "ipod",
        "irate",
        "irk",
        "iron",
        "irregular",
        "irrigate",
        "irritable",
        "irritably",
        "irritant",
        "irritate",
        "islamic",
        "islamist",
        "isolated",
        "isolating",
        "isolation",
        "isotope",
        "issue",
        "issuing",
        "italicize",
        "italics",
        "item",
        "itinerary",
        "itunes",
        "ivory",
        "ivy",
        "jab",
        "jackal",
        "jacket",
        "jackknife",
        "jackpot",
        "jailbird",
        "jailbreak",
        "jailer",
        "jailhouse",
        "jalapeno",
        "jam",
        "janitor",
        "january",
        "jargon",
        "jarring",
        "jasmine",
        "jaundice",
        "jaunt",
        "java",
        "jawed",
        "jawless",
        "jawline",
        "jaws",
        "jaybird",
        "jaywalker",
        "jazz",
        "jeep",
        "jeeringly",
        "jellied",
        "jelly",
        "jersey",
        "jester",
        "jet",
        "jiffy",
        "jigsaw",
        "jimmy",
        "jingle",
        "jingling",
        "jinx",
        "jitters",
        "jittery",
        "job",
        "jockey",
        "jockstrap",
        "jogger",
        "jogging",
        "john",
        "joining",
        "jokester",
        "jokingly",
        "jolliness",
        "jolly",
        "jolt",
        "jot",
        "jovial",
        "joyfully",
        "joylessly",
        "joyous",
        "joyride",
        "joystick",
        "jubilance",
        "jubilant",
        "judge",
        "judgingly",
        "judicial",
        "judiciary",
        "judo",
        "juggle",
        "juggling",
        "jugular",
        "juice",
        "juiciness",
        "juicy",
        "jujitsu",
        "jukebox",
        "july",
        "jumble",
        "jumbo",
        "jump",
        "junction",
        "juncture",
        "june",
        "junior",
        "juniper",
        "junkie",
        "junkman",
        "junkyard",
        "jurist",
        "juror",
        "jury",
        "justice",
        "justifier",
        "justify",
        "justly",
        "justness",
        "juvenile",
        "kabob",
        "kangaroo",
        "karaoke",
        "karate",
        "karma",
        "kebab",
        "keenly",
        "keenness",
        "keep",
        "keg",
        "kelp",
        "kennel",
        "kept",
        "kerchief",
        "kerosene",
        "kettle",
        "kick",
        "kiln",
        "kilobyte",
        "kilogram",
        "kilometer",
        "kilowatt",
        "kilt",
        "kimono",
        "kindle",
        "kindling",
        "kindly",
        "kindness",
        "kindred",
        "kinetic",
        "kinfolk",
        "king",
        "kinship",
        "kinsman",
        "kinswoman",
        "kissable",
        "kisser",
        "kissing",
        "kitchen",
        "kite",
        "kitten",
        "kitty",
        "kiwi",
        "kleenex",
        "knapsack",
        "knee",
        "knelt",
        "knickers",
        "knoll",
        "koala",
        "kooky",
        "kosher",
        "krypton",
        "kudos",
        "kung",
        "labored",
        "laborer",
        "laboring",
        "laborious",
        "labrador",
        "ladder",
        "ladies",
        "ladle",
        "ladybug",
        "ladylike",
        "lagged",
        "lagging",
        "lagoon",
        "lair",
        "lake",
        "lance",
        "landed",
        "landfall",
        "landfill",
        "landing",
        "landlady",
        "landless",
        "landline",
        "landlord",
        "landmark",
        "landmass",
        "landmine",
        "landowner",
        "landscape",
        "landside",
        "landslide",
        "language",
        "lankiness",
        "lanky",
        "lantern",
        "lapdog",
        "lapel",
        "lapped",
        "lapping",
        "laptop",
        "lard",
        "large",
        "lark",
        "lash",
        "lasso",
        "last",
        "latch",
        "late",
        "lather",
        "latitude",
        "latrine",
        "latter",
        "latticed",
        "launch",
        "launder",
        "laundry",
        "laurel",
        "lavender",
        "lavish",
        "laxative",
        "lazily",
        "laziness",
        "lazy",
        "lecturer",
        "left",
        "legacy",
        "legal",
        "legend",
        "legged",
        "leggings",
        "legible",
        "legibly",
        "legislate",
        "lego",
        "legroom",
        "legume",
        "legwarmer",
        "legwork",
        "lemon",
        "lend",
        "length",
        "lens",
        "lent",
        "leotard",
        "lesser",
        "letdown",
        "lethargic",
        "lethargy",
        "letter",
        "lettuce",
        "level",
        "leverage",
        "levers",
        "levitate",
        "levitator",
        "liability",
        "liable",
        "liberty",
        "librarian",
        "library",
        "licking",
        "licorice",
        "lid",
        "life",
        "lifter",
        "lifting",
        "liftoff",
        "ligament",
        "likely",
        "likeness",
        "likewise",
        "liking",
        "lilac",
        "lilly",
        "lily",
        "limb",
        "limeade",
        "limelight",
        "limes",
        "limit",
        "limping",
        "limpness",
        "line",
        "lingo",
        "linguini",
        "linguist",
        "lining",
        "linked",
        "linoleum",
        "linseed",
        "lint",
        "lion",
        "lip",
        "liquefy",
        "liqueur",
        "liquid",
        "lisp",
        "list",
        "litigate",
        "litigator",
        "litmus",
        "litter",
        "little",
        "livable",
        "lived",
        "lively",
        "liver",
        "livestock",
        "lividly",
        "living",
        "lizard",
        "lubricant",
        "lubricate",
        "lucid",
        "luckily",
        "luckiness",
        "luckless",
        "lucrative",
        "ludicrous",
        "lugged",
        "lukewarm",
        "lullaby",
        "lumber",
        "luminance",
        "luminous",
        "lumpiness",
        "lumping",
        "lumpish",
        "lunacy",
        "lunar",
        "lunchbox",
        "luncheon",
        "lunchroom",
        "lunchtime",
        "lung",
        "lurch",
        "lure",
        "luridness",
        "lurk",
        "lushly",
        "lushness",
        "luster",
        "lustfully",
        "lustily",
        "lustiness",
        "lustrous",
        "lusty",
        "luxurious",
        "luxury",
        "lying",
        "lyrically",
        "lyricism",
        "lyricist",
        "lyrics",
        "macarena",
        "macaroni",
        "macaw",
        "mace",
        "machine",
        "machinist",
        "magazine",
        "magenta",
        "maggot",
        "magical",
        "magician",
        "magma",
        "magnesium",
        "magnetic",
        "magnetism",
        "magnetize",
        "magnifier",
        "magnify",
        "magnitude",
        "magnolia",
        "mahogany",
        "maimed",
        "majestic",
        "majesty",
        "majorette",
        "majority",
        "makeover",
        "maker",
        "makeshift",
        "making",
        "malformed",
        "malt",
        "mama",
        "mammal",
        "mammary",
        "mammogram",
        "manager",
        "managing",
        "manatee",
        "mandarin",
        "mandate",
        "mandatory",
        "mandolin",
        "manger",
        "mangle",
        "mango",
        "mangy",
        "manhandle",
        "manhole",
        "manhood",
        "manhunt",
        "manicotti",
        "manicure",
        "manifesto",
        "manila",
        "mankind",
        "manlike",
        "manliness",
        "manly",
        "manmade",
        "manned",
        "mannish",
        "manor",
        "manpower",
        "mantis",
        "mantra",
        "manual",
        "many",
        "map",
        "marathon",
        "marauding",
        "marbled",
        "marbles",
        "marbling",
        "march",
        "mardi",
        "margarine",
        "margarita",
        "margin",
        "marigold",
        "marina",
        "marine",
        "marital",
        "maritime",
        "marlin",
        "marmalade",
        "maroon",
        "married",
        "marrow",
        "marry",
        "marshland",
        "marshy",
        "marsupial",
        "marvelous",
        "marxism",
        "mascot",
        "masculine",
        "mashed",
        "mashing",
        "massager",
        "masses",
        "massive",
        "mastiff",
        "matador",
        "matchbook",
        "matchbox",
        "matcher",
        "matching",
        "matchless",
        "material",
        "maternal",
        "maternity",
        "math",
        "mating",
        "matriarch",
        "matrimony",
        "matrix",
        "matron",
        "matted",
        "matter",
        "maturely",
        "maturing",
        "maturity",
        "mauve",
        "maverick",
        "maximize",
        "maximum",
        "maybe",
        "mayday",
        "mayflower",
        "moaner",
        "moaning",
        "mobile",
        "mobility",
        "mobilize",
        "mobster",
        "mocha",
        "mocker",
        "mockup",
        "modified",
        "modify",
        "modular",
        "modulator",
        "module",
        "moisten",
        "moistness",
        "moisture",
        "molar",
        "molasses",
        "mold",
        "molecular",
        "molecule",
        "molehill",
        "mollusk",
        "mom",
        "monastery",
        "monday",
        "monetary",
        "monetize",
        "moneybags",
        "moneyless",
        "moneywise",
        "mongoose",
        "mongrel",
        "monitor",
        "monkhood",
        "monogamy",
        "monogram",
        "monologue",
        "monopoly",
        "monorail",
        "monotone",
        "monotype",
        "monoxide",
        "monsieur",
        "monsoon",
        "monstrous",
        "monthly",
        "monument",
        "moocher",
        "moodiness",
        "moody",
        "mooing",
        "moonbeam",
        "mooned",
        "moonlight",
        "moonlike",
        "moonlit",
        "moonrise",
        "moonscape",
        "moonshine",
        "moonstone",
        "moonwalk",
        "mop",
        "morale",
        "morality",
        "morally",
        "morbidity",
        "morbidly",
        "morphine",
        "morphing",
        "morse",
        "mortality",
        "mortally",
        "mortician",
        "mortified",
        "mortify",
        "mortuary",
        "mosaic",
        "mossy",
        "most",
        "mothball",
        "mothproof",
        "motion",
        "motivate",
        "motivator",
        "motive",
        "motocross",
        "motor",
        "motto",
        "mountable",
        "mountain",
        "mounted",
        "mounting",
        "mourner",
        "mournful",
        "mouse",
        "mousiness",
        "moustache",
        "mousy",
        "mouth",
        "movable",
        "move",
        "movie",
        "moving",
        "mower",
        "mowing",
        "much",
        "muck",
        "mud",
        "mug",
        "mulberry",
        "mulch",
        "mule",
        "mulled",
        "mullets",
        "multiple",
        "multiply",
        "multitask",
        "multitude",
        "mumble",
        "mumbling",
        "mumbo",
        "mummified",
        "mummify",
        "mummy",
        "mumps",
        "munchkin",
        "mundane",
        "municipal",
        "muppet",
        "mural",
        "murkiness",
        "murky",
        "murmuring",
        "muscular",
        "museum",
        "mushily",
        "mushiness",
        "mushroom",
        "mushy",
        "music",
        "musket",
        "muskiness",
        "musky",
        "mustang",
        "mustard",
        "muster",
        "mustiness",
        "musty",
        "mutable",
        "mutate",
        "mutation",
        "mute",
        "mutilated",
        "mutilator",
        "mutiny",
        "mutt",
        "mutual",
        "muzzle",
        "myself",
        "myspace",
        "mystified",
        "mystify",
        "myth",
        "nacho",
        "nag",
        "nail",
        "name",
        "naming",
        "nanny",
        "nanometer",
        "nape",
        "napkin",
        "napped",
        "napping",
        "nappy",
        "narrow",
        "nastily",
        "nastiness",
        "national",
        "native",
        "nativity",
        "natural",
        "nature",
        "naturist",
        "nautical",
        "navigate",
        "navigator",
        "navy",
        "nearby",
        "nearest",
        "nearly",
        "nearness",
        "neatly",
        "neatness",
        "nebula",
        "nebulizer",
        "nectar",
        "negate",
        "negation",
        "negative",
        "neglector",
        "negligee",
        "negligent",
        "negotiate",
        "nemeses",
        "nemesis",
        "neon",
        "nephew",
        "nerd",
        "nervous",
        "nervy",
        "nest",
        "net",
        "neurology",
        "neuron",
        "neurosis",
        "neurotic",
        "neuter",
        "neutron",
        "never",
        "next",
        "nibble",
        "nickname",
        "nicotine",
        "niece",
        "nifty",
        "nimble",
        "nimbly",
        "nineteen",
        "ninetieth",
        "ninja",
        "nintendo",
        "ninth",
        "nuclear",
        "nuclei",
        "nucleus",
        "nugget",
        "nullify",
        "number",
        "numbing",
        "numbly",
        "numbness",
        "numeral",
        "numerate",
        "numerator",
        "numeric",
        "numerous",
        "nuptials",
        "nursery",
        "nursing",
        "nurture",
        "nutcase",
        "nutlike",
        "nutmeg",
        "nutrient",
        "nutshell",
        "nuttiness",
        "nutty",
        "nuzzle",
        "nylon",
        "oaf",
        "oak",
        "oasis",
        "oat",
        "obedience",
        "obedient",
        "obituary",
        "object",
        "obligate",
        "obliged",
        "oblivion",
        "oblivious",
        "oblong",
        "obnoxious",
        "oboe",
        "obscure",
        "obscurity",
        "observant",
        "observer",
        "observing",
        "obsessed",
        "obsession",
        "obsessive",
        "obsolete",
        "obstacle",
        "obstinate",
        "obstruct",
        "obtain",
        "obtrusive",
        "obtuse",
        "obvious",
        "occultist",
        "occupancy",
        "occupant",
        "occupier",
        "occupy",
        "ocean",
        "ocelot",
        "octagon",
        "octane",
        "october",
        "octopus",
        "ogle",
        "oil",
        "oink",
        "ointment",
        "okay",
        "old",
        "olive",
        "olympics",
        "omega",
        "omen",
        "ominous",
        "omission",
        "omit",
        "omnivore",
        "onboard",
        "oncoming",
        "ongoing",
        "onion",
        "online",
        "onlooker",
        "only",
        "onscreen",
        "onset",
        "onshore",
        "onslaught",
        "onstage",
        "onto",
        "onward",
        "onyx",
        "oops",
        "ooze",
        "oozy",
        "opacity",
        "opal",
        "open",
        "operable",
        "operate",
        "operating",
        "operation",
        "operative",
        "operator",
        "opium",
        "opossum",
        "opponent",
        "oppose",
        "opposing",
        "opposite",
        "oppressed",
        "oppressor",
        "opt",
        "opulently",
        "osmosis",
        "other",
        "otter",
        "ouch",
        "ought",
        "ounce",
        "outage",
        "outback",
        "outbid",
        "outboard",
        "outbound",
        "outbreak",
        "outburst",
        "outcast",
        "outclass",
        "outcome",
        "outdated",
        "outdoors",
        "outer",
        "outfield",
        "outfit",
        "outflank",
        "outgoing",
        "outgrow",
        "outhouse",
        "outing",
        "outlast",
        "outlet",
        "outline",
        "outlook",
        "outlying",
        "outmatch",
        "outmost",
        "outnumber",
        "outplayed",
        "outpost",
        "outpour",
        "output",
        "outrage",
        "outrank",
        "outreach",
        "outright",
        "outscore",
        "outsell",
        "outshine",
        "outshoot",
        "outsider",
        "outskirts",
        "outsmart",
        "outsource",
        "outspoken",
        "outtakes",
        "outthink",
        "outward",
        "outweigh",
        "outwit",
        "oval",
        "ovary",
        "oven",
        "overact",
        "overall",
        "overarch",
        "overbid",
        "overbill",
        "overbite",
        "overblown",
        "overboard",
        "overbook",
        "overbuilt",
        "overcast",
        "overcoat",
        "overcome",
        "overcook",
        "overcrowd",
        "overdraft",
        "overdrawn",
        "overdress",
        "overdrive",
        "overdue",
        "overeager",
        "overeater",
        "overexert",
        "overfed",
        "overfeed",
        "overfill",
        "overflow",
        "overfull",
        "overgrown",
        "overhand",
        "overhang",
        "overhaul",
        "overhead",
        "overhear",
        "overheat",
        "overhung",
        "overjoyed",
        "overkill",
        "overlabor",
        "overlaid",
        "overlap",
        "overlay",
        "overload",
        "overlook",
        "overlord",
        "overlying",
        "overnight",
        "overpass",
        "overpay",
        "overplant",
        "overplay",
        "overpower",
        "overprice",
        "overrate",
        "overreach",
        "overreact",
        "override",
        "overripe",
        "overrule",
        "overrun",
        "overshoot",
        "overshot",
        "oversight",
        "oversized",
        "oversleep",
        "oversold",
        "overspend",
        "overstate",
        "overstay",
        "overstep",
        "overstock",
        "overstuff",
        "oversweet",
        "overtake",
        "overthrow",
        "overtime",
        "overtly",
        "overtone",
        "overture",
        "overturn",
        "overuse",
        "overvalue",
        "overview",
        "overwrite",
        "owl",
        "oxford",
        "oxidant",
        "oxidation",
        "oxidize",
        "oxidizing",
        "oxygen",
        "oxymoron",
        "oyster",
        "ozone",
        "paced",
        "pacemaker",
        "pacific",
        "pacifier",
        "pacifism",
        "pacifist",
        "pacify",
        "padded",
        "padding",
        "paddle",
        "paddling",
        "padlock",
        "pagan",
        "pager",
        "paging",
        "pajamas",
        "palace",
        "palatable",
        "palm",
        "palpable",
        "palpitate",
        "paltry",
        "pampered",
        "pamperer",
        "pampers",
        "pamphlet",
        "panama",
        "pancake",
        "pancreas",
        "panda",
        "pandemic",
        "pang",
        "panhandle",
        "panic",
        "panning",
        "panorama",
        "panoramic",
        "panther",
        "pantomime",
        "pantry",
        "pants",
        "pantyhose",
        "paparazzi",
        "papaya",
        "paper",
        "paprika",
        "papyrus",
        "parabola",
        "parachute",
        "parade",
        "paradox",
        "paragraph",
        "parakeet",
        "paralegal",
        "paralyses",
        "paralysis",
        "paralyze",
        "paramedic",
        "parameter",
        "paramount",
        "parasail",
        "parasite",
        "parasitic",
        "parcel",
        "parched",
        "parchment",
        "pardon",
        "parish",
        "parka",
        "parking",
        "parkway",
        "parlor",
        "parmesan",
        "parole",
        "parrot",
        "parsley",
        "parsnip",
        "partake",
        "parted",
        "parting",
        "partition",
        "partly",
        "partner",
        "partridge",
        "party",
        "passable",
        "passably",
        "passage",
        "passcode",
        "passenger",
        "passerby",
        "passing",
        "passion",
        "passive",
        "passivism",
        "passover",
        "passport",
        "password",
        "pasta",
        "pasted",
        "pastel",
        "pastime",
        "pastor",
        "pastrami",
        "pasture",
        "pasty",
        "patchwork",
        "patchy",
        "paternal",
        "paternity",
        "path",
        "patience",
        "patient",
        "patio",
        "patriarch",
        "patriot",
        "patrol",
        "patronage",
        "patronize",
        "pauper",
        "pavement",
        "paver",
        "pavestone",
        "pavilion",
        "paving",
        "pawing",
        "payable",
        "payback",
        "paycheck",
        "payday",
        "payee",
        "payer",
        "paying",
        "payment",
        "payphone",
        "payroll",
        "pebble",
        "pebbly",
        "pecan",
        "pectin",
        "peculiar",
        "peddling",
        "pediatric",
        "pedicure",
        "pedigree",
        "pedometer",
        "pegboard",
        "pelican",
        "pellet",
        "pelt",
        "pelvis",
        "penalize",
        "penalty",
        "pencil",
        "pendant",
        "pending",
        "penholder",
        "penknife",
        "pennant",
        "penniless",
        "penny",
        "penpal",
        "pension",
        "pentagon",
        "pentagram",
        "pep",
        "perceive",
        "percent",
        "perch",
        "percolate",
        "perennial",
        "perfected",
        "perfectly",
        "perfume",
        "periscope",
        "perish",
        "perjurer",
        "perjury",
        "perkiness",
        "perky",
        "perm",
        "peroxide",
        "perpetual",
        "perplexed",
        "persecute",
        "persevere",
        "persuaded",
        "persuader",
        "pesky",
        "peso",
        "pessimism",
        "pessimist",
        "pester",
        "pesticide",
        "petal",
        "petite",
        "petition",
        "petri",
        "petroleum",
        "petted",
        "petticoat",
        "pettiness",
        "petty",
        "petunia",
        "phantom",
        "phobia",
        "phoenix",
        "phonebook",
        "phoney",
        "phonics",
        "phoniness",
        "phony",
        "phosphate",
        "photo",
        "phrase",
        "phrasing",
        "placard",
        "placate",
        "placidly",
        "plank",
        "planner",
        "plant",
        "plasma",
        "plaster",
        "plastic",
        "plated",
        "platform",
        "plating",
        "platinum",
        "platonic",
        "platter",
        "platypus",
        "plausible",
        "plausibly",
        "playable",
        "playback",
        "player",
        "playful",
        "playgroup",
        "playhouse",
        "playing",
        "playlist",
        "playmaker",
        "playmate",
        "playoff",
        "playpen",
        "playroom",
        "playset",
        "plaything",
        "playtime",
        "plaza",
        "pleading",
        "pleat",
        "pledge",
        "plentiful",
        "plenty",
        "plethora",
        "plexiglas",
        "pliable",
        "plod",
        "plop",
        "plot",
        "plow",
        "ploy",
        "pluck",
        "plug",
        "plunder",
        "plunging",
        "plural",
        "plus",
        "plutonium",
        "plywood",
        "poach",
        "pod",
        "poem",
        "poet",
        "pogo",
        "pointed",
        "pointer",
        "pointing",
        "pointless",
        "pointy",
        "poise",
        "poison",
        "poker",
        "poking",
        "polar",
        "police",
        "policy",
        "polio",
        "polish",
        "politely",
        "polka",
        "polo",
        "polyester",
        "polygon",
        "polygraph",
        "polymer",
        "poncho",
        "pond",
        "pony",
        "popcorn",
        "pope",
        "poplar",
        "popper",
        "poppy",
        "popsicle",
        "populace",
        "popular",
        "populate",
        "porcupine",
        "pork",
        "porous",
        "porridge",
        "portable",
        "portal",
        "portfolio",
        "porthole",
        "portion",
        "portly",
        "portside",
        "poser",
        "posh",
        "posing",
        "possible",
        "possibly",
        "possum",
        "postage",
        "postal",
        "postbox",
        "postcard",
        "posted",
        "poster",
        "posting",
        "postnasal",
        "posture",
        "postwar",
        "pouch",
        "pounce",
        "pouncing",
        "pound",
        "pouring",
        "pout",
        "powdered",
        "powdering",
        "powdery",
        "power",
        "powwow",
        "pox",
        "praising",
        "prance",
        "prancing",
        "pranker",
        "prankish",
        "prankster",
        "prayer",
        "praying",
        "preacher",
        "preaching",
        "preachy",
        "preamble",
        "precinct",
        "precise",
        "precision",
        "precook",
        "precut",
        "predator",
        "predefine",
        "predict",
        "preface",
        "prefix",
        "preflight",
        "preformed",
        "pregame",
        "pregnancy",
        "pregnant",
        "preheated",
        "prelaunch",
        "prelaw",
        "prelude",
        "premiere",
        "premises",
        "premium",
        "prenatal",
        "preoccupy",
        "preorder",
        "prepaid",
        "prepay",
        "preplan",
        "preppy",
        "preschool",
        "prescribe",
        "preseason",
        "preset",
        "preshow",
        "president",
        "presoak",
        "press",
        "presume",
        "presuming",
        "preteen",
        "pretended",
        "pretender",
        "pretense",
        "pretext",
        "pretty",
        "pretzel",
        "prevail",
        "prevalent",
        "prevent",
        "preview",
        "previous",
        "prewar",
        "prewashed",
        "prideful",
        "pried",
        "primal",
        "primarily",
        "primary",
        "primate",
        "primer",
        "primp",
        "princess",
        "print",
        "prior",
        "prism",
        "prison",
        "prissy",
        "pristine",
        "privacy",
        "private",
        "privatize",
        "prize",
        "proactive",
        "probable",
        "probably",
        "probation",
        "probe",
        "probing",
        "probiotic",
        "problem",
        "procedure",
        "process",
        "proclaim",
        "procreate",
        "procurer",
        "prodigal",
        "prodigy",
        "produce",
        "product",
        "profane",
        "profanity",
        "professed",
        "professor",
        "profile",
        "profound",
        "profusely",
        "progeny",
        "prognosis",
        "program",
        "progress",
        "projector",
        "prologue",
        "prolonged",
        "promenade",
        "prominent",
        "promoter",
        "promotion",
        "prompter",
        "promptly",
        "prone",
        "prong",
        "pronounce",
        "pronto",
        "proofing",
        "proofread",
        "proofs",
        "propeller",
        "properly",
        "property",
        "proponent",
        "proposal",
        "propose",
        "props",
        "prorate",
        "protector",
        "protegee",
        "proton",
        "prototype",
        "protozoan",
        "protract",
        "protrude",
        "proud",
        "provable",
        "proved",
        "proven",
        "provided",
        "provider",
        "providing",
        "province",
        "proving",
        "provoke",
        "provoking",
        "provolone",
        "prowess",
        "prowler",
        "prowling",
        "proximity",
        "proxy",
        "prozac",
        "prude",
        "prudishly",
        "prune",
        "pruning",
        "pry",
        "psychic",
        "public",
        "publisher",
        "pucker",
        "pueblo",
        "pug",
        "pull",
        "pulmonary",
        "pulp",
        "pulsate",
        "pulse",
        "pulverize",
        "puma",
        "pumice",
        "pummel",
        "punch",
        "punctual",
        "punctuate",
        "punctured",
        "pungent",
        "punisher",
        "punk",
        "pupil",
        "puppet",
        "puppy",
        "purchase",
        "pureblood",
        "purebred",
        "purely",
        "pureness",
        "purgatory",
        "purge",
        "purging",
        "purifier",
        "purify",
        "purist",
        "puritan",
        "purity",
        "purple",
        "purplish",
        "purposely",
        "purr",
        "purse",
        "pursuable",
        "pursuant",
        "pursuit",
        "purveyor",
        "pushcart",
        "pushchair",
        "pusher",
        "pushiness",
        "pushing",
        "pushover",
        "pushpin",
        "pushup",
        "pushy",
        "putdown",
        "putt",
        "puzzle",
        "puzzling",
        "pyramid",
        "pyromania",
        "python",
        "quack",
        "quadrant",
        "quail",
        "quaintly",
        "quake",
        "quaking",
        "qualified",
        "qualifier",
        "qualify",
        "quality",
        "qualm",
        "quantum",
        "quarrel",
        "quarry",
        "quartered",
        "quarterly",
        "quarters",
        "quartet",
        "quench",
        "query",
        "quicken",
        "quickly",
        "quickness",
        "quicksand",
        "quickstep",
        "quiet",
        "quill",
        "quilt",
        "quintet",
        "quintuple",
        "quirk",
        "quit",
        "quiver",
        "quizzical",
        "quotable",
        "quotation",
        "quote",
        "rabid",
        "race",
        "racing",
        "racism",
        "rack",
        "racoon",
        "radar",
        "radial",
        "radiance",
        "radiantly",
        "radiated",
        "radiation",
        "radiator",
        "radio",
        "radish",
        "raffle",
        "raft",
        "rage",
        "ragged",
        "raging",
        "ragweed",
        "raider",
        "railcar",
        "railing",
        "railroad",
        "railway",
        "raisin",
        "rake",
        "raking",
        "rally",
        "ramble",
        "rambling",
        "ramp",
        "ramrod",
        "ranch",
        "rancidity",
        "random",
        "ranged",
        "ranger",
        "ranging",
        "ranked",
        "ranking",
        "ransack",
        "ranting",
        "rants",
        "rare",
        "rarity",
        "rascal",
        "rash",
        "rasping",
        "ravage",
        "raven",
        "ravine",
        "raving",
        "ravioli",
        "ravishing",
        "reabsorb",
        "reach",
        "reacquire",
        "reaction",
        "reactive",
        "reactor",
        "reaffirm",
        "ream",
        "reanalyze",
        "reappear",
        "reapply",
        "reappoint",
        "reapprove",
        "rearrange",
        "rearview",
        "reason",
        "reassign",
        "reassure",
        "reattach",
        "reawake",
        "rebalance",
        "rebate",
        "rebel",
        "rebirth",
        "reboot",
        "reborn",
        "rebound",
        "rebuff",
        "rebuild",
        "rebuilt",
        "reburial",
        "rebuttal",
        "recall",
        "recant",
        "recapture",
        "recast",
        "recede",
        "recent",
        "recess",
        "recharger",
        "recipient",
        "recital",
        "recite",
        "reckless",
        "reclaim",
        "recliner",
        "reclining",
        "recluse",
        "reclusive",
        "recognize",
        "recoil",
        "recollect",
        "recolor",
        "reconcile",
        "reconfirm",
        "reconvene",
        "recopy",
        "record",
        "recount",
        "recoup",
        "recovery",
        "recreate",
        "rectal",
        "rectangle",
        "rectified",
        "rectify",
        "recycled",
        "recycler",
        "recycling",
        "reemerge",
        "reenact",
        "reenter",
        "reentry",
        "reexamine",
        "referable",
        "referee",
        "reference",
        "refill",
        "refinance",
        "refined",
        "refinery",
        "refining",
        "refinish",
        "reflected",
        "reflector",
        "reflex",
        "reflux",
        "refocus",
        "refold",
        "reforest",
        "reformat",
        "reformed",
        "reformer",
        "reformist",
        "refract",
        "refrain",
        "refreeze",
        "refresh",
        "refried",
        "refueling",
        "refund",
        "refurbish",
        "refurnish",
        "refusal",
        "refuse",
        "refusing",
        "refutable",
        "refute",
        "regain",
        "regalia",
        "regally",
        "reggae",
        "regime",
        "region",
        "register",
        "registrar",
        "registry",
        "regress",
        "regretful",
        "regroup",
        "regular",
        "regulate",
        "regulator",
        "rehab",
        "reheat",
        "rehire",
        "rehydrate",
        "reimburse",
        "reissue",
        "reiterate",
        "rejoice",
        "rejoicing",
        "rejoin",
        "rekindle",
        "relapse",
        "relapsing",
        "relatable",
        "related",
        "relation",
        "relative",
        "relax",
        "relay",
        "relearn",
        "release",
        "relenting",
        "reliable",
        "reliably",
        "reliance",
        "reliant",
        "relic",
        "relieve",
        "relieving",
        "relight",
        "relish",
        "relive",
        "reload",
        "relocate",
        "relock",
        "reluctant",
        "rely",
        "remake",
        "remark",
        "remarry",
        "rematch",
        "remedial",
        "remedy",
        "remember",
        "reminder",
        "remindful",
        "remission",
        "remix",
        "remnant",
        "remodeler",
        "remold",
        "remorse",
        "remote",
        "removable",
        "removal",
        "removed",
        "remover",
        "removing",
        "rename",
        "renderer",
        "rendering",
        "rendition",
        "renegade",
        "renewable",
        "renewably",
        "renewal",
        "renewed",
        "renounce",
        "renovate",
        "renovator",
        "rentable",
        "rental",
        "rented",
        "renter",
        "reoccupy",
        "reoccur",
        "reopen",
        "reorder",
        "repackage",
        "repacking",
        "repaint",
        "repair",
        "repave",
        "repaying",
        "repayment",
        "repeal",
        "repeated",
        "repeater",
        "repent",
        "rephrase",
        "replace",
        "replay",
        "replica",
        "reply",
        "reporter",
        "repose",
        "repossess",
        "repost",
        "repressed",
        "reprimand",
        "reprint",
        "reprise",
        "reproach",
        "reprocess",
        "reproduce",
        "reprogram",
        "reps",
        "reptile",
        "reptilian",
        "repugnant",
        "repulsion",
        "repulsive",
        "repurpose",
        "reputable",
        "reputably",
        "request",
        "require",
        "requisite",
        "reroute",
        "rerun",
        "resale",
        "resample",
        "rescuer",
        "reseal",
        "research",
        "reselect",
        "reseller",
        "resemble",
        "resend",
        "resent",
        "reset",
        "reshape",
        "reshoot",
        "reshuffle",
        "residence",
        "residency",
        "resident",
        "residual",
        "residue",
        "resigned",
        "resilient",
        "resistant",
        "resisting",
        "resize",
        "resolute",
        "resolved",
        "resonant",
        "resonate",
        "resort",
        "resource",
        "respect",
        "resubmit",
        "result",
        "resume",
        "resupply",
        "resurface",
        "resurrect",
        "retail",
        "retainer",
        "retaining",
        "retake",
        "retaliate",
        "retention",
        "rethink",
        "retinal",
        "retired",
        "retiree",
        "retiring",
        "retold",
        "retool",
        "retorted",
        "retouch",
        "retrace",
        "retract",
        "retrain",
        "retread",
        "retreat",
        "retrial",
        "retrieval",
        "retriever",
        "retry",
        "return",
        "retying",
        "retype",
        "reunion",
        "reunite",
        "reusable",
        "reuse",
        "reveal",
        "reveler",
        "revenge",
        "revenue",
        "reverb",
        "revered",
        "reverence",
        "reverend",
        "reversal",
        "reverse",
        "reversing",
        "reversion",
        "revert",
        "revisable",
        "revise",
        "revision",
        "revisit",
        "revivable",
        "revival",
        "reviver",
        "reviving",
        "revocable",
        "revoke",
        "revolt",
        "revolver",
        "revolving",
        "reward",
        "rewash",
        "rewind",
        "rewire",
        "reword",
        "rework",
        "rewrap",
        "rewrite",
        "rhyme",
        "ribbon",
        "ribcage",
        "rice",
        "riches",
        "richly",
        "richness",
        "rickety",
        "ricotta",
        "riddance",
        "ridden",
        "ride",
        "riding",
        "rifling",
        "rift",
        "rigging",
        "rigid",
        "rigor",
        "rimless",
        "rimmed",
        "rind",
        "rink",
        "rinse",
        "rinsing",
        "riot",
        "ripcord",
        "ripeness",
        "ripening",
        "ripping",
        "ripple",
        "rippling",
        "riptide",
        "rise",
        "rising",
        "risk",
        "risotto",
        "ritalin",
        "ritzy",
        "rival",
        "riverbank",
        "riverbed",
        "riverboat",
        "riverside",
        "riveter",
        "riveting",
        "roamer",
        "roaming",
        "roast",
        "robbing",
        "robe",
        "robin",
        "robotics",
        "robust",
        "rockband",
        "rocker",
        "rocket",
        "rockfish",
        "rockiness",
        "rocking",
        "rocklike",
        "rockslide",
        "rockstar",
        "rocky",
        "rogue",
        "roman",
        "romp",
        "rope",
        "roping",
        "roster",
        "rosy",
        "rotten",
        "rotting",
        "rotunda",
        "roulette",
        "rounding",
        "roundish",
        "roundness",
        "roundup",
        "roundworm",
        "routine",
        "routing",
        "rover",
        "roving",
        "royal",
        "rubbed",
        "rubber",
        "rubbing",
        "rubble",
        "rubdown",
        "ruby",
        "ruckus",
        "rudder",
        "rug",
        "ruined",
        "rule",
        "rumble",
        "rumbling",
        "rummage",
        "rumor",
        "runaround",
        "rundown",
        "runner",
        "running",
        "runny",
        "runt",
        "runway",
        "rupture",
        "rural",
        "ruse",
        "rush",
        "rust",
        "rut",
        "sabbath",
        "sabotage",
        "sacrament",
        "sacred",
        "sacrifice",
        "sadden",
        "saddlebag",
        "saddled",
        "saddling",
        "sadly",
        "sadness",
        "safari",
        "safeguard",
        "safehouse",
        "safely",
        "safeness",
        "saffron",
        "saga",
        "sage",
        "sagging",
        "saggy",
        "said",
        "saint",
        "sake",
        "salad",
        "salami",
        "salaried",
        "salary",
        "saline",
        "salon",
        "saloon",
        "salsa",
        "salt",
        "salutary",
        "salute",
        "salvage",
        "salvaging",
        "salvation",
        "same",
        "sample",
        "sampling",
        "sanction",
        "sanctity",
        "sanctuary",
        "sandal",
        "sandbag",
        "sandbank",
        "sandbar",
        "sandblast",
        "sandbox",
        "sanded",
        "sandfish",
        "sanding",
        "sandlot",
        "sandpaper",
        "sandpit",
        "sandstone",
        "sandstorm",
        "sandworm",
        "sandy",
        "sanitary",
        "sanitizer",
        "sank",
        "santa",
        "sapling",
        "sappiness",
        "sappy",
        "sarcasm",
        "sarcastic",
        "sardine",
        "sash",
        "sasquatch",
        "sassy",
        "satchel",
        "satiable",
        "satin",
        "satirical",
        "satisfied",
        "satisfy",
        "saturate",
        "saturday",
        "sauciness",
        "saucy",
        "sauna",
        "savage",
        "savanna",
        "saved",
        "savings",
        "savior",
        "savor",
        "saxophone",
        "say",
        "scabbed",
        "scabby",
        "scalded",
        "scalding",
        "scale",
        "scaling",
        "scallion",
        "scallop",
        "scalping",
        "scam",
        "scandal",
        "scanner",
        "scanning",
        "scant",
        "scapegoat",
        "scarce",
        "scarcity",
        "scarecrow",
        "scared",
        "scarf",
        "scarily",
        "scariness",
        "scarring",
        "scary",
        "scavenger",
        "scenic",
        "schedule",
        "schematic",
        "scheme",
        "scheming",
        "schilling",
        "schnapps",
        "scholar",
        "science",
        "scientist",
        "scion",
        "scoff",
        "scolding",
        "scone",
        "scoop",
        "scooter",
        "scope",
        "scorch",
        "scorebook",
        "scorecard",
        "scored",
        "scoreless",
        "scorer",
        "scoring",
        "scorn",
        "scorpion",
        "scotch",
        "scoundrel",
        "scoured",
        "scouring",
        "scouting",
        "scouts",
        "scowling",
        "scrabble",
        "scraggly",
        "scrambled",
        "scrambler",
        "scrap",
        "scratch",
        "scrawny",
        "screen",
        "scribble",
        "scribe",
        "scribing",
        "scrimmage",
        "script",
        "scroll",
        "scrooge",
        "scrounger",
        "scrubbed",
        "scrubber",
        "scruffy",
        "scrunch",
        "scrutiny",
        "scuba",
        "scuff",
        "sculptor",
        "sculpture",
        "scurvy",
        "scuttle",
        "secluded",
        "secluding",
        "seclusion",
        "second",
        "secrecy",
        "secret",
        "sectional",
        "sector",
        "secular",
        "securely",
        "security",
        "sedan",
        "sedate",
        "sedation",
        "sedative",
        "sediment",
        "seduce",
        "seducing",
        "segment",
        "seismic",
        "seizing",
        "seldom",
        "selected",
        "selection",
        "selective",
        "selector",
        "self",
        "seltzer",
        "semantic",
        "semester",
        "semicolon",
        "semifinal",
        "seminar",
        "semisoft",
        "semisweet",
        "senate",
        "senator",
        "send",
        "senior",
        "senorita",
        "sensation",
        "sensitive",
        "sensitize",
        "sensually",
        "sensuous",
        "sepia",
        "september",
        "septic",
        "septum",
        "sequel",
        "sequence",
        "sequester",
        "series",
        "sermon",
        "serotonin",
        "serpent",
        "serrated",
        "serve",
        "service",
        "serving",
        "sesame",
        "sessions",
        "setback",
        "setting",
        "settle",
        "settling",
        "setup",
        "sevenfold",
        "seventeen",
        "seventh",
        "seventy",
        "severity",
        "shabby",
        "shack",
        "shaded",
        "shadily",
        "shadiness",
        "shading",
        "shadow",
        "shady",
        "shaft",
        "shakable",
        "shakily",
        "shakiness",
        "shaking",
        "shaky",
        "shale",
        "shallot",
        "shallow",
        "shame",
        "shampoo",
        "shamrock",
        "shank",
        "shanty",
        "shape",
        "shaping",
        "share",
        "sharpener",
        "sharper",
        "sharpie",
        "sharply",
        "sharpness",
        "shawl",
        "sheath",
        "shed",
        "sheep",
        "sheet",
        "shelf",
        "shell",
        "shelter",
        "shelve",
        "shelving",
        "sherry",
        "shield",
        "shifter",
        "shifting",
        "shiftless",
        "shifty",
        "shimmer",
        "shimmy",
        "shindig",
        "shine",
        "shingle",
        "shininess",
        "shining",
        "shiny",
        "ship",
        "shirt",
        "shivering",
        "shock",
        "shone",
        "shoplift",
        "shopper",
        "shopping",
        "shoptalk",
        "shore",
        "shortage",
        "shortcake",
        "shortcut",
        "shorten",
        "shorter",
        "shorthand",
        "shortlist",
        "shortly",
        "shortness",
        "shorts",
        "shortwave",
        "shorty",
        "shout",
        "shove",
        "showbiz",
        "showcase",
        "showdown",
        "shower",
        "showgirl",
        "showing",
        "showman",
        "shown",
        "showoff",
        "showpiece",
        "showplace",
        "showroom",
        "showy",
        "shrank",
        "shrapnel",
        "shredder",
        "shredding",
        "shrewdly",
        "shriek",
        "shrill",
        "shrimp",
        "shrine",
        "shrink",
        "shrivel",
        "shrouded",
        "shrubbery",
        "shrubs",
        "shrug",
        "shrunk",
        "shucking",
        "shudder",
        "shuffle",
        "shuffling",
        "shun",
        "shush",
        "shut",
        "shy",
        "siamese",
        "siberian",
        "sibling",
        "siding",
        "sierra",
        "siesta",
        "sift",
        "sighing",
        "silenced",
        "silencer",
        "silent",
        "silica",
        "silicon",
        "silk",
        "silliness",
        "silly",
        "silo",
        "silt",
        "silver",
        "similarly",
        "simile",
        "simmering",
        "simple",
        "simplify",
        "simply",
        "sincere",
        "sincerity",
        "singer",
        "singing",
        "single",
        "singular",
        "sinister",
        "sinless",
        "sinner",
        "sinuous",
        "sip",
        "siren",
        "sister",
        "sitcom",
        "sitter",
        "sitting",
        "situated",
        "situation",
        "sixfold",
        "sixteen",
        "sixth",
        "sixties",
        "sixtieth",
        "sixtyfold",
        "sizable",
        "sizably",
        "size",
        "sizing",
        "sizzle",
        "sizzling",
        "skater",
        "skating",
        "skedaddle",
        "skeletal",
        "skeleton",
        "skeptic",
        "sketch",
        "skewed",
        "skewer",
        "skid",
        "skied",
        "skier",
        "skies",
        "skiing",
        "skilled",
        "skillet",
        "skillful",
        "skimmed",
        "skimmer",
        "skimming",
        "skimpily",
        "skincare",
        "skinhead",
        "skinless",
        "skinning",
        "skinny",
        "skintight",
        "skipper",
        "skipping",
        "skirmish",
        "skirt",
        "skittle",
        "skydiver",
        "skylight",
        "skyline",
        "skype",
        "skyrocket",
        "skyward",
        "slab",
        "slacked",
        "slacker",
        "slacking",
        "slackness",
        "slacks",
        "slain",
        "slam",
        "slander",
        "slang",
        "slapping",
        "slapstick",
        "slashed",
        "slashing",
        "slate",
        "slather",
        "slaw",
        "sled",
        "sleek",
        "sleep",
        "sleet",
        "sleeve",
        "slept",
        "sliceable",
        "sliced",
        "slicer",
        "slicing",
        "slick",
        "slider",
        "slideshow",
        "sliding",
        "slighted",
        "slighting",
        "slightly",
        "slimness",
        "slimy",
        "slinging",
        "slingshot",
        "slinky",
        "slip",
        "slit",
        "sliver",
        "slobbery",
        "slogan",
        "sloped",
        "sloping",
        "sloppily",
        "sloppy",
        "slot",
        "slouching",
        "slouchy",
        "sludge",
        "slug",
        "slum",
        "slurp",
        "slush",
        "sly",
        "small",
        "smartly",
        "smartness",
        "smasher",
        "smashing",
        "smashup",
        "smell",
        "smelting",
        "smile",
        "smilingly",
        "smirk",
        "smite",
        "smith",
        "smitten",
        "smock",
        "smog",
        "smoked",
        "smokeless",
        "smokiness",
        "smoking",
        "smoky",
        "smolder",
        "smooth",
        "smother",
        "smudge",
        "smudgy",
        "smuggler",
        "smuggling",
        "smugly",
        "smugness",
        "snack",
        "snagged",
        "snaking",
        "snap",
        "snare",
        "snarl",
        "snazzy",
        "sneak",
        "sneer",
        "sneeze",
        "sneezing",
        "snide",
        "sniff",
        "snippet",
        "snipping",
        "snitch",
        "snooper",
        "snooze",
        "snore",
        "snoring",
        "snorkel",
        "snort",
        "snout",
        "snowbird",
        "snowboard",
        "snowbound",
        "snowcap",
        "snowdrift",
        "snowdrop",
        "snowfall",
        "snowfield",
        "snowflake",
        "snowiness",
        "snowless",
        "snowman",
        "snowplow",
        "snowshoe",
        "snowstorm",
        "snowsuit",
        "snowy",
        "snub",
        "snuff",
        "snuggle",
        "snugly",
        "snugness",
        "speak",
        "spearfish",
        "spearhead",
        "spearman",
        "spearmint",
        "species",
        "specimen",
        "specked",
        "speckled",
        "specks",
        "spectacle",
        "spectator",
        "spectrum",
        "speculate",
        "speech",
        "speed",
        "spellbind",
        "speller",
        "spelling",
        "spendable",
        "spender",
        "spending",
        "spent",
        "spew",
        "sphere",
        "spherical",
        "sphinx",
        "spider",
        "spied",
        "spiffy",
        "spill",
        "spilt",
        "spinach",
        "spinal",
        "spindle",
        "spinner",
        "spinning",
        "spinout",
        "spinster",
        "spiny",
        "spiral",
        "spirited",
        "spiritism",
        "spirits",
        "spiritual",
        "splashed",
        "splashing",
        "splashy",
        "splatter",
        "spleen",
        "splendid",
        "splendor",
        "splice",
        "splicing",
        "splinter",
        "splotchy",
        "splurge",
        "spoilage",
        "spoiled",
        "spoiler",
        "spoiling",
        "spoils",
        "spoken",
        "spokesman",
        "sponge",
        "spongy",
        "sponsor",
        "spoof",
        "spookily",
        "spooky",
        "spool",
        "spoon",
        "spore",
        "sporting",
        "sports",
        "sporty",
        "spotless",
        "spotlight",
        "spotted",
        "spotter",
        "spotting",
        "spotty",
        "spousal",
        "spouse",
        "spout",
        "sprain",
        "sprang",
        "sprawl",
        "spray",
        "spree",
        "sprig",
        "spring",
        "sprinkled",
        "sprinkler",
        "sprint",
        "sprite",
        "sprout",
        "spruce",
        "sprung",
        "spry",
        "spud",
        "spur",
        "sputter",
        "spyglass",
        "squabble",
        "squad",
        "squall",
        "squander",
        "squash",
        "squatted",
        "squatter",
        "squatting",
        "squeak",
        "squealer",
        "squealing",
        "squeamish",
        "squeegee",
        "squeeze",
        "squeezing",
        "squid",
        "squiggle",
        "squiggly",
        "squint",
        "squire",
        "squirt",
        "squishier",
        "squishy",
        "stability",
        "stabilize",
        "stable",
        "stack",
        "stadium",
        "staff",
        "stage",
        "staging",
        "stagnant",
        "stagnate",
        "stainable",
        "stained",
        "staining",
        "stainless",
        "stalemate",
        "staleness",
        "stalling",
        "stallion",
        "stamina",
        "stammer",
        "stamp",
        "stand",
        "stank",
        "staple",
        "stapling",
        "starboard",
        "starch",
        "stardom",
        "stardust",
        "starfish",
        "stargazer",
        "staring",
        "stark",
        "starless",
        "starlet",
        "starlight",
        "starlit",
        "starring",
        "starry",
        "starship",
        "starter",
        "starting",
        "startle",
        "startling",
        "startup",
        "starved",
        "starving",
        "stash",
        "state",
        "static",
        "statistic",
        "statue",
        "stature",
        "status",
        "statute",
        "statutory",
        "staunch",
        "stays",
        "steadfast",
        "steadier",
        "steadily",
        "steadying",
        "steam",
        "steed",
        "steep",
        "steerable",
        "steering",
        "steersman",
        "stegosaur",
        "stellar",
        "stem",
        "stench",
        "stencil",
        "step",
        "stereo",
        "sterile",
        "sterility",
        "sterilize",
        "sterling",
        "sternness",
        "sternum",
        "stew",
        "stick",
        "stiffen",
        "stiffly",
        "stiffness",
        "stifle",
        "stifling",
        "stillness",
        "stilt",
        "stimulant",
        "stimulate",
        "stimuli",
        "stimulus",
        "stinger",
        "stingily",
        "stinging",
        "stingray",
        "stingy",
        "stinking",
        "stinky",
        "stipend",
        "stipulate",
        "stir",
        "stitch",
        "stock",
        "stoic",
        "stoke",
        "stole",
        "stomp",
        "stonewall",
        "stoneware",
        "stonework",
        "stoning",
        "stony",
        "stood",
        "stooge",
        "stool",
        "stoop",
        "stoplight",
        "stoppable",
        "stoppage",
        "stopped",
        "stopper",
        "stopping",
        "stopwatch",
        "storable",
        "storage",
        "storeroom",
        "storewide",
        "storm",
        "stout",
        "stove",
        "stowaway",
        "stowing",
        "straddle",
        "straggler",
        "strained",
        "strainer",
        "straining",
        "strangely",
        "stranger",
        "strangle",
        "strategic",
        "strategy",
        "stratus",
        "straw",
        "stray",
        "streak",
        "stream",
        "street",
        "strength",
        "strenuous",
        "strep",
        "stress",
        "stretch",
        "strewn",
        "stricken",
        "strict",
        "stride",
        "strife",
        "strike",
        "striking",
        "strive",
        "striving",
        "strobe",
        "strode",
        "stroller",
        "strongbox",
        "strongly",
        "strongman",
        "struck",
        "structure",
        "strudel",
        "struggle",
        "strum",
        "strung",
        "strut",
        "stubbed",
        "stubble",
        "stubbly",
        "stubborn",
        "stucco",
        "stuck",
        "student",
        "studied",
        "studio",
        "study",
        "stuffed",
        "stuffing",
        "stuffy",
        "stumble",
        "stumbling",
        "stump",
        "stung",
        "stunned",
        "stunner",
        "stunning",
        "stunt",
        "stupor",
        "sturdily",
        "sturdy",
        "styling",
        "stylishly",
        "stylist",
        "stylized",
        "stylus",
        "suave",
        "subarctic",
        "subatomic",
        "subdivide",
        "subdued",
        "subduing",
        "subfloor",
        "subgroup",
        "subheader",
        "subject",
        "sublease",
        "sublet",
        "sublevel",
        "sublime",
        "submarine",
        "submerge",
        "submersed",
        "submitter",
        "subpanel",
        "subpar",
        "subplot",
        "subprime",
        "subscribe",
        "subscript",
        "subsector",
        "subside",
        "subsiding",
        "subsidize",
        "subsidy",
        "subsoil",
        "subsonic",
        "substance",
        "subsystem",
        "subtext",
        "subtitle",
        "subtly",
        "subtotal",
        "subtract",
        "subtype",
        "suburb",
        "subway",
        "subwoofer",
        "subzero",
        "succulent",
        "such",
        "suction",
        "sudden",
        "sudoku",
        "suds",
        "sufferer",
        "suffering",
        "suffice",
        "suffix",
        "suffocate",
        "suffrage",
        "sugar",
        "suggest",
        "suing",
        "suitable",
        "suitably",
        "suitcase",
        "suitor",
        "sulfate",
        "sulfide",
        "sulfite",
        "sulfur",
        "sulk",
        "sullen",
        "sulphate",
        "sulphuric",
        "sultry",
        "superbowl",
        "superglue",
        "superhero",
        "superior",
        "superjet",
        "superman",
        "supermom",
        "supernova",
        "supervise",
        "supper",
        "supplier",
        "supply",
        "support",
        "supremacy",
        "supreme",
        "surcharge",
        "surely",
        "sureness",
        "surface",
        "surfacing",
        "surfboard",
        "surfer",
        "surgery",
        "surgical",
        "surging",
        "surname",
        "surpass",
        "surplus",
        "surprise",
        "surreal",
        "surrender",
        "surrogate",
        "surround",
        "survey",
        "survival",
        "survive",
        "surviving",
        "survivor",
        "sushi",
        "suspect",
        "suspend",
        "suspense",
        "sustained",
        "sustainer",
        "swab",
        "swaddling",
        "swagger",
        "swampland",
        "swan",
        "swapping",
        "swarm",
        "sway",
        "swear",
        "sweat",
        "sweep",
        "swell",
        "swept",
        "swerve",
        "swifter",
        "swiftly",
        "swiftness",
        "swimmable",
        "swimmer",
        "swimming",
        "swimsuit",
        "swimwear",
        "swinger",
        "swinging",
        "swipe",
        "swirl",
        "switch",
        "swivel",
        "swizzle",
        "swooned",
        "swoop",
        "swoosh",
        "swore",
        "sworn",
        "swung",
        "sycamore",
        "sympathy",
        "symphonic",
        "symphony",
        "symptom",
        "synapse",
        "syndrome",
        "synergy",
        "synopses",
        "synopsis",
        "synthesis",
        "synthetic",
        "syrup",
        "system",
        "t-shirt",
        "tabasco",
        "tabby",
        "tableful",
        "tables",
        "tablet",
        "tableware",
        "tabloid",
        "tackiness",
        "tacking",
        "tackle",
        "tackling",
        "tacky",
        "taco",
        "tactful",
        "tactical",
        "tactics",
        "tactile",
        "tactless",
        "tadpole",
        "taekwondo",
        "tag",
        "tainted",
        "take",
        "taking",
        "talcum",
        "talisman",
        "tall",
        "talon",
        "tamale",
        "tameness",
        "tamer",
        "tamper",
        "tank",
        "tanned",
        "tannery",
        "tanning",
        "tantrum",
        "tapeless",
        "tapered",
        "tapering",
        "tapestry",
        "tapioca",
        "tapping",
        "taps",
        "tarantula",
        "target",
        "tarmac",
        "tarnish",
        "tarot",
        "tartar",
        "tartly",
        "tartness",
        "task",
        "tassel",
        "taste",
        "tastiness",
        "tasting",
        "tasty",
        "tattered",
        "tattle",
        "tattling",
        "tattoo",
        "taunt",
        "tavern",
        "thank",
        "that",
        "thaw",
        "theater",
        "theatrics",
        "thee",
        "theft",
        "theme",
        "theology",
        "theorize",
        "thermal",
        "thermos",
        "thesaurus",
        "these",
        "thesis",
        "thespian",
        "thicken",
        "thicket",
        "thickness",
        "thieving",
        "thievish",
        "thigh",
        "thimble",
        "thing",
        "think",
        "thinly",
        "thinner",
        "thinness",
        "thinning",
        "thirstily",
        "thirsting",
        "thirsty",
        "thirteen",
        "thirty",
        "thong",
        "thorn",
        "those",
        "thousand",
        "thrash",
        "thread",
        "threaten",
        "threefold",
        "thrift",
        "thrill",
        "thrive",
        "thriving",
        "throat",
        "throbbing",
        "throng",
        "throttle",
        "throwaway",
        "throwback",
        "thrower",
        "throwing",
        "thud",
        "thumb",
        "thumping",
        "thursday",
        "thus",
        "thwarting",
        "thyself",
        "tiara",
        "tibia",
        "tidal",
        "tidbit",
        "tidiness",
        "tidings",
        "tidy",
        "tiger",
        "tighten",
        "tightly",
        "tightness",
        "tightrope",
        "tightwad",
        "tigress",
        "tile",
        "tiling",
        "till",
        "tilt",
        "timid",
        "timing",
        "timothy",
        "tinderbox",
        "tinfoil",
        "tingle",
        "tingling",
        "tingly",
        "tinker",
        "tinkling",
        "tinsel",
        "tinsmith",
        "tint",
        "tinwork",
        "tiny",
        "tipoff",
        "tipped",
        "tipper",
        "tipping",
        "tiptoeing",
        "tiptop",
        "tiring",
        "tissue",
        "trace",
        "tracing",
        "track",
        "traction",
        "tractor",
        "trade",
        "trading",
        "tradition",
        "traffic",
        "tragedy",
        "trailing",
        "trailside",
        "train",
        "traitor",
        "trance",
        "tranquil",
        "transfer",
        "transform",
        "translate",
        "transpire",
        "transport",
        "transpose",
        "trapdoor",
        "trapeze",
        "trapezoid",
        "trapped",
        "trapper",
        "trapping",
        "traps",
        "trash",
        "travel",
        "traverse",
        "travesty",
        "tray",
        "treachery",
        "treading",
        "treadmill",
        "treason",
        "treat",
        "treble",
        "tree",
        "trekker",
        "tremble",
        "trembling",
        "tremor",
        "trench",
        "trend",
        "trespass",
        "triage",
        "trial",
        "triangle",
        "tribesman",
        "tribunal",
        "tribune",
        "tributary",
        "tribute",
        "triceps",
        "trickery",
        "trickily",
        "tricking",
        "trickle",
        "trickster",
        "tricky",
        "tricolor",
        "tricycle",
        "trident",
        "tried",
        "trifle",
        "trifocals",
        "trillion",
        "trilogy",
        "trimester",
        "trimmer",
        "trimming",
        "trimness",
        "trinity",
        "trio",
        "tripod",
        "tripping",
        "triumph",
        "trivial",
        "trodden",
        "trolling",
        "trombone",
        "trophy",
        "tropical",
        "tropics",
        "trouble",
        "troubling",
        "trough",
        "trousers",
        "trout",
        "trowel",
        "truce",
        "truck",
        "truffle",
        "trump",
        "trunks",
        "trustable",
        "trustee",
        "trustful",
        "trusting",
        "trustless",
        "truth",
        "try",
        "tubby",
        "tubeless",
        "tubular",
        "tucking",
        "tuesday",
        "tug",
        "tuition",
        "tulip",
        "tumble",
        "tumbling",
        "tummy",
        "turban",
        "turbine",
        "turbofan",
        "turbojet",
        "turbulent",
        "turf",
        "turkey",
        "turmoil",
        "turret",
        "turtle",
        "tusk",
        "tutor",
        "tutu",
        "tux",
        "tweak",
        "tweed",
        "tweet",
        "tweezers",
        "twelve",
        "twentieth",
        "twenty",
        "twerp",
        "twice",
        "twiddle",
        "twiddling",
        "twig",
        "twilight",
        "twine",
        "twins",
        "twirl",
        "twistable",
        "twisted",
        "twister",
        "twisting",
        "twisty",
        "twitch",
        "twitter",
        "tycoon",
        "tying",
        "tyke",
        "udder",
        "ultimate",
        "ultimatum",
        "ultra",
        "umbilical",
        "umbrella",
        "umpire",
        "unabashed",
        "unable",
        "unadorned",
        "unadvised",
        "unafraid",
        "unaired",
        "unaligned",
        "unaltered",
        "unarmored",
        "unashamed",
        "unaudited",
        "unawake",
        "unaware",
        "unbaked",
        "unbalance",
        "unbeaten",
        "unbend",
        "unbent",
        "unbiased",
        "unbitten",
        "unblended",
        "unblessed",
        "unblock",
        "unbolted",
        "unbounded",
        "unboxed",
        "unbraided",
        "unbridle",
        "unbroken",
        "unbuckled",
        "unbundle",
        "unburned",
        "unbutton",
        "uncanny",
        "uncapped",
        "uncaring",
        "uncertain",
        "unchain",
        "unchanged",
        "uncharted",
        "uncheck",
        "uncivil",
        "unclad",
        "unclaimed",
        "unclamped",
        "unclasp",
        "uncle",
        "unclip",
        "uncloak",
        "unclog",
        "unclothed",
        "uncoated",
        "uncoiled",
        "uncolored",
        "uncombed",
        "uncommon",
        "uncooked",
        "uncork",
        "uncorrupt",
        "uncounted",
        "uncouple",
        "uncouth",
        "uncover",
        "uncross",
        "uncrown",
        "uncrushed",
        "uncured",
        "uncurious",
        "uncurled",
        "uncut",
        "undamaged",
        "undated",
        "undaunted",
        "undead",
        "undecided",
        "undefined",
        "underage",
        "underarm",
        "undercoat",
        "undercook",
        "undercut",
        "underdog",
        "underdone",
        "underfed",
        "underfeed",
        "underfoot",
        "undergo",
        "undergrad",
        "underhand",
        "underline",
        "underling",
        "undermine",
        "undermost",
        "underpaid",
        "underpass",
        "underpay",
        "underrate",
        "undertake",
        "undertone",
        "undertook",
        "undertow",
        "underuse",
        "underwear",
        "underwent",
        "underwire",
        "undesired",
        "undiluted",
        "undivided",
        "undocked",
        "undoing",
        "undone",
        "undrafted",
        "undress",
        "undrilled",
        "undusted",
        "undying",
        "unearned",
        "unearth",
        "unease",
        "uneasily",
        "uneasy",
        "uneatable",
        "uneaten",
        "unedited",
        "unelected",
        "unending",
        "unengaged",
        "unenvied",
        "unequal",
        "unethical",
        "uneven",
        "unexpired",
        "unexposed",
        "unfailing",
        "unfair",
        "unfasten",
        "unfazed",
        "unfeeling",
        "unfiled",
        "unfilled",
        "unfitted",
        "unfitting",
        "unfixable",
        "unfixed",
        "unflawed",
        "unfocused",
        "unfold",
        "unfounded",
        "unframed",
        "unfreeze",
        "unfrosted",
        "unfrozen",
        "unfunded",
        "unglazed",
        "ungloved",
        "unglue",
        "ungodly",
        "ungraded",
        "ungreased",
        "unguarded",
        "unguided",
        "unhappily",
        "unhappy",
        "unharmed",
        "unhealthy",
        "unheard",
        "unhearing",
        "unheated",
        "unhelpful",
        "unhidden",
        "unhinge",
        "unhitched",
        "unholy",
        "unhook",
        "unicorn",
        "unicycle",
        "unified",
        "unifier",
        "uniformed",
        "uniformly",
        "unify",
        "unimpeded",
        "uninjured",
        "uninstall",
        "uninsured",
        "uninvited",
        "union",
        "uniquely",
        "unisexual",
        "unison",
        "unissued",
        "unit",
        "universal",
        "universe",
        "unjustly",
        "unkempt",
        "unkind",
        "unknotted",
        "unknowing",
        "unknown",
        "unlaced",
        "unlatch",
        "unlawful",
        "unleaded",
        "unlearned",
        "unleash",
        "unless",
        "unleveled",
        "unlighted",
        "unlikable",
        "unlimited",
        "unlined",
        "unlinked",
        "unlisted",
        "unlit",
        "unlivable",
        "unloaded",
        "unloader",
        "unlocked",
        "unlocking",
        "unlovable",
        "unloved",
        "unlovely",
        "unloving",
        "unluckily",
        "unlucky",
        "unmade",
        "unmanaged",
        "unmanned",
        "unmapped",
        "unmarked",
        "unmasked",
        "unmasking",
        "unmatched",
        "unmindful",
        "unmixable",
        "unmixed",
        "unmolded",
        "unmoral",
        "unmovable",
        "unmoved",
        "unmoving",
        "unnamable",
        "unnamed",
        "unnatural",
        "unneeded",
        "unnerve",
        "unnerving",
        "unnoticed",
        "unopened",
        "unopposed",
        "unpack",
        "unpadded",
        "unpaid",
        "unpainted",
        "unpaired",
        "unpaved",
        "unpeeled",
        "unpicked",
        "unpiloted",
        "unpinned",
        "unplanned",
        "unplanted",
        "unpleased",
        "unpledged",
        "unplowed",
        "unplug",
        "unpopular",
        "unproven",
        "unquote",
        "unranked",
        "unrated",
        "unraveled",
        "unreached",
        "unread",
        "unreal",
        "unreeling",
        "unrefined",
        "unrelated",
        "unrented",
        "unrest",
        "unretired",
        "unrevised",
        "unrigged",
        "unripe",
        "unrivaled",
        "unroasted",
        "unrobed",
        "unroll",
        "unruffled",
        "unruly",
        "unrushed",
        "unsaddle",
        "unsafe",
        "unsaid",
        "unsalted",
        "unsaved",
        "unsavory",
        "unscathed",
        "unscented",
        "unscrew",
        "unsealed",
        "unseated",
        "unsecured",
        "unseeing",
        "unseemly",
        "unseen",
        "unselect",
        "unselfish",
        "unsent",
        "unsettled",
        "unshackle",
        "unshaken",
        "unshaved",
        "unshaven",
        "unsheathe",
        "unshipped",
        "unsightly",
        "unsigned",
        "unskilled",
        "unsliced",
        "unsmooth",
        "unsnap",
        "unsocial",
        "unsoiled",
        "unsold",
        "unsolved",
        "unsorted",
        "unspoiled",
        "unspoken",
        "unstable",
        "unstaffed",
        "unstamped",
        "unsteady",
        "unsterile",
        "unstirred",
        "unstitch",
        "unstopped",
        "unstuck",
        "unstuffed",
        "unstylish",
        "unsubtle",
        "unsubtly",
        "unsuited",
        "unsure",
        "unsworn",
        "untagged",
        "untainted",
        "untaken",
        "untamed",
        "untangled",
        "untapped",
        "untaxed",
        "unthawed",
        "unthread",
        "untidy",
        "untie",
        "until",
        "untimed",
        "untimely",
        "untitled",
        "untoasted",
        "untold",
        "untouched",
        "untracked",
        "untrained",
        "untreated",
        "untried",
        "untrimmed",
        "untrue",
        "untruth",
        "unturned",
        "untwist",
        "untying",
        "unusable",
        "unused",
        "unusual",
        "unvalued",
        "unvaried",
        "unvarying",
        "unveiled",
        "unveiling",
        "unvented",
        "unviable",
        "unvisited",
        "unvocal",
        "unwanted",
        "unwarlike",
        "unwary",
        "unwashed",
        "unwatched",
        "unweave",
        "unwed",
        "unwelcome",
        "unwell",
        "unwieldy",
        "unwilling",
        "unwind",
        "unwired",
        "unwitting",
        "unwomanly",
        "unworldly",
        "unworn",
        "unworried",
        "unworthy",
        "unwound",
        "unwoven",
        "unwrapped",
        "unwritten",
        "unzip",
        "upbeat",
        "upchuck",
        "upcoming",
        "upcountry",
        "update",
        "upfront",
        "upgrade",
        "upheaval",
        "upheld",
        "uphill",
        "uphold",
        "uplifted",
        "uplifting",
        "upload",
        "upon",
        "upper",
        "upright",
        "uprising",
        "upriver",
        "uproar",
        "uproot",
        "upscale",
        "upside",
        "upstage",
        "upstairs",
        "upstart",
        "upstate",
        "upstream",
        "upstroke",
        "upswing",
        "uptake",
        "uptight",
        "uptown",
        "upturned",
        "upward",
        "upwind",
        "uranium",
        "urban",
        "urchin",
        "urethane",
        "urgency",
        "urgent",
        "urging",
        "urologist",
        "urology",
        "usable",
        "usage",
        "useable",
        "used",
        "uselessly",
        "user",
        "usher",
        "usual",
        "utensil",
        "utility",
        "utilize",
        "utmost",
        "utopia",
        "utter",
        "vacancy",
        "vacant",
        "vacate",
        "vacation",
        "vagabond",
        "vagrancy",
        "vagrantly",
        "vaguely",
        "vagueness",
        "valiant",
        "valid",
        "valium",
        "valley",
        "valuables",
        "value",
        "vanilla",
        "vanish",
        "vanity",
        "vanquish",
        "vantage",
        "vaporizer",
        "variable",
        "variably",
        "varied",
        "variety",
        "various",
        "varmint",
        "varnish",
        "varsity",
        "varying",
        "vascular",
        "vaseline",
        "vastly",
        "vastness",
        "veal",
        "vegan",
        "veggie",
        "vehicular",
        "velcro",
        "velocity",
        "velvet",
        "vendetta",
        "vending",
        "vendor",
        "veneering",
        "vengeful",
        "venomous",
        "ventricle",
        "venture",
        "venue",
        "venus",
        "verbalize",
        "verbally",
        "verbose",
        "verdict",
        "verify",
        "verse",
        "version",
        "versus",
        "vertebrae",
        "vertical",
        "vertigo",
        "very",
        "vessel",
        "vest",
        "veteran",
        "veto",
        "vexingly",
        "viability",
        "viable",
        "vibes",
        "vice",
        "vicinity",
        "victory",
        "video",
        "viewable",
        "viewer",
        "viewing",
        "viewless",
        "viewpoint",
        "vigorous",
        "village",
        "villain",
        "vindicate",
        "vineyard",
        "vintage",
        "violate",
        "violation",
        "violator",
        "violet",
        "violin",
        "viper",
        "viral",
        "virtual",
        "virtuous",
        "virus",
        "visa",
        "viscosity",
        "viscous",
        "viselike",
        "visible",
        "visibly",
        "vision",
        "visiting",
        "visitor",
        "visor",
        "vista",
        "vitality",
        "vitalize",
        "vitally",
        "vitamins",
        "vivacious",
        "vividly",
        "vividness",
        "vixen",
        "vocalist",
        "vocalize",
        "vocally",
        "vocation",
        "voice",
        "voicing",
        "void",
        "volatile",
        "volley",
        "voltage",
        "volumes",
        "voter",
        "voting",
        "voucher",
        "vowed",
        "vowel",
        "voyage",
        "wackiness",
        "wad",
        "wafer",
        "waffle",
        "waged",
        "wager",
        "wages",
        "waggle",
        "wagon",
        "wake",
        "waking",
        "walk",
        "walmart",
        "walnut",
        "walrus",
        "waltz",
        "wand",
        "wannabe",
        "wanted",
        "wanting",
        "wasabi",
        "washable",
        "washbasin",
        "washboard",
        "washbowl",
        "washcloth",
        "washday",
        "washed",
        "washer",
        "washhouse",
        "washing",
        "washout",
        "washroom",
        "washstand",
        "washtub",
        "wasp",
        "wasting",
        "watch",
        "water",
        "waviness",
        "waving",
        "wavy",
        "whacking",
        "whacky",
        "wham",
        "wharf",
        "wheat",
        "whenever",
        "whiff",
        "whimsical",
        "whinny",
        "whiny",
        "whisking",
        "whoever",
        "whole",
        "whomever",
        "whoopee",
        "whooping",
        "whoops",
        "why",
        "wick",
        "widely",
        "widen",
        "widget",
        "widow",
        "width",
        "wieldable",
        "wielder",
        "wife",
        "wifi",
        "wikipedia",
        "wildcard",
        "wildcat",
        "wilder",
        "wildfire",
        "wildfowl",
        "wildland",
        "wildlife",
        "wildly",
        "wildness",
        "willed",
        "willfully",
        "willing",
        "willow",
        "willpower",
        "wilt",
        "wimp",
        "wince",
        "wincing",
        "wind",
        "wing",
        "winking",
        "winner",
        "winnings",
        "winter",
        "wipe",
        "wired",
        "wireless",
        "wiring",
        "wiry",
        "wisdom",
        "wise",
        "wish",
        "wisplike",
        "wispy",
        "wistful",
        "wizard",
        "wobble",
        "wobbling",
        "wobbly",
        "wok",
        "wolf",
        "wolverine",
        "womanhood",
        "womankind",
        "womanless",
        "womanlike",
        "womanly",
        "womb",
        "woof",
        "wooing",
        "wool",
        "woozy",
        "word",
        "work",
        "worried",
        "worrier",
        "worrisome",
        "worry",
        "worsening",
        "worshiper",
        "worst",
        "wound",
        "woven",
        "wow",
        "wrangle",
        "wrath",
        "wreath",
        "wreckage",
        "wrecker",
        "wrecking",
        "wrench",
        "wriggle",
        "wriggly",
        "wrinkle",
        "wrinkly",
        "wrist",
        "writing",
        "written",
        "wrongdoer",
        "wronged",
        "wrongful",
        "wrongly",
        "wrongness",
        "wrought",
        "xbox",
        "xerox",
        "yahoo",
        "yam",
        "yanking",
        "yapping",
        "yard",
        "yarn",
        "yeah",
        "yearbook",
        "yearling",
        "yearly",
        "yearning",
        "yeast",
        "yelling",
        "yelp",
        "yen",
        "yesterday",
        "yiddish",
        "yield",
        "yin",
        "yippee",
        "yo-yo",
        "yodel",
        "yoga",
        "yogurt",
        "yonder",
        "yoyo",
        "yummy",
        "zap",
        "zealous",
        "zebra",
        "zen",
        "zeppelin",
        "zero",
        "zestfully",
        "zesty",
        "zigzagged",
        "zipfile",
        "zipping",
        "zippy",
        "zips",
        "zit",
        "zodiac",
        "zombie",
        "zone",
        "zoning",
        "zookeeper",
        "zoologist",
        "zoology",
        "zoom"
      ];
    }
  });

  // node_modules/ton-crypto/dist/passwords/newSecureWords.js
  var require_newSecureWords = __commonJS({
    "node_modules/ton-crypto/dist/passwords/newSecureWords.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.newSecureWords = void 0;
      var getSecureRandom_1 = require_getSecureRandom2();
      var wordlist_1 = require_wordlist2();
      function newSecureWords(size = 6) {
        return __async(this, null, function* () {
          let words = [];
          for (let i = 0; i < size; i++) {
            words.push(wordlist_1.wordlist[yield (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length)]);
          }
          return words;
        });
      }
      exports.newSecureWords = newSecureWords;
    }
  });

  // node_modules/ton-crypto/dist/passwords/newSecurePassphrase.js
  var require_newSecurePassphrase = __commonJS({
    "node_modules/ton-crypto/dist/passwords/newSecurePassphrase.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.newSecurePassphrase = void 0;
      var __1 = require_dist();
      function newSecurePassphrase(size = 6) {
        return __async(this, null, function* () {
          return (yield (0, __1.newSecureWords)(size)).join("-");
        });
      }
      exports.newSecurePassphrase = newSecurePassphrase;
    }
  });

  // node_modules/ton-crypto/dist/index.js
  var require_dist = __commonJS({
    "node_modules/ton-crypto/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.newSecurePassphrase = exports.newSecureWords = exports.signVerify = exports.sign = exports.keyPairFromSecretKey = exports.keyPairFromSeed = exports.openBox = exports.sealBox = exports.mnemonicWordList = exports.mnemonicToSeed = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicValidate = exports.mnemonicNew = exports.getSecureRandomNumber = exports.getSecureRandomWords = exports.getSecureRandomBytes = exports.hmac_sha512 = exports.pbkdf2_sha512 = exports.sha512_sync = exports.sha512 = exports.sha256_sync = exports.sha256 = void 0;
      var sha256_1 = require_sha2562();
      Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
        return sha256_1.sha256;
      } });
      Object.defineProperty(exports, "sha256_sync", { enumerable: true, get: function() {
        return sha256_1.sha256_sync;
      } });
      var sha512_1 = require_sha5122();
      Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
        return sha512_1.sha512;
      } });
      Object.defineProperty(exports, "sha512_sync", { enumerable: true, get: function() {
        return sha512_1.sha512_sync;
      } });
      var pbkdf2_sha512_1 = require_pbkdf2_sha5122();
      Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
        return pbkdf2_sha512_1.pbkdf2_sha512;
      } });
      var hmac_sha512_1 = require_hmac_sha5122();
      Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
        return hmac_sha512_1.hmac_sha512;
      } });
      var getSecureRandom_1 = require_getSecureRandom2();
      Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
        return getSecureRandom_1.getSecureRandomBytes;
      } });
      Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
        return getSecureRandom_1.getSecureRandomWords;
      } });
      Object.defineProperty(exports, "getSecureRandomNumber", { enumerable: true, get: function() {
        return getSecureRandom_1.getSecureRandomNumber;
      } });
      var mnemonic_1 = require_mnemonic();
      Object.defineProperty(exports, "mnemonicNew", { enumerable: true, get: function() {
        return mnemonic_1.mnemonicNew;
      } });
      Object.defineProperty(exports, "mnemonicValidate", { enumerable: true, get: function() {
        return mnemonic_1.mnemonicValidate;
      } });
      Object.defineProperty(exports, "mnemonicToPrivateKey", { enumerable: true, get: function() {
        return mnemonic_1.mnemonicToPrivateKey;
      } });
      Object.defineProperty(exports, "mnemonicToWalletKey", { enumerable: true, get: function() {
        return mnemonic_1.mnemonicToWalletKey;
      } });
      Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
        return mnemonic_1.mnemonicToSeed;
      } });
      var wordlist_1 = require_wordlist();
      Object.defineProperty(exports, "mnemonicWordList", { enumerable: true, get: function() {
        return wordlist_1.wordlist;
      } });
      var nacl_1 = require_nacl();
      Object.defineProperty(exports, "sealBox", { enumerable: true, get: function() {
        return nacl_1.sealBox;
      } });
      Object.defineProperty(exports, "openBox", { enumerable: true, get: function() {
        return nacl_1.openBox;
      } });
      Object.defineProperty(exports, "keyPairFromSeed", { enumerable: true, get: function() {
        return nacl_1.keyPairFromSeed;
      } });
      var nacl_2 = require_nacl();
      Object.defineProperty(exports, "keyPairFromSecretKey", { enumerable: true, get: function() {
        return nacl_2.keyPairFromSecretKey;
      } });
      Object.defineProperty(exports, "sign", { enumerable: true, get: function() {
        return nacl_2.sign;
      } });
      Object.defineProperty(exports, "signVerify", { enumerable: true, get: function() {
        return nacl_2.signVerify;
      } });
      var newSecureWords_1 = require_newSecureWords();
      Object.defineProperty(exports, "newSecureWords", { enumerable: true, get: function() {
        return newSecureWords_1.newSecureWords;
      } });
      var newSecurePassphrase_1 = require_newSecurePassphrase();
      Object.defineProperty(exports, "newSecurePassphrase", { enumerable: true, get: function() {
        return newSecurePassphrase_1.newSecurePassphrase;
      } });
    }
  });

  // node_modules/ton/dist/boc/utils/crc32c.js
  var require_crc32c = __commonJS({
    "node_modules/ton/dist/boc/utils/crc32c.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crc32c = void 0;
      var POLY = 2197175160;
      function crc32c(source) {
        let crc = 0 ^ 4294967295;
        for (let n = 0; n < source.length; n++) {
          crc ^= source[n];
          crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
          crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
          crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
          crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
          crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
          crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
          crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
          crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        }
        crc = crc ^ 4294967295;
        let res = Buffer.alloc(4);
        res.writeInt32LE(crc);
        return res;
      }
      exports.crc32c = crc32c;
    }
  });

  // node_modules/ton/dist/boc/utils/topologicalSort.js
  var require_topologicalSort = __commonJS({
    "node_modules/ton/dist/boc/utils/topologicalSort.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.topologicalSort = void 0;
      function topologicalSort(src) {
        let pending = [src];
        let allCells = /* @__PURE__ */ new Map();
        let notPermCells = /* @__PURE__ */ new Set();
        let sorted = [];
        while (pending.length > 0) {
          const cells = [...pending];
          pending = [];
          for (let cell of cells) {
            const hash = cell.hash().toString("hex");
            if (allCells.has(hash)) {
              continue;
            }
            notPermCells.add(hash);
            allCells.set(hash, { cell, refs: cell.refs.map((v) => v.hash().toString("hex")) });
            for (let r of cell.refs) {
              pending.push(r);
            }
          }
        }
        let tempMark = /* @__PURE__ */ new Set();
        function visit(hash) {
          if (!notPermCells.has(hash)) {
            return;
          }
          if (tempMark.has(hash)) {
            throw Error("Not a DAG");
          }
          tempMark.add(hash);
          for (let c of allCells.get(hash).refs) {
            visit(c);
          }
          sorted.unshift(hash);
          tempMark.delete(hash);
          notPermCells.delete(hash);
        }
        while (notPermCells.size > 0) {
          const id = Array.from(notPermCells)[0];
          visit(id);
        }
        let indexes = /* @__PURE__ */ new Map();
        for (let i = 0; i < sorted.length; i++) {
          indexes.set(sorted[i], i);
        }
        let result = [];
        for (let ent of sorted) {
          const rrr = allCells.get(ent);
          result.push({ cell: rrr.cell, refs: rrr.refs.map((v) => indexes.get(v)) });
        }
        return result;
      }
      exports.topologicalSort = topologicalSort;
    }
  });

  // node_modules/ton/dist/boc/boc.js
  var require_boc = __commonJS({
    "node_modules/ton/dist/boc/boc.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.serializeToBoc = exports.deserializeBoc = exports.deserializeCellData = exports.parseBocHeader = exports.hashCell = exports.getMaxLevel = exports.getMaxDepth = void 0;
      var ton_crypto_1 = require_dist();
      var __1 = require_dist2();
      var crc32c_1 = require_crc32c();
      var topologicalSort_1 = require_topologicalSort();
      var reachBocMagicPrefix = Buffer.from("B5EE9C72", "hex");
      var leanBocMagicPrefix = Buffer.from("68ff65f3", "hex");
      var leanBocMagicPrefixCRC = Buffer.from("acc3a728", "hex");
      var cacheContext = null;
      function getCellCache(src) {
        if (!cacheContext) {
          throw Error("No cache context");
        }
        let ex = src[cacheContext];
        if (!ex) {
          ex = { hash: null, maxDepth: null };
          src[cacheContext] = ex;
        }
        return ex;
      }
      function inCache(cell, handler) {
        let wasCreated = false;
        if (!cacheContext) {
          wasCreated = true;
          cacheContext = Symbol();
        }
        let cache = getCellCache(cell);
        try {
          return handler(cache);
        } finally {
          if (wasCreated) {
            cacheContext = null;
          }
        }
      }
      function getMaxDepth(cell) {
        return inCache(cell, (cache) => {
          if (cache.maxDepth !== null) {
            return cache.maxDepth;
          }
          let maxDepth = 0;
          if (cell.refs.length > 0) {
            for (let k in cell.refs) {
              const i = cell.refs[k];
              if (getMaxDepth(i) > maxDepth) {
                maxDepth = getMaxDepth(i);
              }
            }
            maxDepth = maxDepth + 1;
          }
          cache.maxDepth = maxDepth;
          return maxDepth;
        });
      }
      exports.getMaxDepth = getMaxDepth;
      function getMaxDepthAsArray(cell) {
        const maxDepth = getMaxDepth(cell);
        const d = Uint8Array.from({ length: 2 }, () => 0);
        d[1] = maxDepth % 256;
        d[0] = Math.floor(maxDepth / 256);
        return Buffer.from(d);
      }
      function getMaxLevel(cell) {
        return 0;
      }
      exports.getMaxLevel = getMaxLevel;
      function getRefsDescriptor(cell) {
        const d1 = Uint8Array.from({ length: 1 }, () => 0);
        d1[0] = cell.refs.length + (cell.isExotic ? 1 : 0) * 8 + getMaxLevel(cell) * 32;
        return Buffer.from(d1);
      }
      function getBitsDescriptor(cell) {
        const d2 = Uint8Array.from({ length: 1 }, () => 0);
        let len = cell.bits.cursor;
        if (cell.isExotic) {
          len += 8;
        }
        d2[0] = Math.ceil(len / 8) + Math.floor(len / 8);
        return Buffer.from(d2);
      }
      function getDataWithDescriptors(cell) {
        const d1 = getRefsDescriptor(cell);
        const d2 = getBitsDescriptor(cell);
        const tuBits = cell.bits.getTopUppedArray();
        return Buffer.concat([d1, d2, tuBits]);
      }
      function getRepr(cell) {
        const reprArray = [];
        reprArray.push(getDataWithDescriptors(cell));
        for (let k in cell.refs) {
          const i = cell.refs[k];
          reprArray.push(getMaxDepthAsArray(i));
        }
        for (let k in cell.refs) {
          const i = cell.refs[k];
          reprArray.push(i.hash());
        }
        let x = Buffer.alloc(0);
        for (let k in reprArray) {
          const i = reprArray[k];
          x = Buffer.concat([x, i]);
        }
        return x;
      }
      function hashCell(cell) {
        return inCache(cell, (cache) => {
          if (cache.hash) {
            return cache.hash;
          }
          let r = (0, ton_crypto_1.sha256_sync)(getRepr(cell));
          cache.hash = r;
          return r;
        });
      }
      exports.hashCell = hashCell;
      function readNBytesUIntFromArray(n, ui8array) {
        let res = 0;
        for (let c = 0; c < n; c++) {
          res *= 256;
          res += ui8array[c];
        }
        return res;
      }
      function parseBocHeader(serializedBoc) {
        if (serializedBoc.length < 4 + 1) {
          throw new Error("Not enough bytes for magic prefix");
        }
        const inputData = serializedBoc;
        const prefix = serializedBoc.slice(0, 4);
        serializedBoc = serializedBoc.slice(4);
        let has_idx = false;
        let hash_crc32 = false;
        let has_cache_bits = false;
        let flags = 0;
        let size_bytes = 0;
        if (prefix.equals(reachBocMagicPrefix)) {
          const flags_byte = serializedBoc[0];
          has_idx = !!(flags_byte & 128);
          hash_crc32 = !!(flags_byte & 64);
          has_cache_bits = !!(flags_byte & 32);
          flags = (flags_byte & 16) * 2 + (flags_byte & 8);
          size_bytes = flags_byte % 8;
        } else if (prefix.equals(leanBocMagicPrefix)) {
          has_idx = true;
          hash_crc32 = false;
          has_cache_bits = false;
          flags = 0;
          size_bytes = serializedBoc[0];
        } else if (prefix.equals(leanBocMagicPrefixCRC)) {
          has_idx = true;
          hash_crc32 = true;
          has_cache_bits = false;
          flags = 0;
          size_bytes = serializedBoc[0];
        } else {
          throw Error("Unknown magic prefix");
        }
        serializedBoc = serializedBoc.slice(1);
        if (serializedBoc.length < 1 + 5 * size_bytes) {
          throw new Error("Not enough bytes for encoding cells counters");
        }
        const offset_bytes = serializedBoc[0];
        serializedBoc = serializedBoc.slice(1);
        const cells_num = readNBytesUIntFromArray(size_bytes, serializedBoc);
        serializedBoc = serializedBoc.slice(size_bytes);
        const roots_num = readNBytesUIntFromArray(size_bytes, serializedBoc);
        serializedBoc = serializedBoc.slice(size_bytes);
        const absent_num = readNBytesUIntFromArray(size_bytes, serializedBoc);
        serializedBoc = serializedBoc.slice(size_bytes);
        const tot_cells_size = readNBytesUIntFromArray(offset_bytes, serializedBoc);
        serializedBoc = serializedBoc.slice(offset_bytes);
        if (serializedBoc.length < roots_num * size_bytes) {
          throw new Error("Not enough bytes for encoding root cells hashes");
        }
        let root_list = [];
        for (let c = 0; c < roots_num; c++) {
          root_list.push(readNBytesUIntFromArray(size_bytes, serializedBoc));
          serializedBoc = serializedBoc.slice(size_bytes);
        }
        let index = null;
        if (has_idx) {
          index = [];
          if (serializedBoc.length < offset_bytes * cells_num)
            throw new Error("Not enough bytes for index encoding");
          for (let c = 0; c < cells_num; c++) {
            index.push(readNBytesUIntFromArray(offset_bytes, serializedBoc));
            serializedBoc = serializedBoc.slice(offset_bytes);
          }
        }
        if (serializedBoc.length < tot_cells_size) {
          throw new Error("Not enough bytes for cells data");
        }
        const cells_data = serializedBoc.slice(0, tot_cells_size);
        serializedBoc = serializedBoc.slice(tot_cells_size);
        if (hash_crc32) {
          if (serializedBoc.length < 4) {
            throw new Error("Not enough bytes for crc32c hashsum");
          }
          const length = inputData.length;
          if (!(0, crc32c_1.crc32c)(inputData.slice(0, length - 4)).equals(serializedBoc.slice(0, 4))) {
            throw new Error("Crc32c hashsum mismatch");
          }
          serializedBoc = serializedBoc.slice(4);
        }
        if (serializedBoc.length) {
          throw new Error("Too much bytes in BoC serialization");
        }
        return {
          has_idx,
          hash_crc32,
          has_cache_bits,
          flags,
          size_bytes,
          off_bytes: offset_bytes,
          cells_num,
          roots_num,
          absent_num,
          tot_cells_size,
          root_list,
          index,
          cells_data
        };
      }
      exports.parseBocHeader = parseBocHeader;
      function deserializeCellData(cellData, referenceIndexSize) {
        if (cellData.length < 2) {
          throw new Error("Not enough bytes to encode cell descriptors");
        }
        const d1 = cellData[0], d2 = cellData[1];
        cellData = cellData.slice(2);
        const isExotic = !!(d1 & 8);
        const refNum = d1 % 8;
        let dataBytesize = Math.ceil(d2 / 2);
        const fullfilledBytes = !(d2 % 2);
        let bits = __1.BitString.alloc(1023);
        let refs = [];
        if (cellData.length < dataBytesize + referenceIndexSize * refNum) {
          throw new Error("Not enough bytes to encode cell data");
        }
        let kind = "ordinary";
        if (isExotic) {
          let k = cellData.readUInt8();
          if (k === 1) {
            kind = "pruned";
          } else if (k === 2) {
            kind = "library_reference";
          } else if (k === 3) {
            kind = "merkle_proof";
          } else if (k === 4) {
            kind = "merkle_update";
          } else {
            throw Error("Invalid cell type: " + k);
          }
          cellData = cellData.slice(1);
          dataBytesize--;
        }
        bits.setTopUppedArray(cellData.slice(0, dataBytesize), fullfilledBytes);
        cellData = cellData.slice(dataBytesize);
        for (let r = 0; r < refNum; r++) {
          refs.push(readNBytesUIntFromArray(referenceIndexSize, cellData));
          cellData = cellData.slice(referenceIndexSize);
        }
        let cell = new __1.Cell(kind, bits);
        return { cell, refs, residue: cellData };
      }
      exports.deserializeCellData = deserializeCellData;
      function deserializeBoc(serializedBoc) {
        const header = parseBocHeader(serializedBoc);
        let cells_data = header.cells_data;
        let cells_array = [];
        let refs_array = [];
        for (let ci = 0; ci < header.cells_num; ci++) {
          let dd = deserializeCellData(cells_data, header.size_bytes);
          cells_data = dd.residue;
          cells_array.push(dd.cell);
          refs_array.push(dd.refs);
        }
        for (let ci = header.cells_num - 1; ci >= 0; ci--) {
          let c = refs_array[ci];
          for (let ri = 0; ri < c.length; ri++) {
            const r = c[ri];
            if (r < ci) {
              throw new Error("Topological order is broken");
            }
            cells_array[ci].refs[ri] = cells_array[r];
          }
        }
        let root_cells = [];
        for (let ri of header.root_list) {
          root_cells.push(cells_array[ri]);
        }
        return root_cells;
      }
      exports.deserializeBoc = deserializeBoc;
      function serializeForBoc(cell, refs, sSize) {
        const reprArray = [];
        reprArray.push(getRefsDescriptor(cell));
        reprArray.push(getBitsDescriptor(cell));
        if (cell.isExotic) {
          if (cell.kind === "pruned") {
            reprArray.push(Buffer.from([1]));
          } else if (cell.kind === "library_reference") {
            reprArray.push(Buffer.from([2]));
          } else if (cell.kind === "merkle_proof") {
            reprArray.push(Buffer.from([3]));
          } else if (cell.kind === "merkle_update") {
            reprArray.push(Buffer.from([4]));
          } else {
            throw Error("Invalid cell type");
          }
        }
        reprArray.push(cell.bits.getTopUppedArray());
        for (let refIndexInt of refs) {
          let refIndexHex = refIndexInt.toString(16);
          while (refIndexHex.length < sSize * 2) {
            refIndexHex = "0" + refIndexHex;
          }
          const reference = Buffer.from(refIndexHex, "hex");
          reprArray.push(reference);
        }
        let x = Buffer.alloc(0);
        for (let k in reprArray) {
          const i = reprArray[k];
          x = Buffer.concat([x, i]);
        }
        return x;
      }
      function serializeToBoc(cell, has_idx = true, hash_crc32 = true, has_cache_bits = false, flags = 0) {
        return inCache(cell, () => {
          const root_cell = cell;
          const allCells = (0, topologicalSort_1.topologicalSort)(root_cell);
          const cells_num = allCells.length;
          const s = cells_num.toString(2).length;
          const s_bytes = Math.max(Math.ceil(s / 8), 1);
          let full_size = 0;
          let sizeIndex = [];
          for (let cell_info of allCells) {
            full_size = full_size + serializeForBoc(cell_info.cell, cell_info.refs, s_bytes).length;
            sizeIndex.push(full_size);
          }
          const offset_bits = full_size.toString(2).length;
          const offset_bytes = Math.max(Math.ceil(offset_bits / 8), 1);
          const serialization = __1.BitString.alloc((1023 + 32 * 4 + 32 * 3) * allCells.length);
          serialization.writeBuffer(reachBocMagicPrefix);
          serialization.writeBitArray([has_idx, hash_crc32, has_cache_bits]);
          serialization.writeUint(flags, 2);
          serialization.writeUint(s_bytes, 3);
          serialization.writeUint8(offset_bytes);
          serialization.writeUint(cells_num, s_bytes * 8);
          serialization.writeUint(1, s_bytes * 8);
          serialization.writeUint(0, s_bytes * 8);
          serialization.writeUint(full_size, offset_bytes * 8);
          serialization.writeUint(0, s_bytes * 8);
          if (has_idx) {
            allCells.forEach((cell_data, index) => serialization.writeUint(sizeIndex[index], offset_bytes * 8));
          }
          for (let cell_info of allCells) {
            const refcell_ser = serializeForBoc(cell_info.cell, cell_info.refs, s_bytes);
            serialization.writeBuffer(refcell_ser);
          }
          let ser_arr = serialization.getTopUppedArray();
          if (hash_crc32) {
            ser_arr = Buffer.concat([ser_arr, (0, crc32c_1.crc32c)(ser_arr)]);
          }
          return ser_arr;
        });
      }
      exports.serializeToBoc = serializeToBoc;
    }
  });

  // node_modules/ton/dist/boc/Cell.js
  var require_Cell = __commonJS({
    "node_modules/ton/dist/boc/Cell.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Cell = void 0;
      var BitString_1 = require_BitString();
      var boc_1 = require_boc();
      var symbol_inspect_1 = __importDefault(require_symbol());
      var __1 = require_dist2();
      var Cell2 = class {
        constructor(kind = "ordinary", bits = BitString_1.BitString.alloc(1023)) {
          this.refs = [];
          this[_a] = () => this.toString();
          this.kind = kind;
          this.bits = bits;
        }
        static fromBoc(src) {
          return (0, boc_1.deserializeBoc)(typeof src === "string" ? Buffer.from(src, "hex") : src);
        }
        get isExotic() {
          return this.kind !== "ordinary";
        }
        beginParse() {
          if (this.isExotic) {
            throw Error("Unable to parse exotic cell");
          }
          return __1.Slice.fromCell(this);
        }
        writeCell(anotherCell) {
          this.bits.writeBitString(anotherCell.bits);
          for (let r of anotherCell.refs) {
            this.refs.push(r);
          }
        }
        hash() {
          return (0, boc_1.hashCell)(this);
        }
        toBoc(opts) {
          let idx = opts && opts.idx !== null && opts.idx !== void 0 ? opts.idx : true;
          let crc32 = opts && opts.crc32 !== null && opts.crc32 !== void 0 ? opts.crc32 : true;
          let cacheBits = opts && opts.cacheBits !== null && opts.cacheBits !== void 0 ? opts.cacheBits : false;
          let flags = opts && opts.flags !== null && opts.flags !== void 0 ? opts.flags : 0;
          return (0, boc_1.serializeToBoc)(this, idx, crc32, cacheBits, flags);
        }
        toString(indent) {
          let id = indent || "";
          let s = id + "x{" + this.bits.toFiftHex() + "}\n";
          for (let k in this.refs) {
            const i = this.refs[k];
            s += i.toString(id + " ");
          }
          return s;
        }
        toDebugString(indent) {
          let id = indent || "";
          if (this.isExotic) {
            id += "(exotic)";
          }
          let s = id + "x{" + this.bits.toFiftHex() + "}\n";
          for (let k in this.refs) {
            const i = this.refs[k];
            s += i.toString(id + " ");
          }
          return s;
        }
        withReference(cell) {
          this.refs.push(cell);
          return this;
        }
        withData(src) {
          for (let s of src) {
            if (s === "0") {
              this.bits.writeBit(0);
            } else {
              this.bits.writeBit(1);
            }
          }
          return this;
        }
        equals(src) {
          if (src.refs.length !== this.refs.length) {
            return false;
          }
          for (let i = 0; i < src.refs.length; i++) {
            if (!src.refs[i].equals(this.refs[i])) {
              return false;
            }
          }
          return this.bits.equals(src.bits);
        }
        getMaxLevel() {
          return (0, boc_1.getMaxLevel)(this);
        }
        getMaxDepth() {
          return (0, boc_1.getMaxDepth)(this);
        }
      };
      exports.Cell = Cell2;
      _a = symbol_inspect_1.default;
    }
  });

  // node_modules/ton/dist/utils/crc16.js
  var require_crc16 = __commonJS({
    "node_modules/ton/dist/utils/crc16.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crc16 = void 0;
      function crc16(data) {
        const poly = 4129;
        let reg = 0;
        const message = Buffer.alloc(data.length + 2);
        message.set(data);
        for (let byte of message) {
          let mask = 128;
          while (mask > 0) {
            reg <<= 1;
            if (byte & mask) {
              reg += 1;
            }
            mask >>= 1;
            if (reg > 65535) {
              reg &= 65535;
              reg ^= poly;
            }
          }
        }
        return Buffer.from([Math.floor(reg / 256), reg % 256]);
      }
      exports.crc16 = crc16;
    }
  });

  // node_modules/ton/dist/address/Address.js
  var require_Address = __commonJS({
    "node_modules/ton/dist/address/Address.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Address = void 0;
      var symbol_inspect_1 = __importDefault(require_symbol());
      var crc16_1 = require_crc16();
      var bounceable_tag = 17;
      var non_bounceable_tag = 81;
      var test_flag = 128;
      function parseFriendlyAddress(src) {
        const data = Buffer.isBuffer(src) ? src : Buffer.from(src, "base64");
        if (data.length !== 36) {
          throw new Error("Unknown address type: byte length is not equal to 36");
        }
        const addr = data.slice(0, 34);
        const crc = data.slice(34, 36);
        const calcedCrc = (0, crc16_1.crc16)(addr);
        if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {
          throw new Error("Invalid checksum: " + src);
        }
        let tag = addr[0];
        let isTestOnly = false;
        let isBounceable = false;
        if (tag & test_flag) {
          isTestOnly = true;
          tag = tag ^ test_flag;
        }
        if (tag !== bounceable_tag && tag !== non_bounceable_tag)
          throw "Unknown address tag";
        isBounceable = tag === bounceable_tag;
        let workchain = null;
        if (addr[1] === 255) {
          workchain = -1;
        } else {
          workchain = addr[1];
        }
        const hashPart = addr.slice(2, 34);
        return { isTestOnly, isBounceable, workchain, hashPart };
      }
      var Address2 = class {
        constructor(workChain, hash) {
          this.toString = () => {
            return this.workChain + ":" + this.hash.toString("hex");
          };
          this.toBuffer = () => {
            const addressWithChecksum = Buffer.alloc(36);
            addressWithChecksum.set(this.hash);
            addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);
            return addressWithChecksum;
          };
          this.toFriendlyBuffer = (args) => {
            let testOnly = args && args.testOnly !== void 0 ? args.testOnly : false;
            let bounceable = args && args.bounceable !== void 0 ? args.bounceable : true;
            let tag = bounceable ? bounceable_tag : non_bounceable_tag;
            if (testOnly) {
              tag |= test_flag;
            }
            const addr = Buffer.alloc(34);
            addr[0] = tag;
            addr[1] = this.workChain;
            addr.set(this.hash, 2);
            const addressWithChecksum = Buffer.alloc(36);
            addressWithChecksum.set(addr);
            addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);
            return addressWithChecksum;
          };
          this.toFriendly = (args) => {
            let urlSafe = args && args.urlSafe !== void 0 ? args.urlSafe : true;
            let buffer = this.toFriendlyBuffer(args);
            if (urlSafe) {
              return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_");
            } else {
              return buffer.toString("base64");
            }
          };
          this[_a] = () => this.toFriendly();
          this.workChain = workChain;
          this.hash = hash;
          Object.freeze(this);
        }
        static isAddress(src) {
          return src instanceof Address2;
        }
        static isFriendly(source) {
          return source.indexOf(":") < 0;
        }
        static normalize(source) {
          if (typeof source === "string") {
            return Address2.parse(source).toFriendly();
          } else {
            return source.toFriendly();
          }
        }
        static parse(source) {
          if (Address2.isFriendly(source)) {
            return this.parseFriendly(source).address;
          } else {
            return this.parseRaw(source);
          }
        }
        static parseRaw(source) {
          let workChain = parseInt(source.split(":")[0]);
          let hash = Buffer.from(source.split(":")[1], "hex");
          return new Address2(workChain, hash);
        }
        static parseFriendly(source) {
          if (Buffer.isBuffer(source)) {
            let r = parseFriendlyAddress(source);
            return {
              isBounceable: r.isBounceable,
              isTestOnly: r.isTestOnly,
              address: new Address2(r.workchain, r.hashPart)
            };
          } else {
            let addr = source.replace(/\-/g, "+").replace(/_/g, "/");
            let r = parseFriendlyAddress(addr);
            return {
              isBounceable: r.isBounceable,
              isTestOnly: r.isTestOnly,
              address: new Address2(r.workchain, r.hashPart)
            };
          }
        }
        equals(src) {
          if (src.workChain !== this.workChain) {
            return false;
          }
          return src.hash.equals(this.hash);
        }
      };
      exports.Address = Address2;
      _a = symbol_inspect_1.default;
    }
  });

  // node_modules/fp-ts/lib/function.js
  var require_function = __commonJS({
    "node_modules/fp-ts/lib/function.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getEndomorphismMonoid = exports.not = exports.SK = exports.hole = exports.pipe = exports.untupled = exports.tupled = exports.absurd = exports.decrement = exports.increment = exports.tuple = exports.flow = exports.flip = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.constant = exports.unsafeCoerce = exports.identity = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;
      var getBooleanAlgebra = function(B) {
        return function() {
          return {
            meet: function(x, y) {
              return function(a) {
                return B.meet(x(a), y(a));
              };
            },
            join: function(x, y) {
              return function(a) {
                return B.join(x(a), y(a));
              };
            },
            zero: function() {
              return B.zero;
            },
            one: function() {
              return B.one;
            },
            implies: function(x, y) {
              return function(a) {
                return B.implies(x(a), y(a));
              };
            },
            not: function(x) {
              return function(a) {
                return B.not(x(a));
              };
            }
          };
        };
      };
      exports.getBooleanAlgebra = getBooleanAlgebra;
      var getSemigroup = function(S) {
        return function() {
          return {
            concat: function(f, g) {
              return function(a) {
                return S.concat(f(a), g(a));
              };
            }
          };
        };
      };
      exports.getSemigroup = getSemigroup;
      var getMonoid = function(M) {
        var getSemigroupM = (0, exports.getSemigroup)(M);
        return function() {
          return {
            concat: getSemigroupM().concat,
            empty: function() {
              return M.empty;
            }
          };
        };
      };
      exports.getMonoid = getMonoid;
      var getSemiring = function(S) {
        return {
          add: function(f, g) {
            return function(x) {
              return S.add(f(x), g(x));
            };
          },
          zero: function() {
            return S.zero;
          },
          mul: function(f, g) {
            return function(x) {
              return S.mul(f(x), g(x));
            };
          },
          one: function() {
            return S.one;
          }
        };
      };
      exports.getSemiring = getSemiring;
      var getRing = function(R) {
        var S = (0, exports.getSemiring)(R);
        return {
          add: S.add,
          mul: S.mul,
          one: S.one,
          zero: S.zero,
          sub: function(f, g) {
            return function(x) {
              return R.sub(f(x), g(x));
            };
          }
        };
      };
      exports.getRing = getRing;
      var apply = function(a) {
        return function(f) {
          return f(a);
        };
      };
      exports.apply = apply;
      function identity(a) {
        return a;
      }
      exports.identity = identity;
      exports.unsafeCoerce = identity;
      function constant(a) {
        return function() {
          return a;
        };
      }
      exports.constant = constant;
      exports.constTrue = constant(true);
      exports.constFalse = constant(false);
      exports.constNull = constant(null);
      exports.constUndefined = constant(void 0);
      exports.constVoid = exports.constUndefined;
      function flip(f) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (args.length > 1) {
            return f(args[1], args[0]);
          }
          return function(a) {
            return f(a)(args[0]);
          };
        };
      }
      exports.flip = flip;
      function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
        switch (arguments.length) {
          case 1:
            return ab;
          case 2:
            return function() {
              return bc(ab.apply(this, arguments));
            };
          case 3:
            return function() {
              return cd(bc(ab.apply(this, arguments)));
            };
          case 4:
            return function() {
              return de(cd(bc(ab.apply(this, arguments))));
            };
          case 5:
            return function() {
              return ef(de(cd(bc(ab.apply(this, arguments)))));
            };
          case 6:
            return function() {
              return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
            };
          case 7:
            return function() {
              return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
            };
          case 8:
            return function() {
              return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
            };
          case 9:
            return function() {
              return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
            };
        }
        return;
      }
      exports.flow = flow;
      function tuple() {
        var t = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          t[_i] = arguments[_i];
        }
        return t;
      }
      exports.tuple = tuple;
      function increment(n) {
        return n + 1;
      }
      exports.increment = increment;
      function decrement(n) {
        return n - 1;
      }
      exports.decrement = decrement;
      function absurd(_) {
        throw new Error("Called `absurd` function which should be uncallable");
      }
      exports.absurd = absurd;
      function tupled(f) {
        return function(a) {
          return f.apply(void 0, a);
        };
      }
      exports.tupled = tupled;
      function untupled(f) {
        return function() {
          var a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
          }
          return f(a);
        };
      }
      exports.untupled = untupled;
      function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
        switch (arguments.length) {
          case 1:
            return a;
          case 2:
            return ab(a);
          case 3:
            return bc(ab(a));
          case 4:
            return cd(bc(ab(a)));
          case 5:
            return de(cd(bc(ab(a))));
          case 6:
            return ef(de(cd(bc(ab(a)))));
          case 7:
            return fg(ef(de(cd(bc(ab(a))))));
          case 8:
            return gh(fg(ef(de(cd(bc(ab(a)))))));
          case 9:
            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
          default: {
            var ret = arguments[0];
            for (var i = 1; i < arguments.length; i++) {
              ret = arguments[i](ret);
            }
            return ret;
          }
        }
      }
      exports.pipe = pipe;
      exports.hole = absurd;
      var SK = function(_, b) {
        return b;
      };
      exports.SK = SK;
      function not(predicate) {
        return function(a) {
          return !predicate(a);
        };
      }
      exports.not = not;
      var getEndomorphismMonoid = function() {
        return {
          concat: function(first, second) {
            return flow(first, second);
          },
          empty: identity
        };
      };
      exports.getEndomorphismMonoid = getEndomorphismMonoid;
    }
  });

  // node_modules/fp-ts/lib/internal.js
  var require_internal = __commonJS({
    "node_modules/fp-ts/lib/internal.js"(exports) {
      "use strict";
      var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromReadonlyNonEmptyArray = exports.has = exports.emptyRecord = exports.emptyReadonlyArray = exports.tail = exports.head = exports.isNonEmpty = exports.singleton = exports.right = exports.left = exports.isRight = exports.isLeft = exports.some = exports.none = exports.isSome = exports.isNone = void 0;
      var isNone = function(fa) {
        return fa._tag === "None";
      };
      exports.isNone = isNone;
      var isSome = function(fa) {
        return fa._tag === "Some";
      };
      exports.isSome = isSome;
      exports.none = { _tag: "None" };
      var some = function(a) {
        return { _tag: "Some", value: a };
      };
      exports.some = some;
      var isLeft = function(ma) {
        return ma._tag === "Left";
      };
      exports.isLeft = isLeft;
      var isRight = function(ma) {
        return ma._tag === "Right";
      };
      exports.isRight = isRight;
      var left = function(e) {
        return { _tag: "Left", left: e };
      };
      exports.left = left;
      var right = function(a) {
        return { _tag: "Right", right: a };
      };
      exports.right = right;
      var singleton = function(a) {
        return [a];
      };
      exports.singleton = singleton;
      var isNonEmpty = function(as) {
        return as.length > 0;
      };
      exports.isNonEmpty = isNonEmpty;
      var head = function(as) {
        return as[0];
      };
      exports.head = head;
      var tail = function(as) {
        return as.slice(1);
      };
      exports.tail = tail;
      exports.emptyReadonlyArray = [];
      exports.emptyRecord = {};
      exports.has = Object.prototype.hasOwnProperty;
      var fromReadonlyNonEmptyArray = function(as) {
        return __spreadArray([as[0]], as.slice(1), true);
      };
      exports.fromReadonlyNonEmptyArray = fromReadonlyNonEmptyArray;
    }
  });

  // node_modules/fp-ts/lib/Apply.js
  var require_Apply = __commonJS({
    "node_modules/fp-ts/lib/Apply.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sequenceS = exports.sequenceT = exports.getApplySemigroup = exports.apS = exports.apSecond = exports.apFirst = exports.ap = void 0;
      var function_1 = require_function();
      var _ = __importStar(require_internal());
      function ap(F, G) {
        return function(fa) {
          return function(fab) {
            return F.ap(F.map(fab, function(gab) {
              return function(ga) {
                return G.ap(gab, ga);
              };
            }), fa);
          };
        };
      }
      exports.ap = ap;
      function apFirst(A) {
        return function(second) {
          return function(first) {
            return A.ap(A.map(first, function(a) {
              return function() {
                return a;
              };
            }), second);
          };
        };
      }
      exports.apFirst = apFirst;
      function apSecond(A) {
        return function(second) {
          return function(first) {
            return A.ap(A.map(first, function() {
              return function(b) {
                return b;
              };
            }), second);
          };
        };
      }
      exports.apSecond = apSecond;
      function apS(F) {
        return function(name, fb) {
          return function(fa) {
            return F.ap(F.map(fa, function(a) {
              return function(b) {
                var _a;
                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
              };
            }), fb);
          };
        };
      }
      exports.apS = apS;
      function getApplySemigroup(F) {
        return function(S) {
          return {
            concat: function(first, second) {
              return F.ap(F.map(first, function(x) {
                return function(y) {
                  return S.concat(x, y);
                };
              }), second);
            }
          };
        };
      }
      exports.getApplySemigroup = getApplySemigroup;
      function curried(f, n, acc) {
        return function(x) {
          var combined = Array(acc.length + 1);
          for (var i = 0; i < acc.length; i++) {
            combined[i] = acc[i];
          }
          combined[acc.length] = x;
          return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);
        };
      }
      var tupleConstructors = {
        1: function(a) {
          return [a];
        },
        2: function(a) {
          return function(b) {
            return [a, b];
          };
        },
        3: function(a) {
          return function(b) {
            return function(c) {
              return [a, b, c];
            };
          };
        },
        4: function(a) {
          return function(b) {
            return function(c) {
              return function(d) {
                return [a, b, c, d];
              };
            };
          };
        },
        5: function(a) {
          return function(b) {
            return function(c) {
              return function(d) {
                return function(e) {
                  return [a, b, c, d, e];
                };
              };
            };
          };
        }
      };
      function getTupleConstructor(len) {
        if (!_.has.call(tupleConstructors, len)) {
          tupleConstructors[len] = curried(function_1.tuple, len - 1, []);
        }
        return tupleConstructors[len];
      }
      function sequenceT(F) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var len = args.length;
          var f = getTupleConstructor(len);
          var fas = F.map(args[0], f);
          for (var i = 1; i < len; i++) {
            fas = F.ap(fas, args[i]);
          }
          return fas;
        };
      }
      exports.sequenceT = sequenceT;
      function getRecordConstructor(keys) {
        var len = keys.length;
        switch (len) {
          case 1:
            return function(a) {
              var _a;
              return _a = {}, _a[keys[0]] = a, _a;
            };
          case 2:
            return function(a) {
              return function(b) {
                var _a;
                return _a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a;
              };
            };
          case 3:
            return function(a) {
              return function(b) {
                return function(c) {
                  var _a;
                  return _a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a;
                };
              };
            };
          case 4:
            return function(a) {
              return function(b) {
                return function(c) {
                  return function(d) {
                    var _a;
                    return _a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a[keys[3]] = d, _a;
                  };
                };
              };
            };
          case 5:
            return function(a) {
              return function(b) {
                return function(c) {
                  return function(d) {
                    return function(e) {
                      var _a;
                      return _a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a[keys[3]] = d, _a[keys[4]] = e, _a;
                    };
                  };
                };
              };
            };
          default:
            return curried(function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var r = {};
              for (var i = 0; i < len; i++) {
                r[keys[i]] = args[i];
              }
              return r;
            }, len - 1, []);
        }
      }
      function sequenceS(F) {
        return function(r) {
          var keys = Object.keys(r);
          var len = keys.length;
          var f = getRecordConstructor(keys);
          var fr = F.map(r[keys[0]], f);
          for (var i = 1; i < len; i++) {
            fr = F.ap(fr, r[keys[i]]);
          }
          return fr;
        };
      }
      exports.sequenceS = sequenceS;
    }
  });

  // node_modules/fp-ts/lib/Functor.js
  var require_Functor = __commonJS({
    "node_modules/fp-ts/lib/Functor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFunctorComposition = exports.let = exports.bindTo = exports.flap = exports.map = void 0;
      var function_1 = require_function();
      function map(F, G) {
        return function(f) {
          return function(fa) {
            return F.map(fa, function(ga) {
              return G.map(ga, f);
            });
          };
        };
      }
      exports.map = map;
      function flap(F) {
        return function(a) {
          return function(fab) {
            return F.map(fab, function(f) {
              return f(a);
            });
          };
        };
      }
      exports.flap = flap;
      function bindTo(F) {
        return function(name) {
          return function(fa) {
            return F.map(fa, function(a) {
              var _a;
              return _a = {}, _a[name] = a, _a;
            });
          };
        };
      }
      exports.bindTo = bindTo;
      function let_(F) {
        return function(name, f) {
          return function(fa) {
            return F.map(fa, function(a) {
              var _a;
              return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));
            });
          };
        };
      }
      exports.let = let_;
      function getFunctorComposition(F, G) {
        var _map = map(F, G);
        return {
          map: function(fga, f) {
            return (0, function_1.pipe)(fga, _map(f));
          }
        };
      }
      exports.getFunctorComposition = getFunctorComposition;
    }
  });

  // node_modules/fp-ts/lib/Applicative.js
  var require_Applicative = __commonJS({
    "node_modules/fp-ts/lib/Applicative.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getApplicativeComposition = exports.getApplicativeMonoid = void 0;
      var Apply_1 = require_Apply();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      function getApplicativeMonoid(F) {
        var f = (0, Apply_1.getApplySemigroup)(F);
        return function(M) {
          return {
            concat: f(M).concat,
            empty: F.of(M.empty)
          };
        };
      }
      exports.getApplicativeMonoid = getApplicativeMonoid;
      function getApplicativeComposition(F, G) {
        var map = (0, Functor_1.getFunctorComposition)(F, G).map;
        var _ap = (0, Apply_1.ap)(F, G);
        return {
          map,
          of: function(a) {
            return F.of(G.of(a));
          },
          ap: function(fgab, fga) {
            return (0, function_1.pipe)(fgab, _ap(fga));
          }
        };
      }
      exports.getApplicativeComposition = getApplicativeComposition;
    }
  });

  // node_modules/fp-ts/lib/Chain.js
  var require_Chain = __commonJS({
    "node_modules/fp-ts/lib/Chain.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bind = exports.chainFirst = void 0;
      function chainFirst(M) {
        return function(f) {
          return function(first) {
            return M.chain(first, function(a) {
              return M.map(f(a), function() {
                return a;
              });
            });
          };
        };
      }
      exports.chainFirst = chainFirst;
      function bind(M) {
        return function(name, f) {
          return function(ma) {
            return M.chain(ma, function(a) {
              return M.map(f(a), function(b) {
                var _a;
                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
              });
            });
          };
        };
      }
      exports.bind = bind;
    }
  });

  // node_modules/fp-ts/lib/ChainRec.js
  var require_ChainRec = __commonJS({
    "node_modules/fp-ts/lib/ChainRec.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.tailRec = void 0;
      var tailRec = function(startWith, f) {
        var ab = f(startWith);
        while (ab._tag === "Left") {
          ab = f(ab.left);
        }
        return ab.right;
      };
      exports.tailRec = tailRec;
    }
  });

  // node_modules/fp-ts/lib/FromEither.js
  var require_FromEither = __commonJS({
    "node_modules/fp-ts/lib/FromEither.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.filterOrElse = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromPredicate = exports.fromOption = void 0;
      var Chain_1 = require_Chain();
      var function_1 = require_function();
      var _ = __importStar(require_internal());
      function fromOption(F) {
        return function(onNone) {
          return function(ma) {
            return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value));
          };
        };
      }
      exports.fromOption = fromOption;
      function fromPredicate(F) {
        return function(predicate, onFalse) {
          return function(a) {
            return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
          };
        };
      }
      exports.fromPredicate = fromPredicate;
      function fromOptionK(F) {
        var fromOptionF = fromOption(F);
        return function(onNone) {
          var from = fromOptionF(onNone);
          return function(f) {
            return (0, function_1.flow)(f, from);
          };
        };
      }
      exports.fromOptionK = fromOptionK;
      function chainOptionK(F, M) {
        var fromOptionKF = fromOptionK(F);
        return function(onNone) {
          var from = fromOptionKF(onNone);
          return function(f) {
            return function(ma) {
              return M.chain(ma, from(f));
            };
          };
        };
      }
      exports.chainOptionK = chainOptionK;
      function fromEitherK(F) {
        return function(f) {
          return (0, function_1.flow)(f, F.fromEither);
        };
      }
      exports.fromEitherK = fromEitherK;
      function chainEitherK(F, M) {
        var fromEitherKF = fromEitherK(F);
        return function(f) {
          return function(ma) {
            return M.chain(ma, fromEitherKF(f));
          };
        };
      }
      exports.chainEitherK = chainEitherK;
      function chainFirstEitherK(F, M) {
        return (0, function_1.flow)(fromEitherK(F), (0, Chain_1.chainFirst)(M));
      }
      exports.chainFirstEitherK = chainFirstEitherK;
      function filterOrElse(F, M) {
        return function(predicate, onFalse) {
          return function(ma) {
            return M.chain(ma, function(a) {
              return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
            });
          };
        };
      }
      exports.filterOrElse = filterOrElse;
    }
  });

  // node_modules/fp-ts/lib/Separated.js
  var require_Separated = __commonJS({
    "node_modules/fp-ts/lib/Separated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.right = exports.left = exports.flap = exports.Functor = exports.Bifunctor = exports.URI = exports.bimap = exports.mapLeft = exports.map = exports.separated = void 0;
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var separated = function(left2, right2) {
        return { left: left2, right: right2 };
      };
      exports.separated = separated;
      var _map = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f));
      };
      var _mapLeft = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f));
      };
      var _bimap = function(fa, g, f) {
        return (0, function_1.pipe)(fa, (0, exports.bimap)(g, f));
      };
      var map = function(f) {
        return function(fa) {
          return (0, exports.separated)((0, exports.left)(fa), f((0, exports.right)(fa)));
        };
      };
      exports.map = map;
      var mapLeft = function(f) {
        return function(fa) {
          return (0, exports.separated)(f((0, exports.left)(fa)), (0, exports.right)(fa));
        };
      };
      exports.mapLeft = mapLeft;
      var bimap = function(f, g) {
        return function(fa) {
          return (0, exports.separated)(f((0, exports.left)(fa)), g((0, exports.right)(fa)));
        };
      };
      exports.bimap = bimap;
      exports.URI = "Separated";
      exports.Bifunctor = {
        URI: exports.URI,
        mapLeft: _mapLeft,
        bimap: _bimap
      };
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      var left = function(s) {
        return s.left;
      };
      exports.left = left;
      var right = function(s) {
        return s.right;
      };
      exports.right = right;
    }
  });

  // node_modules/fp-ts/lib/Witherable.js
  var require_Witherable = __commonJS({
    "node_modules/fp-ts/lib/Witherable.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.filterE = exports.witherDefault = exports.wiltDefault = void 0;
      var _ = __importStar(require_internal());
      function wiltDefault(T, C) {
        return function(F) {
          var traverseF = T.traverse(F);
          return function(wa, f) {
            return F.map(traverseF(wa, f), C.separate);
          };
        };
      }
      exports.wiltDefault = wiltDefault;
      function witherDefault(T, C) {
        return function(F) {
          var traverseF = T.traverse(F);
          return function(wa, f) {
            return F.map(traverseF(wa, f), C.compact);
          };
        };
      }
      exports.witherDefault = witherDefault;
      function filterE(W) {
        return function(F) {
          var witherF = W.wither(F);
          return function(predicate) {
            return function(ga) {
              return witherF(ga, function(a) {
                return F.map(predicate(a), function(b) {
                  return b ? _.some(a) : _.none;
                });
              });
            };
          };
        };
      }
      exports.filterE = filterE;
    }
  });

  // node_modules/fp-ts/lib/Either.js
  var require_Either = __commonJS({
    "node_modules/fp-ts/lib/Either.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fold = exports.match = exports.foldW = exports.matchW = exports.isRight = exports.isLeft = exports.fromOption = exports.fromPredicate = exports.FromEither = exports.MonadThrow = exports.throwError = exports.ChainRec = exports.Extend = exports.extend = exports.Alt = exports.alt = exports.altW = exports.Bifunctor = exports.mapLeft = exports.bimap = exports.Traversable = exports.sequence = exports.traverse = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.chain = exports.chainW = exports.Applicative = exports.Apply = exports.ap = exports.apW = exports.Pointed = exports.of = exports.Functor = exports.map = exports.getAltValidation = exports.getApplicativeValidation = exports.getWitherable = exports.getFilterable = exports.getCompactable = exports.getSemigroup = exports.getEq = exports.getShow = exports.URI = exports.right = exports.left = void 0;
      exports.getValidation = exports.getValidationMonoid = exports.getValidationSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.either = exports.stringifyJSON = exports.parseJSON = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toError = exports.toUnion = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.orElse = exports.orElseW = exports.swap = exports.filterOrElseW = exports.filterOrElse = exports.chainOptionK = exports.fromOptionK = exports.duplicate = exports.flatten = exports.flattenW = exports.chainFirstW = exports.chainFirst = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = void 0;
      var Applicative_1 = require_Applicative();
      var Apply_1 = require_Apply();
      var Chain_1 = require_Chain();
      var ChainRec_1 = require_ChainRec();
      var FromEither_1 = require_FromEither();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar(require_internal());
      var Separated_1 = require_Separated();
      var Witherable_1 = require_Witherable();
      exports.left = _.left;
      exports.right = _.right;
      var _map = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f));
      };
      var _ap = function(fab, fa) {
        return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
      };
      var _chain = function(ma, f) {
        return (0, function_1.pipe)(ma, (0, exports.chain)(f));
      };
      var _reduce = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f));
      };
      var _foldMap = function(M) {
        return function(fa, f) {
          var foldMapM = (0, exports.foldMap)(M);
          return (0, function_1.pipe)(fa, foldMapM(f));
        };
      };
      var _reduceRight = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f));
      };
      var _traverse = function(F) {
        var traverseF = (0, exports.traverse)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseF(f));
        };
      };
      var _bimap = function(fa, f, g) {
        return (0, function_1.pipe)(fa, (0, exports.bimap)(f, g));
      };
      var _mapLeft = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f));
      };
      var _alt = function(fa, that) {
        return (0, function_1.pipe)(fa, (0, exports.alt)(that));
      };
      var _extend = function(wa, f) {
        return (0, function_1.pipe)(wa, (0, exports.extend)(f));
      };
      var _chainRec = function(a, f) {
        return (0, ChainRec_1.tailRec)(f(a), function(e) {
          return (0, exports.isLeft)(e) ? (0, exports.right)((0, exports.left)(e.left)) : (0, exports.isLeft)(e.right) ? (0, exports.left)(f(e.right.left)) : (0, exports.right)((0, exports.right)(e.right.right));
        });
      };
      exports.URI = "Either";
      var getShow = function(SE, SA) {
        return {
          show: function(ma) {
            return (0, exports.isLeft)(ma) ? "left(".concat(SE.show(ma.left), ")") : "right(".concat(SA.show(ma.right), ")");
          }
        };
      };
      exports.getShow = getShow;
      var getEq = function(EL, EA) {
        return {
          equals: function(x, y) {
            return x === y || ((0, exports.isLeft)(x) ? (0, exports.isLeft)(y) && EL.equals(x.left, y.left) : (0, exports.isRight)(y) && EA.equals(x.right, y.right));
          }
        };
      };
      exports.getEq = getEq;
      var getSemigroup = function(S) {
        return {
          concat: function(x, y) {
            return (0, exports.isLeft)(y) ? x : (0, exports.isLeft)(x) ? y : (0, exports.right)(S.concat(x.right, y.right));
          }
        };
      };
      exports.getSemigroup = getSemigroup;
      var getCompactable = function(M) {
        var empty = (0, exports.left)(M.empty);
        return {
          URI: exports.URI,
          _E: void 0,
          compact: function(ma) {
            return (0, exports.isLeft)(ma) ? ma : ma.right._tag === "None" ? empty : (0, exports.right)(ma.right.value);
          },
          separate: function(ma) {
            return (0, exports.isLeft)(ma) ? (0, Separated_1.separated)(ma, ma) : (0, exports.isLeft)(ma.right) ? (0, Separated_1.separated)((0, exports.right)(ma.right.left), empty) : (0, Separated_1.separated)(empty, (0, exports.right)(ma.right.right));
          }
        };
      };
      exports.getCompactable = getCompactable;
      var getFilterable = function(M) {
        var empty = (0, exports.left)(M.empty);
        var _a = (0, exports.getCompactable)(M), compact = _a.compact, separate = _a.separate;
        var filter = function(ma, predicate) {
          return (0, exports.isLeft)(ma) ? ma : predicate(ma.right) ? ma : empty;
        };
        var partition = function(ma, p) {
          return (0, exports.isLeft)(ma) ? (0, Separated_1.separated)(ma, ma) : p(ma.right) ? (0, Separated_1.separated)(empty, (0, exports.right)(ma.right)) : (0, Separated_1.separated)((0, exports.right)(ma.right), empty);
        };
        return {
          URI: exports.URI,
          _E: void 0,
          map: _map,
          compact,
          separate,
          filter,
          filterMap: function(ma, f) {
            if ((0, exports.isLeft)(ma)) {
              return ma;
            }
            var ob = f(ma.right);
            return ob._tag === "None" ? empty : (0, exports.right)(ob.value);
          },
          partition,
          partitionMap: function(ma, f) {
            if ((0, exports.isLeft)(ma)) {
              return (0, Separated_1.separated)(ma, ma);
            }
            var e = f(ma.right);
            return (0, exports.isLeft)(e) ? (0, Separated_1.separated)((0, exports.right)(e.left), empty) : (0, Separated_1.separated)(empty, (0, exports.right)(e.right));
          }
        };
      };
      exports.getFilterable = getFilterable;
      var getWitherable = function(M) {
        var F_ = (0, exports.getFilterable)(M);
        var C = (0, exports.getCompactable)(M);
        return {
          URI: exports.URI,
          _E: void 0,
          map: _map,
          compact: F_.compact,
          separate: F_.separate,
          filter: F_.filter,
          filterMap: F_.filterMap,
          partition: F_.partition,
          partitionMap: F_.partitionMap,
          traverse: _traverse,
          sequence: exports.sequence,
          reduce: _reduce,
          foldMap: _foldMap,
          reduceRight: _reduceRight,
          wither: (0, Witherable_1.witherDefault)(exports.Traversable, C),
          wilt: (0, Witherable_1.wiltDefault)(exports.Traversable, C)
        };
      };
      exports.getWitherable = getWitherable;
      var getApplicativeValidation = function(SE) {
        return {
          URI: exports.URI,
          _E: void 0,
          map: _map,
          ap: function(fab, fa) {
            return (0, exports.isLeft)(fab) ? (0, exports.isLeft)(fa) ? (0, exports.left)(SE.concat(fab.left, fa.left)) : fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
          },
          of: exports.of
        };
      };
      exports.getApplicativeValidation = getApplicativeValidation;
      var getAltValidation = function(SE) {
        return {
          URI: exports.URI,
          _E: void 0,
          map: _map,
          alt: function(me, that) {
            if ((0, exports.isRight)(me)) {
              return me;
            }
            var ea = that();
            return (0, exports.isLeft)(ea) ? (0, exports.left)(SE.concat(me.left, ea.left)) : ea;
          }
        };
      };
      exports.getAltValidation = getAltValidation;
      var map = function(f) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? fa : (0, exports.right)(f(fa.right));
        };
      };
      exports.map = map;
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.of = exports.right;
      exports.Pointed = {
        URI: exports.URI,
        of: exports.of
      };
      var apW = function(fa) {
        return function(fab) {
          return (0, exports.isLeft)(fab) ? fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
        };
      };
      exports.apW = apW;
      exports.ap = exports.apW;
      exports.Apply = {
        URI: exports.URI,
        map: _map,
        ap: _ap
      };
      exports.Applicative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of
      };
      var chainW = function(f) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? ma : f(ma.right);
        };
      };
      exports.chainW = chainW;
      exports.chain = exports.chainW;
      exports.Chain = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain
      };
      exports.Monad = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain
      };
      var reduce = function(b, f) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? b : f(b, fa.right);
        };
      };
      exports.reduce = reduce;
      var foldMap = function(M) {
        return function(f) {
          return function(fa) {
            return (0, exports.isLeft)(fa) ? M.empty : f(fa.right);
          };
        };
      };
      exports.foldMap = foldMap;
      var reduceRight = function(b, f) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? b : f(fa.right, b);
        };
      };
      exports.reduceRight = reduceRight;
      exports.Foldable = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight
      };
      var traverse = function(F) {
        return function(f) {
          return function(ta) {
            return (0, exports.isLeft)(ta) ? F.of((0, exports.left)(ta.left)) : F.map(f(ta.right), exports.right);
          };
        };
      };
      exports.traverse = traverse;
      var sequence = function(F) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? F.of((0, exports.left)(ma.left)) : F.map(ma.right, exports.right);
        };
      };
      exports.sequence = sequence;
      exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence
      };
      var bimap = function(f, g) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : (0, exports.right)(g(fa.right));
        };
      };
      exports.bimap = bimap;
      var mapLeft = function(f) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : fa;
        };
      };
      exports.mapLeft = mapLeft;
      exports.Bifunctor = {
        URI: exports.URI,
        bimap: _bimap,
        mapLeft: _mapLeft
      };
      var altW = function(that) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? that() : fa;
        };
      };
      exports.altW = altW;
      exports.alt = exports.altW;
      exports.Alt = {
        URI: exports.URI,
        map: _map,
        alt: _alt
      };
      var extend = function(f) {
        return function(wa) {
          return (0, exports.isLeft)(wa) ? wa : (0, exports.right)(f(wa));
        };
      };
      exports.extend = extend;
      exports.Extend = {
        URI: exports.URI,
        map: _map,
        extend: _extend
      };
      exports.ChainRec = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain,
        chainRec: _chainRec
      };
      exports.throwError = exports.left;
      exports.MonadThrow = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain,
        throwError: exports.throwError
      };
      exports.FromEither = {
        URI: exports.URI,
        fromEither: function_1.identity
      };
      exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
      exports.fromOption = /* @__PURE__ */ (0, FromEither_1.fromOption)(exports.FromEither);
      exports.isLeft = _.isLeft;
      exports.isRight = _.isRight;
      var matchW = function(onLeft, onRight) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? onLeft(ma.left) : onRight(ma.right);
        };
      };
      exports.matchW = matchW;
      exports.foldW = exports.matchW;
      exports.match = exports.matchW;
      exports.fold = exports.match;
      var getOrElseW = function(onLeft) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma.right;
        };
      };
      exports.getOrElseW = getOrElseW;
      exports.getOrElse = exports.getOrElseW;
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
      exports.apFirstW = exports.apFirst;
      exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
      exports.apSecondW = exports.apSecond;
      exports.chainFirst = /* @__PURE__ */ (0, Chain_1.chainFirst)(exports.Chain);
      exports.chainFirstW = exports.chainFirst;
      exports.flattenW = /* @__PURE__ */ (0, exports.chainW)(function_1.identity);
      exports.flatten = exports.flattenW;
      exports.duplicate = (0, exports.extend)(function_1.identity);
      exports.fromOptionK = /* @__PURE__ */ (0, FromEither_1.fromOptionK)(exports.FromEither);
      exports.chainOptionK = (0, FromEither_1.chainOptionK)(exports.FromEither, exports.Chain);
      exports.filterOrElse = (0, FromEither_1.filterOrElse)(exports.FromEither, exports.Chain);
      exports.filterOrElseW = exports.filterOrElse;
      var swap = function(ma) {
        return (0, exports.isLeft)(ma) ? (0, exports.right)(ma.left) : (0, exports.left)(ma.right);
      };
      exports.swap = swap;
      var orElseW = function(onLeft) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma;
        };
      };
      exports.orElseW = orElseW;
      exports.orElse = exports.orElseW;
      var fromNullable = function(e) {
        return function(a) {
          return a == null ? (0, exports.left)(e) : (0, exports.right)(a);
        };
      };
      exports.fromNullable = fromNullable;
      var tryCatch = function(f, onThrow) {
        try {
          return (0, exports.right)(f());
        } catch (e) {
          return (0, exports.left)(onThrow(e));
        }
      };
      exports.tryCatch = tryCatch;
      var tryCatchK = function(f, onThrow) {
        return function() {
          var a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
          }
          return (0, exports.tryCatch)(function() {
            return f.apply(void 0, a);
          }, onThrow);
        };
      };
      exports.tryCatchK = tryCatchK;
      var fromNullableK = function(e) {
        var from = (0, exports.fromNullable)(e);
        return function(f) {
          return (0, function_1.flow)(f, from);
        };
      };
      exports.fromNullableK = fromNullableK;
      var chainNullableK = function(e) {
        var from = (0, exports.fromNullableK)(e);
        return function(f) {
          return (0, exports.chain)(from(f));
        };
      };
      exports.chainNullableK = chainNullableK;
      exports.toUnion = (0, exports.foldW)(function_1.identity, function_1.identity);
      function toError(e) {
        return e instanceof Error ? e : new Error(String(e));
      }
      exports.toError = toError;
      function elem(E) {
        return function(a, ma) {
          if (ma === void 0) {
            var elemE_1 = elem(E);
            return function(ma2) {
              return elemE_1(a, ma2);
            };
          }
          return (0, exports.isLeft)(ma) ? false : E.equals(a, ma.right);
        };
      }
      exports.elem = elem;
      var exists = function(predicate) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? false : predicate(ma.right);
        };
      };
      exports.exists = exists;
      exports.Do = (0, exports.of)(_.emptyRecord);
      exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
      var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
      exports.let = let_;
      exports.bind = (0, Chain_1.bind)(exports.Chain);
      exports.bindW = exports.bind;
      exports.apS = (0, Apply_1.apS)(exports.Apply);
      exports.apSW = exports.apS;
      exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
      var traverseReadonlyNonEmptyArrayWithIndex = function(f) {
        return function(as) {
          var e = f(0, _.head(as));
          if ((0, exports.isLeft)(e)) {
            return e;
          }
          var out = [e.right];
          for (var i = 1; i < as.length; i++) {
            var e_1 = f(i, as[i]);
            if ((0, exports.isLeft)(e_1)) {
              return e_1;
            }
            out.push(e_1.right);
          }
          return (0, exports.right)(out);
        };
      };
      exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
      var traverseReadonlyArrayWithIndex = function(f) {
        var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);
        return function(as) {
          return _.isNonEmpty(as) ? g(as) : exports.ApT;
        };
      };
      exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
      exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
      var traverseArray = function(f) {
        return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.traverseArray = traverseArray;
      exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
      function parseJSON(s, onError) {
        return (0, exports.tryCatch)(function() {
          return JSON.parse(s);
        }, onError);
      }
      exports.parseJSON = parseJSON;
      var stringifyJSON = function(u, onError) {
        return (0, exports.tryCatch)(function() {
          var s = JSON.stringify(u);
          if (typeof s !== "string") {
            throw new Error("Converting unsupported structure to JSON");
          }
          return s;
        }, onError);
      };
      exports.stringifyJSON = stringifyJSON;
      exports.either = {
        URI: exports.URI,
        map: _map,
        of: exports.of,
        ap: _ap,
        chain: _chain,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        bimap: _bimap,
        mapLeft: _mapLeft,
        alt: _alt,
        extend: _extend,
        chainRec: _chainRec,
        throwError: exports.throwError
      };
      exports.getApplySemigroup = /* @__PURE__ */ (0, Apply_1.getApplySemigroup)(exports.Apply);
      exports.getApplyMonoid = /* @__PURE__ */ (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);
      var getValidationSemigroup = function(SE, SA) {
        return (0, Apply_1.getApplySemigroup)((0, exports.getApplicativeValidation)(SE))(SA);
      };
      exports.getValidationSemigroup = getValidationSemigroup;
      var getValidationMonoid = function(SE, MA) {
        return (0, Applicative_1.getApplicativeMonoid)((0, exports.getApplicativeValidation)(SE))(MA);
      };
      exports.getValidationMonoid = getValidationMonoid;
      function getValidation(SE) {
        var ap = (0, exports.getApplicativeValidation)(SE).ap;
        var alt = (0, exports.getAltValidation)(SE).alt;
        return {
          URI: exports.URI,
          _E: void 0,
          map: _map,
          of: exports.of,
          chain: _chain,
          bimap: _bimap,
          mapLeft: _mapLeft,
          reduce: _reduce,
          foldMap: _foldMap,
          reduceRight: _reduceRight,
          extend: _extend,
          traverse: _traverse,
          sequence: exports.sequence,
          chainRec: _chainRec,
          throwError: exports.throwError,
          ap,
          alt
        };
      }
      exports.getValidation = getValidation;
    }
  });

  // node_modules/io-ts/lib/index.js
  var require_lib = __commonJS({
    "node_modules/io-ts/lib/index.js"(exports) {
      "use strict";
      var __extends = exports && exports.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.partial = exports.PartialType = exports.type = exports.InterfaceType = exports.array = exports.ArrayType = exports.recursion = exports.RecursiveType = exports.Int = exports.brand = exports.RefinementType = exports.keyof = exports.KeyofType = exports.literal = exports.LiteralType = exports.void = exports.undefined = exports.null = exports.UnknownRecord = exports.AnyDictionaryType = exports.UnknownArray = exports.AnyArrayType = exports.boolean = exports.BooleanType = exports.bigint = exports.BigIntType = exports.number = exports.NumberType = exports.string = exports.StringType = exports.unknown = exports.UnknownType = exports.voidType = exports.VoidType = exports.UndefinedType = exports.nullType = exports.NullType = exports.getIndex = exports.getTags = exports.emptyTags = exports.mergeAll = exports.getDomainKeys = exports.appendContext = exports.getContextEntry = exports.getFunctionName = exports.identity = exports.Type = exports.success = exports.failure = exports.failures = void 0;
      exports.alias = exports.clean = exports.StrictType = exports.dictionary = exports.Integer = exports.refinement = exports.object = exports.ObjectType = exports.Dictionary = exports.any = exports.AnyType = exports.never = exports.NeverType = exports.getDefaultContext = exports.getValidationError = exports.interface = exports.Array = exports.taggedUnion = exports.TaggedUnionType = exports.Function = exports.FunctionType = exports.exact = exports.ExactType = exports.strict = exports.readonlyArray = exports.ReadonlyArrayType = exports.readonly = exports.ReadonlyType = exports.tuple = exports.TupleType = exports.intersection = exports.IntersectionType = exports.union = exports.UnionType = exports.record = exports.DictionaryType = void 0;
      var Either_1 = require_Either();
      exports.failures = Either_1.left;
      var failure = function(value, context, message) {
        return (0, exports.failures)([{ value, context, message }]);
      };
      exports.failure = failure;
      exports.success = Either_1.right;
      var Type = function() {
        function Type2(name, is, validate, encode) {
          this.name = name;
          this.is = is;
          this.validate = validate;
          this.encode = encode;
          this.decode = this.decode.bind(this);
        }
        Type2.prototype.pipe = function(ab, name) {
          var _this = this;
          if (name === void 0) {
            name = "pipe(".concat(this.name, ", ").concat(ab.name, ")");
          }
          return new Type2(name, ab.is, function(i, c) {
            var e = _this.validate(i, c);
            if ((0, Either_1.isLeft)(e)) {
              return e;
            }
            return ab.validate(e.right, c);
          }, this.encode === exports.identity && ab.encode === exports.identity ? exports.identity : function(b) {
            return _this.encode(ab.encode(b));
          });
        };
        Type2.prototype.asDecoder = function() {
          return this;
        };
        Type2.prototype.asEncoder = function() {
          return this;
        };
        Type2.prototype.decode = function(i) {
          return this.validate(i, [{ key: "", type: this, actual: i }]);
        };
        return Type2;
      }();
      exports.Type = Type;
      var identity = function(a) {
        return a;
      };
      exports.identity = identity;
      function getFunctionName(f) {
        return f.displayName || f.name || "<function".concat(f.length, ">");
      }
      exports.getFunctionName = getFunctionName;
      function getContextEntry(key, decoder) {
        return { key, type: decoder };
      }
      exports.getContextEntry = getContextEntry;
      function appendContext(c, key, decoder, actual) {
        var len = c.length;
        var r = Array(len + 1);
        for (var i = 0; i < len; i++) {
          r[i] = c[i];
        }
        r[len] = { key, type: decoder, actual };
        return r;
      }
      exports.appendContext = appendContext;
      function pushAll(xs, ys) {
        var l = ys.length;
        for (var i = 0; i < l; i++) {
          xs.push(ys[i]);
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function getNameFromProps(props) {
        return Object.keys(props).map(function(k) {
          return "".concat(k, ": ").concat(props[k].name);
        }).join(", ");
      }
      function useIdentity(codecs) {
        for (var i = 0; i < codecs.length; i++) {
          if (codecs[i].encode !== exports.identity) {
            return false;
          }
        }
        return true;
      }
      function getInterfaceTypeName(props) {
        return "{ ".concat(getNameFromProps(props), " }");
      }
      function getPartialTypeName(inner) {
        return "Partial<".concat(inner, ">");
      }
      function enumerableRecord(keys, domain, codomain, name) {
        if (name === void 0) {
          name = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }");
        }
        var len = keys.length;
        return new DictionaryType(name, function(u) {
          return exports.UnknownRecord.is(u) && keys.every(function(k) {
            return codomain.is(u[k]);
          });
        }, function(u, c) {
          var e = exports.UnknownRecord.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var o = e.right;
          var a = {};
          var errors = [];
          var changed = false;
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            var ok = o[k];
            var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
            if ((0, Either_1.isLeft)(codomainResult)) {
              pushAll(errors, codomainResult.left);
            } else {
              var vok = codomainResult.right;
              changed = changed || vok !== ok;
              a[k] = vok;
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(changed || Object.keys(o).length !== len ? a : o);
        }, codomain.encode === exports.identity ? exports.identity : function(a) {
          var s = {};
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            s[k] = codomain.encode(a[k]);
          }
          return s;
        }, domain, codomain);
      }
      function getDomainKeys(domain) {
        var _a;
        if (isLiteralC(domain)) {
          var literal_1 = domain.value;
          if (exports.string.is(literal_1)) {
            return _a = {}, _a[literal_1] = null, _a;
          }
        } else if (isKeyofC(domain)) {
          return domain.keys;
        } else if (isUnionC(domain)) {
          var keys = domain.types.map(function(type2) {
            return getDomainKeys(type2);
          });
          return keys.some(undefinedType.is) ? void 0 : Object.assign.apply(Object, __spreadArray([{}], keys, false));
        }
        return void 0;
      }
      exports.getDomainKeys = getDomainKeys;
      function nonEnumerableRecord(domain, codomain, name) {
        if (name === void 0) {
          name = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }");
        }
        return new DictionaryType(name, function(u) {
          if (exports.UnknownRecord.is(u)) {
            return Object.keys(u).every(function(k) {
              return domain.is(k) && codomain.is(u[k]);
            });
          }
          return isAnyC(codomain) && Array.isArray(u);
        }, function(u, c) {
          if (exports.UnknownRecord.is(u)) {
            var a = {};
            var errors = [];
            var keys = Object.keys(u);
            var len = keys.length;
            var changed = false;
            for (var i = 0; i < len; i++) {
              var k = keys[i];
              var ok = u[k];
              var domainResult = domain.validate(k, appendContext(c, k, domain, k));
              if ((0, Either_1.isLeft)(domainResult)) {
                pushAll(errors, domainResult.left);
              } else {
                var vk = domainResult.right;
                changed = changed || vk !== k;
                k = vk;
                var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
                if ((0, Either_1.isLeft)(codomainResult)) {
                  pushAll(errors, codomainResult.left);
                } else {
                  var vok = codomainResult.right;
                  changed = changed || vok !== ok;
                  a[k] = vok;
                }
              }
            }
            return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(changed ? a : u);
          }
          if (isAnyC(codomain) && Array.isArray(u)) {
            return (0, exports.success)(u);
          }
          return (0, exports.failure)(u, c);
        }, domain.encode === exports.identity && codomain.encode === exports.identity ? exports.identity : function(a) {
          var s = {};
          var keys = Object.keys(a);
          var len = keys.length;
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            s[String(domain.encode(k))] = codomain.encode(a[k]);
          }
          return s;
        }, domain, codomain);
      }
      function getUnionName(codecs) {
        return "(" + codecs.map(function(type2) {
          return type2.name;
        }).join(" | ") + ")";
      }
      function mergeAll(base, us) {
        var equal = true;
        var primitive = true;
        var baseIsNotADictionary = !exports.UnknownRecord.is(base);
        for (var _i = 0, us_1 = us; _i < us_1.length; _i++) {
          var u = us_1[_i];
          if (u !== base) {
            equal = false;
          }
          if (exports.UnknownRecord.is(u)) {
            primitive = false;
          }
        }
        if (equal) {
          return base;
        } else if (primitive) {
          return us[us.length - 1];
        }
        var r = {};
        for (var _a = 0, us_2 = us; _a < us_2.length; _a++) {
          var u = us_2[_a];
          for (var k in u) {
            if (!hasOwnProperty.call(r, k) || baseIsNotADictionary || u[k] !== base[k]) {
              r[k] = u[k];
            }
          }
        }
        return r;
      }
      exports.mergeAll = mergeAll;
      function getProps(codec) {
        switch (codec._tag) {
          case "RefinementType":
          case "ReadonlyType":
            return getProps(codec.type);
          case "InterfaceType":
          case "StrictType":
          case "PartialType":
            return codec.props;
          case "IntersectionType":
            return codec.types.reduce(function(props, type2) {
              return Object.assign(props, getProps(type2));
            }, {});
        }
      }
      function stripKeys(o, props) {
        var keys = Object.getOwnPropertyNames(o);
        var shouldStrip = false;
        var r = {};
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (!hasOwnProperty.call(props, key)) {
            shouldStrip = true;
          } else {
            r[key] = o[key];
          }
        }
        return shouldStrip ? r : o;
      }
      function getExactTypeName(codec) {
        if (isTypeC(codec)) {
          return "{| ".concat(getNameFromProps(codec.props), " |}");
        } else if (isPartialC(codec)) {
          return getPartialTypeName("{| ".concat(getNameFromProps(codec.props), " |}"));
        }
        return "Exact<".concat(codec.name, ">");
      }
      function isNonEmpty(as) {
        return as.length > 0;
      }
      exports.emptyTags = {};
      function intersect(a, b) {
        var r = [];
        for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
          var v = a_1[_i];
          if (b.indexOf(v) !== -1) {
            r.push(v);
          }
        }
        return r;
      }
      function mergeTags(a, b) {
        if (a === exports.emptyTags) {
          return b;
        }
        if (b === exports.emptyTags) {
          return a;
        }
        var r = Object.assign({}, a);
        for (var k in b) {
          if (hasOwnProperty.call(a, k)) {
            var intersection_1 = intersect(a[k], b[k]);
            if (isNonEmpty(intersection_1)) {
              r[k] = intersection_1;
            } else {
              r = exports.emptyTags;
              break;
            }
          } else {
            r[k] = b[k];
          }
        }
        return r;
      }
      function intersectTags(a, b) {
        if (a === exports.emptyTags || b === exports.emptyTags) {
          return exports.emptyTags;
        }
        var r = exports.emptyTags;
        for (var k in a) {
          if (hasOwnProperty.call(b, k)) {
            var intersection_2 = intersect(a[k], b[k]);
            if (intersection_2.length === 0) {
              if (r === exports.emptyTags) {
                r = {};
              }
              r[k] = a[k].concat(b[k]);
            }
          }
        }
        return r;
      }
      function isAnyC(codec) {
        return codec._tag === "AnyType";
      }
      function isLiteralC(codec) {
        return codec._tag === "LiteralType";
      }
      function isKeyofC(codec) {
        return codec._tag === "KeyofType";
      }
      function isTypeC(codec) {
        return codec._tag === "InterfaceType";
      }
      function isPartialC(codec) {
        return codec._tag === "PartialType";
      }
      function isStrictC(codec) {
        return codec._tag === "StrictType";
      }
      function isExactC(codec) {
        return codec._tag === "ExactType";
      }
      function isRefinementC(codec) {
        return codec._tag === "RefinementType";
      }
      function isIntersectionC(codec) {
        return codec._tag === "IntersectionType";
      }
      function isUnionC(codec) {
        return codec._tag === "UnionType";
      }
      function isRecursiveC(codec) {
        return codec._tag === "RecursiveType";
      }
      var lazyCodecs = [];
      function getTags(codec) {
        if (lazyCodecs.indexOf(codec) !== -1) {
          return exports.emptyTags;
        }
        if (isTypeC(codec) || isStrictC(codec)) {
          var index = exports.emptyTags;
          for (var k in codec.props) {
            var prop = codec.props[k];
            if (isLiteralC(prop)) {
              if (index === exports.emptyTags) {
                index = {};
              }
              index[k] = [prop.value];
            }
          }
          return index;
        } else if (isExactC(codec) || isRefinementC(codec)) {
          return getTags(codec.type);
        } else if (isIntersectionC(codec)) {
          return codec.types.reduce(function(tags2, codec2) {
            return mergeTags(tags2, getTags(codec2));
          }, exports.emptyTags);
        } else if (isUnionC(codec)) {
          return codec.types.slice(1).reduce(function(tags2, codec2) {
            return intersectTags(tags2, getTags(codec2));
          }, getTags(codec.types[0]));
        } else if (isRecursiveC(codec)) {
          lazyCodecs.push(codec);
          var tags = getTags(codec.type);
          lazyCodecs.pop();
          return tags;
        }
        return exports.emptyTags;
      }
      exports.getTags = getTags;
      function getIndex(codecs) {
        var tags = getTags(codecs[0]);
        var keys = Object.keys(tags);
        var len = codecs.length;
        var _loop_1 = function(k2) {
          var all = tags[k2].slice();
          var index = [tags[k2]];
          for (var i = 1; i < len; i++) {
            var codec = codecs[i];
            var ctags = getTags(codec);
            var values = ctags[k2];
            if (values === void 0) {
              return "continue-keys";
            } else {
              if (values.some(function(v) {
                return all.indexOf(v) !== -1;
              })) {
                return "continue-keys";
              } else {
                all.push.apply(all, values);
                index.push(values);
              }
            }
          }
          return { value: [k2, index] };
        };
        keys:
          for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var k = keys_1[_i];
            var state_1 = _loop_1(k);
            if (typeof state_1 === "object")
              return state_1.value;
            switch (state_1) {
              case "continue-keys":
                continue keys;
            }
          }
        return void 0;
      }
      exports.getIndex = getIndex;
      var NullType = function(_super) {
        __extends(NullType2, _super);
        function NullType2() {
          var _this = _super.call(this, "null", function(u) {
            return u === null;
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "NullType";
          return _this;
        }
        return NullType2;
      }(Type);
      exports.NullType = NullType;
      exports.nullType = new NullType();
      exports.null = exports.nullType;
      var UndefinedType = function(_super) {
        __extends(UndefinedType2, _super);
        function UndefinedType2() {
          var _this = _super.call(this, "undefined", function(u) {
            return u === void 0;
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "UndefinedType";
          return _this;
        }
        return UndefinedType2;
      }(Type);
      exports.UndefinedType = UndefinedType;
      var undefinedType = new UndefinedType();
      exports.undefined = undefinedType;
      var VoidType = function(_super) {
        __extends(VoidType2, _super);
        function VoidType2() {
          var _this = _super.call(this, "void", undefinedType.is, undefinedType.validate, exports.identity) || this;
          _this._tag = "VoidType";
          return _this;
        }
        return VoidType2;
      }(Type);
      exports.VoidType = VoidType;
      exports.voidType = new VoidType();
      exports.void = exports.voidType;
      var UnknownType = function(_super) {
        __extends(UnknownType2, _super);
        function UnknownType2() {
          var _this = _super.call(this, "unknown", function(_) {
            return true;
          }, exports.success, exports.identity) || this;
          _this._tag = "UnknownType";
          return _this;
        }
        return UnknownType2;
      }(Type);
      exports.UnknownType = UnknownType;
      exports.unknown = new UnknownType();
      var StringType = function(_super) {
        __extends(StringType2, _super);
        function StringType2() {
          var _this = _super.call(this, "string", function(u) {
            return typeof u === "string";
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "StringType";
          return _this;
        }
        return StringType2;
      }(Type);
      exports.StringType = StringType;
      exports.string = new StringType();
      var NumberType = function(_super) {
        __extends(NumberType2, _super);
        function NumberType2() {
          var _this = _super.call(this, "number", function(u) {
            return typeof u === "number";
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "NumberType";
          return _this;
        }
        return NumberType2;
      }(Type);
      exports.NumberType = NumberType;
      exports.number = new NumberType();
      var BigIntType = function(_super) {
        __extends(BigIntType2, _super);
        function BigIntType2() {
          var _this = _super.call(
            this,
            "bigint",
            function(u) {
              return typeof u === "bigint";
            },
            function(u, c) {
              return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
            },
            exports.identity
          ) || this;
          _this._tag = "BigIntType";
          return _this;
        }
        return BigIntType2;
      }(Type);
      exports.BigIntType = BigIntType;
      exports.bigint = new BigIntType();
      var BooleanType = function(_super) {
        __extends(BooleanType2, _super);
        function BooleanType2() {
          var _this = _super.call(this, "boolean", function(u) {
            return typeof u === "boolean";
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "BooleanType";
          return _this;
        }
        return BooleanType2;
      }(Type);
      exports.BooleanType = BooleanType;
      exports.boolean = new BooleanType();
      var AnyArrayType = function(_super) {
        __extends(AnyArrayType2, _super);
        function AnyArrayType2() {
          var _this = _super.call(this, "UnknownArray", Array.isArray, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "AnyArrayType";
          return _this;
        }
        return AnyArrayType2;
      }(Type);
      exports.AnyArrayType = AnyArrayType;
      exports.UnknownArray = new AnyArrayType();
      exports.Array = exports.UnknownArray;
      var AnyDictionaryType = function(_super) {
        __extends(AnyDictionaryType2, _super);
        function AnyDictionaryType2() {
          var _this = _super.call(this, "UnknownRecord", function(u) {
            return u !== null && typeof u === "object" && !Array.isArray(u);
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "AnyDictionaryType";
          return _this;
        }
        return AnyDictionaryType2;
      }(Type);
      exports.AnyDictionaryType = AnyDictionaryType;
      exports.UnknownRecord = new AnyDictionaryType();
      var LiteralType = function(_super) {
        __extends(LiteralType2, _super);
        function LiteralType2(name, is, validate, encode, value) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.value = value;
          _this._tag = "LiteralType";
          return _this;
        }
        return LiteralType2;
      }(Type);
      exports.LiteralType = LiteralType;
      function literal(value, name) {
        if (name === void 0) {
          name = JSON.stringify(value);
        }
        var is = function(u) {
          return u === value;
        };
        return new LiteralType(name, is, function(u, c) {
          return is(u) ? (0, exports.success)(value) : (0, exports.failure)(u, c);
        }, exports.identity, value);
      }
      exports.literal = literal;
      var KeyofType = function(_super) {
        __extends(KeyofType2, _super);
        function KeyofType2(name, is, validate, encode, keys) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.keys = keys;
          _this._tag = "KeyofType";
          return _this;
        }
        return KeyofType2;
      }(Type);
      exports.KeyofType = KeyofType;
      function keyof(keys, name) {
        if (name === void 0) {
          name = Object.keys(keys).map(function(k) {
            return JSON.stringify(k);
          }).join(" | ");
        }
        var is = function(u) {
          return exports.string.is(u) && hasOwnProperty.call(keys, u);
        };
        return new KeyofType(name, is, function(u, c) {
          return is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
        }, exports.identity, keys);
      }
      exports.keyof = keyof;
      var RefinementType = function(_super) {
        __extends(RefinementType2, _super);
        function RefinementType2(name, is, validate, encode, type2, predicate) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type2;
          _this.predicate = predicate;
          _this._tag = "RefinementType";
          return _this;
        }
        return RefinementType2;
      }(Type);
      exports.RefinementType = RefinementType;
      function brand(codec, predicate, name) {
        return refinement(codec, predicate, name);
      }
      exports.brand = brand;
      exports.Int = brand(exports.number, function(n) {
        return Number.isInteger(n);
      }, "Int");
      var RecursiveType = function(_super) {
        __extends(RecursiveType2, _super);
        function RecursiveType2(name, is, validate, encode, runDefinition) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.runDefinition = runDefinition;
          _this._tag = "RecursiveType";
          return _this;
        }
        return RecursiveType2;
      }(Type);
      exports.RecursiveType = RecursiveType;
      Object.defineProperty(RecursiveType.prototype, "type", {
        get: function() {
          return this.runDefinition();
        },
        enumerable: true,
        configurable: true
      });
      function recursion(name, definition) {
        var cache;
        var runDefinition = function() {
          if (!cache) {
            cache = definition(Self);
            cache.name = name;
          }
          return cache;
        };
        var Self = new RecursiveType(name, function(u) {
          return runDefinition().is(u);
        }, function(u, c) {
          return runDefinition().validate(u, c);
        }, function(a) {
          return runDefinition().encode(a);
        }, runDefinition);
        return Self;
      }
      exports.recursion = recursion;
      var ArrayType = function(_super) {
        __extends(ArrayType2, _super);
        function ArrayType2(name, is, validate, encode, type2) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type2;
          _this._tag = "ArrayType";
          return _this;
        }
        return ArrayType2;
      }(Type);
      exports.ArrayType = ArrayType;
      function array(item, name) {
        if (name === void 0) {
          name = "Array<".concat(item.name, ">");
        }
        return new ArrayType(name, function(u) {
          return exports.UnknownArray.is(u) && u.every(item.is);
        }, function(u, c) {
          var e = exports.UnknownArray.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var us = e.right;
          var len = us.length;
          var as = us;
          var errors = [];
          for (var i = 0; i < len; i++) {
            var ui = us[i];
            var result = item.validate(ui, appendContext(c, String(i), item, ui));
            if ((0, Either_1.isLeft)(result)) {
              pushAll(errors, result.left);
            } else {
              var ai = result.right;
              if (ai !== ui) {
                if (as === us) {
                  as = us.slice();
                }
                as[i] = ai;
              }
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(as);
        }, item.encode === exports.identity ? exports.identity : function(a) {
          return a.map(item.encode);
        }, item);
      }
      exports.array = array;
      var InterfaceType = function(_super) {
        __extends(InterfaceType2, _super);
        function InterfaceType2(name, is, validate, encode, props) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.props = props;
          _this._tag = "InterfaceType";
          return _this;
        }
        return InterfaceType2;
      }(Type);
      exports.InterfaceType = InterfaceType;
      function type(props, name) {
        if (name === void 0) {
          name = getInterfaceTypeName(props);
        }
        var keys = Object.keys(props);
        var types = keys.map(function(key) {
          return props[key];
        });
        var len = keys.length;
        return new InterfaceType(name, function(u) {
          if (exports.UnknownRecord.is(u)) {
            for (var i = 0; i < len; i++) {
              var k = keys[i];
              var uk = u[k];
              if (uk === void 0 && !hasOwnProperty.call(u, k) || !types[i].is(uk)) {
                return false;
              }
            }
            return true;
          }
          return false;
        }, function(u, c) {
          var e = exports.UnknownRecord.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var o = e.right;
          var a = o;
          var errors = [];
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            var ak = a[k];
            var type_1 = types[i];
            var result = type_1.validate(ak, appendContext(c, k, type_1, ak));
            if ((0, Either_1.isLeft)(result)) {
              pushAll(errors, result.left);
            } else {
              var vak = result.right;
              if (vak !== ak || vak === void 0 && !hasOwnProperty.call(a, k)) {
                if (a === o) {
                  a = __assign({}, o);
                }
                a[k] = vak;
              }
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(a);
        }, useIdentity(types) ? exports.identity : function(a) {
          var s = __assign({}, a);
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            var encode = types[i].encode;
            if (encode !== exports.identity) {
              s[k] = encode(a[k]);
            }
          }
          return s;
        }, props);
      }
      exports.type = type;
      exports.interface = type;
      var PartialType = function(_super) {
        __extends(PartialType2, _super);
        function PartialType2(name, is, validate, encode, props) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.props = props;
          _this._tag = "PartialType";
          return _this;
        }
        return PartialType2;
      }(Type);
      exports.PartialType = PartialType;
      function partial(props, name) {
        if (name === void 0) {
          name = getPartialTypeName(getInterfaceTypeName(props));
        }
        var keys = Object.keys(props);
        var types = keys.map(function(key) {
          return props[key];
        });
        var len = keys.length;
        return new PartialType(name, function(u) {
          if (exports.UnknownRecord.is(u)) {
            for (var i = 0; i < len; i++) {
              var k = keys[i];
              var uk = u[k];
              if (uk !== void 0 && !props[k].is(uk)) {
                return false;
              }
            }
            return true;
          }
          return false;
        }, function(u, c) {
          var e = exports.UnknownRecord.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var o = e.right;
          var a = o;
          var errors = [];
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            var ak = a[k];
            var type_2 = props[k];
            var result = type_2.validate(ak, appendContext(c, k, type_2, ak));
            if ((0, Either_1.isLeft)(result)) {
              if (ak !== void 0) {
                pushAll(errors, result.left);
              }
            } else {
              var vak = result.right;
              if (vak !== ak) {
                if (a === o) {
                  a = __assign({}, o);
                }
                a[k] = vak;
              }
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(a);
        }, useIdentity(types) ? exports.identity : function(a) {
          var s = __assign({}, a);
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            var ak = a[k];
            if (ak !== void 0) {
              s[k] = types[i].encode(ak);
            }
          }
          return s;
        }, props);
      }
      exports.partial = partial;
      var DictionaryType = function(_super) {
        __extends(DictionaryType2, _super);
        function DictionaryType2(name, is, validate, encode, domain, codomain) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.domain = domain;
          _this.codomain = codomain;
          _this._tag = "DictionaryType";
          return _this;
        }
        return DictionaryType2;
      }(Type);
      exports.DictionaryType = DictionaryType;
      function record(domain, codomain, name) {
        var keys = getDomainKeys(domain);
        return keys ? enumerableRecord(Object.keys(keys), domain, codomain, name) : nonEnumerableRecord(domain, codomain, name);
      }
      exports.record = record;
      var UnionType = function(_super) {
        __extends(UnionType2, _super);
        function UnionType2(name, is, validate, encode, types) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.types = types;
          _this._tag = "UnionType";
          return _this;
        }
        return UnionType2;
      }(Type);
      exports.UnionType = UnionType;
      function union(codecs, name) {
        if (name === void 0) {
          name = getUnionName(codecs);
        }
        var index = getIndex(codecs);
        if (index !== void 0 && codecs.length > 0) {
          var tag_1 = index[0], groups_1 = index[1];
          var len_1 = groups_1.length;
          var find_1 = function(value) {
            for (var i = 0; i < len_1; i++) {
              if (groups_1[i].indexOf(value) !== -1) {
                return i;
              }
            }
            return void 0;
          };
          return new TaggedUnionType(name, function(u) {
            if (exports.UnknownRecord.is(u)) {
              var i = find_1(u[tag_1]);
              return i !== void 0 ? codecs[i].is(u) : false;
            }
            return false;
          }, function(u, c) {
            var e = exports.UnknownRecord.validate(u, c);
            if ((0, Either_1.isLeft)(e)) {
              return e;
            }
            var r = e.right;
            var i = find_1(r[tag_1]);
            if (i === void 0) {
              return (0, exports.failure)(u, c);
            }
            var codec = codecs[i];
            return codec.validate(r, appendContext(c, String(i), codec, r));
          }, useIdentity(codecs) ? exports.identity : function(a) {
            var i = find_1(a[tag_1]);
            if (i === void 0) {
              throw new Error("no codec found to encode value in union codec ".concat(name));
            } else {
              return codecs[i].encode(a);
            }
          }, codecs, tag_1);
        } else {
          return new UnionType(name, function(u) {
            return codecs.some(function(type2) {
              return type2.is(u);
            });
          }, function(u, c) {
            var errors = [];
            for (var i = 0; i < codecs.length; i++) {
              var codec = codecs[i];
              var result = codec.validate(u, appendContext(c, String(i), codec, u));
              if ((0, Either_1.isLeft)(result)) {
                pushAll(errors, result.left);
              } else {
                return (0, exports.success)(result.right);
              }
            }
            return (0, exports.failures)(errors);
          }, useIdentity(codecs) ? exports.identity : function(a) {
            for (var _i = 0, codecs_1 = codecs; _i < codecs_1.length; _i++) {
              var codec = codecs_1[_i];
              if (codec.is(a)) {
                return codec.encode(a);
              }
            }
            throw new Error("no codec found to encode value in union type ".concat(name));
          }, codecs);
        }
      }
      exports.union = union;
      var IntersectionType = function(_super) {
        __extends(IntersectionType2, _super);
        function IntersectionType2(name, is, validate, encode, types) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.types = types;
          _this._tag = "IntersectionType";
          return _this;
        }
        return IntersectionType2;
      }(Type);
      exports.IntersectionType = IntersectionType;
      function intersection(codecs, name) {
        if (name === void 0) {
          name = "(".concat(codecs.map(function(type2) {
            return type2.name;
          }).join(" & "), ")");
        }
        var len = codecs.length;
        return new IntersectionType(name, function(u) {
          return codecs.every(function(type2) {
            return type2.is(u);
          });
        }, codecs.length === 0 ? exports.success : function(u, c) {
          var us = [];
          var errors = [];
          for (var i = 0; i < len; i++) {
            var codec = codecs[i];
            var result = codec.validate(u, appendContext(c, String(i), codec, u));
            if ((0, Either_1.isLeft)(result)) {
              pushAll(errors, result.left);
            } else {
              us.push(result.right);
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(mergeAll(u, us));
        }, codecs.length === 0 ? exports.identity : function(a) {
          return mergeAll(a, codecs.map(function(codec) {
            return codec.encode(a);
          }));
        }, codecs);
      }
      exports.intersection = intersection;
      var TupleType = function(_super) {
        __extends(TupleType2, _super);
        function TupleType2(name, is, validate, encode, types) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.types = types;
          _this._tag = "TupleType";
          return _this;
        }
        return TupleType2;
      }(Type);
      exports.TupleType = TupleType;
      function tuple(codecs, name) {
        if (name === void 0) {
          name = "[".concat(codecs.map(function(type2) {
            return type2.name;
          }).join(", "), "]");
        }
        var len = codecs.length;
        return new TupleType(name, function(u) {
          return exports.UnknownArray.is(u) && u.length === len && codecs.every(function(type2, i) {
            return type2.is(u[i]);
          });
        }, function(u, c) {
          var e = exports.UnknownArray.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var us = e.right;
          var as = us.length > len ? us.slice(0, len) : us;
          var errors = [];
          for (var i = 0; i < len; i++) {
            var a = us[i];
            var type_3 = codecs[i];
            var result = type_3.validate(a, appendContext(c, String(i), type_3, a));
            if ((0, Either_1.isLeft)(result)) {
              pushAll(errors, result.left);
            } else {
              var va = result.right;
              if (va !== a) {
                if (as === us) {
                  as = us.slice();
                }
                as[i] = va;
              }
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(as);
        }, useIdentity(codecs) ? exports.identity : function(a) {
          return codecs.map(function(type2, i) {
            return type2.encode(a[i]);
          });
        }, codecs);
      }
      exports.tuple = tuple;
      var ReadonlyType = function(_super) {
        __extends(ReadonlyType2, _super);
        function ReadonlyType2(name, is, validate, encode, type2) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type2;
          _this._tag = "ReadonlyType";
          return _this;
        }
        return ReadonlyType2;
      }(Type);
      exports.ReadonlyType = ReadonlyType;
      function readonly(codec, name) {
        if (name === void 0) {
          name = "Readonly<".concat(codec.name, ">");
        }
        return new ReadonlyType(name, codec.is, codec.validate, codec.encode, codec);
      }
      exports.readonly = readonly;
      var ReadonlyArrayType = function(_super) {
        __extends(ReadonlyArrayType2, _super);
        function ReadonlyArrayType2(name, is, validate, encode, type2) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type2;
          _this._tag = "ReadonlyArrayType";
          return _this;
        }
        return ReadonlyArrayType2;
      }(Type);
      exports.ReadonlyArrayType = ReadonlyArrayType;
      function readonlyArray(item, name) {
        if (name === void 0) {
          name = "ReadonlyArray<".concat(item.name, ">");
        }
        var codec = array(item);
        return new ReadonlyArrayType(name, codec.is, codec.validate, codec.encode, item);
      }
      exports.readonlyArray = readonlyArray;
      var strict = function(props, name) {
        return exact(type(props), name);
      };
      exports.strict = strict;
      var ExactType = function(_super) {
        __extends(ExactType2, _super);
        function ExactType2(name, is, validate, encode, type2) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type2;
          _this._tag = "ExactType";
          return _this;
        }
        return ExactType2;
      }(Type);
      exports.ExactType = ExactType;
      function exact(codec, name) {
        if (name === void 0) {
          name = getExactTypeName(codec);
        }
        var props = getProps(codec);
        return new ExactType(name, codec.is, function(u, c) {
          var e = exports.UnknownRecord.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var ce = codec.validate(u, c);
          if ((0, Either_1.isLeft)(ce)) {
            return ce;
          }
          return (0, Either_1.right)(stripKeys(ce.right, props));
        }, function(a) {
          return codec.encode(stripKeys(a, props));
        }, codec);
      }
      exports.exact = exact;
      var FunctionType = function(_super) {
        __extends(FunctionType2, _super);
        function FunctionType2() {
          var _this = _super.call(
            this,
            "Function",
            function(u) {
              return typeof u === "function";
            },
            function(u, c) {
              return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
            },
            exports.identity
          ) || this;
          _this._tag = "FunctionType";
          return _this;
        }
        return FunctionType2;
      }(Type);
      exports.FunctionType = FunctionType;
      exports.Function = new FunctionType();
      var TaggedUnionType = function(_super) {
        __extends(TaggedUnionType2, _super);
        function TaggedUnionType2(name, is, validate, encode, codecs, tag) {
          var _this = _super.call(this, name, is, validate, encode, codecs) || this;
          _this.tag = tag;
          return _this;
        }
        return TaggedUnionType2;
      }(UnionType);
      exports.TaggedUnionType = TaggedUnionType;
      var taggedUnion = function(tag, codecs, name) {
        if (name === void 0) {
          name = getUnionName(codecs);
        }
        var U = union(codecs, name);
        if (U instanceof TaggedUnionType) {
          return U;
        } else {
          console.warn("[io-ts] Cannot build a tagged union for ".concat(name, ", returning a de-optimized union"));
          return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag);
        }
      };
      exports.taggedUnion = taggedUnion;
      var getValidationError = function(value, context) {
        return {
          value,
          context
        };
      };
      exports.getValidationError = getValidationError;
      var getDefaultContext = function(decoder) {
        return [
          { key: "", type: decoder }
        ];
      };
      exports.getDefaultContext = getDefaultContext;
      var NeverType = function(_super) {
        __extends(NeverType2, _super);
        function NeverType2() {
          var _this = _super.call(
            this,
            "never",
            function(_) {
              return false;
            },
            function(u, c) {
              return (0, exports.failure)(u, c);
            },
            function() {
              throw new Error("cannot encode never");
            }
          ) || this;
          _this._tag = "NeverType";
          return _this;
        }
        return NeverType2;
      }(Type);
      exports.NeverType = NeverType;
      exports.never = new NeverType();
      var AnyType = function(_super) {
        __extends(AnyType2, _super);
        function AnyType2() {
          var _this = _super.call(this, "any", function(_) {
            return true;
          }, exports.success, exports.identity) || this;
          _this._tag = "AnyType";
          return _this;
        }
        return AnyType2;
      }(Type);
      exports.AnyType = AnyType;
      exports.any = new AnyType();
      exports.Dictionary = exports.UnknownRecord;
      var ObjectType = function(_super) {
        __extends(ObjectType2, _super);
        function ObjectType2() {
          var _this = _super.call(this, "object", function(u) {
            return u !== null && typeof u === "object";
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "ObjectType";
          return _this;
        }
        return ObjectType2;
      }(Type);
      exports.ObjectType = ObjectType;
      exports.object = new ObjectType();
      function refinement(codec, predicate, name) {
        if (name === void 0) {
          name = "(".concat(codec.name, " | ").concat(getFunctionName(predicate), ")");
        }
        return new RefinementType(name, function(u) {
          return codec.is(u) && predicate(u);
        }, function(i, c) {
          var e = codec.validate(i, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var a = e.right;
          return predicate(a) ? (0, exports.success)(a) : (0, exports.failure)(a, c);
        }, codec.encode, codec, predicate);
      }
      exports.refinement = refinement;
      exports.Integer = refinement(exports.number, Number.isInteger, "Integer");
      exports.dictionary = record;
      var StrictType = function(_super) {
        __extends(StrictType2, _super);
        function StrictType2(name, is, validate, encode, props) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.props = props;
          _this._tag = "StrictType";
          return _this;
        }
        return StrictType2;
      }(Type);
      exports.StrictType = StrictType;
      function clean(codec) {
        return codec;
      }
      exports.clean = clean;
      function alias(codec) {
        return function() {
          return codec;
        };
      }
      exports.alias = alias;
    }
  });

  // node_modules/fp-ts/lib/Eq.js
  var require_Eq = __commonJS({
    "node_modules/fp-ts/lib/Eq.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.eqDate = exports.eqNumber = exports.eqString = exports.eqBoolean = exports.eq = exports.strictEqual = exports.getStructEq = exports.getTupleEq = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.eqStrict = exports.URI = exports.contramap = exports.tuple = exports.struct = exports.fromEquals = void 0;
      var function_1 = require_function();
      var fromEquals = function(equals) {
        return {
          equals: function(x, y) {
            return x === y || equals(x, y);
          }
        };
      };
      exports.fromEquals = fromEquals;
      var struct = function(eqs) {
        return (0, exports.fromEquals)(function(first, second) {
          for (var key in eqs) {
            if (!eqs[key].equals(first[key], second[key])) {
              return false;
            }
          }
          return true;
        });
      };
      exports.struct = struct;
      var tuple = function() {
        var eqs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          eqs[_i] = arguments[_i];
        }
        return (0, exports.fromEquals)(function(first, second) {
          return eqs.every(function(E, i) {
            return E.equals(first[i], second[i]);
          });
        });
      };
      exports.tuple = tuple;
      var contramap_ = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.contramap)(f));
      };
      var contramap = function(f) {
        return function(fa) {
          return (0, exports.fromEquals)(function(x, y) {
            return fa.equals(f(x), f(y));
          });
        };
      };
      exports.contramap = contramap;
      exports.URI = "Eq";
      exports.eqStrict = {
        equals: function(a, b) {
          return a === b;
        }
      };
      var empty = {
        equals: function() {
          return true;
        }
      };
      var getSemigroup = function() {
        return {
          concat: function(x, y) {
            return (0, exports.fromEquals)(function(a, b) {
              return x.equals(a, b) && y.equals(a, b);
            });
          }
        };
      };
      exports.getSemigroup = getSemigroup;
      var getMonoid = function() {
        return {
          concat: (0, exports.getSemigroup)().concat,
          empty
        };
      };
      exports.getMonoid = getMonoid;
      exports.Contravariant = {
        URI: exports.URI,
        contramap: contramap_
      };
      exports.getTupleEq = exports.tuple;
      exports.getStructEq = exports.struct;
      exports.strictEqual = exports.eqStrict.equals;
      exports.eq = exports.Contravariant;
      exports.eqBoolean = exports.eqStrict;
      exports.eqString = exports.eqStrict;
      exports.eqNumber = exports.eqStrict;
      exports.eqDate = {
        equals: function(first, second) {
          return first.valueOf() === second.valueOf();
        }
      };
    }
  });

  // node_modules/fp-ts/lib/Ord.js
  var require_Ord = __commonJS({
    "node_modules/fp-ts/lib/Ord.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ordDate = exports.ordNumber = exports.ordString = exports.ordBoolean = exports.ord = exports.getDualOrd = exports.getTupleOrd = exports.between = exports.clamp = exports.max = exports.min = exports.geq = exports.leq = exports.gt = exports.lt = exports.equals = exports.trivial = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.URI = exports.contramap = exports.reverse = exports.tuple = exports.fromCompare = exports.equalsDefault = void 0;
      var Eq_1 = require_Eq();
      var function_1 = require_function();
      var equalsDefault = function(compare2) {
        return function(first, second) {
          return first === second || compare2(first, second) === 0;
        };
      };
      exports.equalsDefault = equalsDefault;
      var fromCompare = function(compare2) {
        return {
          equals: (0, exports.equalsDefault)(compare2),
          compare: function(first, second) {
            return first === second ? 0 : compare2(first, second);
          }
        };
      };
      exports.fromCompare = fromCompare;
      var tuple = function() {
        var ords = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          ords[_i] = arguments[_i];
        }
        return (0, exports.fromCompare)(function(first, second) {
          var i = 0;
          for (; i < ords.length - 1; i++) {
            var r = ords[i].compare(first[i], second[i]);
            if (r !== 0) {
              return r;
            }
          }
          return ords[i].compare(first[i], second[i]);
        });
      };
      exports.tuple = tuple;
      var reverse = function(O) {
        return (0, exports.fromCompare)(function(first, second) {
          return O.compare(second, first);
        });
      };
      exports.reverse = reverse;
      var contramap_ = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.contramap)(f));
      };
      var contramap = function(f) {
        return function(fa) {
          return (0, exports.fromCompare)(function(first, second) {
            return fa.compare(f(first), f(second));
          });
        };
      };
      exports.contramap = contramap;
      exports.URI = "Ord";
      var getSemigroup = function() {
        return {
          concat: function(first, second) {
            return (0, exports.fromCompare)(function(a, b) {
              var ox = first.compare(a, b);
              return ox !== 0 ? ox : second.compare(a, b);
            });
          }
        };
      };
      exports.getSemigroup = getSemigroup;
      var getMonoid = function() {
        return {
          concat: (0, exports.getSemigroup)().concat,
          empty: (0, exports.fromCompare)(function() {
            return 0;
          })
        };
      };
      exports.getMonoid = getMonoid;
      exports.Contravariant = {
        URI: exports.URI,
        contramap: contramap_
      };
      exports.trivial = {
        equals: function_1.constTrue,
        compare: /* @__PURE__ */ (0, function_1.constant)(0)
      };
      var equals = function(O) {
        return function(second) {
          return function(first) {
            return first === second || O.compare(first, second) === 0;
          };
        };
      };
      exports.equals = equals;
      var lt = function(O) {
        return function(first, second) {
          return O.compare(first, second) === -1;
        };
      };
      exports.lt = lt;
      var gt = function(O) {
        return function(first, second) {
          return O.compare(first, second) === 1;
        };
      };
      exports.gt = gt;
      var leq = function(O) {
        return function(first, second) {
          return O.compare(first, second) !== 1;
        };
      };
      exports.leq = leq;
      var geq = function(O) {
        return function(first, second) {
          return O.compare(first, second) !== -1;
        };
      };
      exports.geq = geq;
      var min = function(O) {
        return function(first, second) {
          return first === second || O.compare(first, second) < 1 ? first : second;
        };
      };
      exports.min = min;
      var max = function(O) {
        return function(first, second) {
          return first === second || O.compare(first, second) > -1 ? first : second;
        };
      };
      exports.max = max;
      var clamp = function(O) {
        var minO = (0, exports.min)(O);
        var maxO = (0, exports.max)(O);
        return function(low, hi) {
          return function(a) {
            return maxO(minO(a, hi), low);
          };
        };
      };
      exports.clamp = clamp;
      var between = function(O) {
        var ltO = (0, exports.lt)(O);
        var gtO = (0, exports.gt)(O);
        return function(low, hi) {
          return function(a) {
            return ltO(a, low) || gtO(a, hi) ? false : true;
          };
        };
      };
      exports.between = between;
      exports.getTupleOrd = exports.tuple;
      exports.getDualOrd = exports.reverse;
      exports.ord = exports.Contravariant;
      function compare(first, second) {
        return first < second ? -1 : first > second ? 1 : 0;
      }
      var strictOrd = {
        equals: Eq_1.eqStrict.equals,
        compare
      };
      exports.ordBoolean = strictOrd;
      exports.ordString = strictOrd;
      exports.ordNumber = strictOrd;
      exports.ordDate = (0, function_1.pipe)(
        exports.ordNumber,
        /* @__PURE__ */ (0, exports.contramap)(function(date) {
          return date.valueOf();
        })
      );
    }
  });

  // node_modules/fp-ts/lib/Magma.js
  var require_Magma = __commonJS({
    "node_modules/fp-ts/lib/Magma.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.concatAll = exports.endo = exports.filterSecond = exports.filterFirst = exports.reverse = void 0;
      var reverse = function(M) {
        return {
          concat: function(first, second) {
            return M.concat(second, first);
          }
        };
      };
      exports.reverse = reverse;
      var filterFirst = function(predicate) {
        return function(M) {
          return {
            concat: function(first, second) {
              return predicate(first) ? M.concat(first, second) : second;
            }
          };
        };
      };
      exports.filterFirst = filterFirst;
      var filterSecond = function(predicate) {
        return function(M) {
          return {
            concat: function(first, second) {
              return predicate(second) ? M.concat(first, second) : first;
            }
          };
        };
      };
      exports.filterSecond = filterSecond;
      var endo = function(f) {
        return function(M) {
          return {
            concat: function(first, second) {
              return M.concat(f(first), f(second));
            }
          };
        };
      };
      exports.endo = endo;
      var concatAll = function(M) {
        return function(startWith) {
          return function(as) {
            return as.reduce(function(a, acc) {
              return M.concat(a, acc);
            }, startWith);
          };
        };
      };
      exports.concatAll = concatAll;
    }
  });

  // node_modules/fp-ts/lib/Semigroup.js
  var require_Semigroup = __commonJS({
    "node_modules/fp-ts/lib/Semigroup.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.semigroupProduct = exports.semigroupSum = exports.semigroupString = exports.getFunctionSemigroup = exports.semigroupAny = exports.semigroupAll = exports.fold = exports.getIntercalateSemigroup = exports.getMeetSemigroup = exports.getJoinSemigroup = exports.getDualSemigroup = exports.getStructSemigroup = exports.getTupleSemigroup = exports.getFirstSemigroup = exports.getLastSemigroup = exports.getObjectSemigroup = exports.semigroupVoid = exports.concatAll = exports.last = exports.first = exports.intercalate = exports.tuple = exports.struct = exports.reverse = exports.constant = exports.max = exports.min = void 0;
      var function_1 = require_function();
      var _ = __importStar(require_internal());
      var M = __importStar(require_Magma());
      var Or = __importStar(require_Ord());
      var min = function(O) {
        return {
          concat: Or.min(O)
        };
      };
      exports.min = min;
      var max = function(O) {
        return {
          concat: Or.max(O)
        };
      };
      exports.max = max;
      var constant = function(a) {
        return {
          concat: function() {
            return a;
          }
        };
      };
      exports.constant = constant;
      exports.reverse = M.reverse;
      var struct = function(semigroups) {
        return {
          concat: function(first2, second) {
            var r = {};
            for (var k in semigroups) {
              if (_.has.call(semigroups, k)) {
                r[k] = semigroups[k].concat(first2[k], second[k]);
              }
            }
            return r;
          }
        };
      };
      exports.struct = struct;
      var tuple = function() {
        var semigroups = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          semigroups[_i] = arguments[_i];
        }
        return {
          concat: function(first2, second) {
            return semigroups.map(function(s, i) {
              return s.concat(first2[i], second[i]);
            });
          }
        };
      };
      exports.tuple = tuple;
      var intercalate = function(middle) {
        return function(S) {
          return {
            concat: function(x, y) {
              return S.concat(x, S.concat(middle, y));
            }
          };
        };
      };
      exports.intercalate = intercalate;
      var first = function() {
        return { concat: function_1.identity };
      };
      exports.first = first;
      var last = function() {
        return { concat: function(_2, y) {
          return y;
        } };
      };
      exports.last = last;
      exports.concatAll = M.concatAll;
      exports.semigroupVoid = (0, exports.constant)(void 0);
      var getObjectSemigroup = function() {
        return {
          concat: function(first2, second) {
            return Object.assign({}, first2, second);
          }
        };
      };
      exports.getObjectSemigroup = getObjectSemigroup;
      exports.getLastSemigroup = exports.last;
      exports.getFirstSemigroup = exports.first;
      exports.getTupleSemigroup = exports.tuple;
      exports.getStructSemigroup = exports.struct;
      exports.getDualSemigroup = exports.reverse;
      exports.getJoinSemigroup = exports.max;
      exports.getMeetSemigroup = exports.min;
      exports.getIntercalateSemigroup = exports.intercalate;
      function fold(S) {
        var concatAllS = (0, exports.concatAll)(S);
        return function(startWith, as) {
          return as === void 0 ? concatAllS(startWith) : concatAllS(startWith)(as);
        };
      }
      exports.fold = fold;
      exports.semigroupAll = {
        concat: function(x, y) {
          return x && y;
        }
      };
      exports.semigroupAny = {
        concat: function(x, y) {
          return x || y;
        }
      };
      exports.getFunctionSemigroup = function_1.getSemigroup;
      exports.semigroupString = {
        concat: function(x, y) {
          return x + y;
        }
      };
      exports.semigroupSum = {
        concat: function(x, y) {
          return x + y;
        }
      };
      exports.semigroupProduct = {
        concat: function(x, y) {
          return x * y;
        }
      };
    }
  });

  // node_modules/fp-ts/lib/ReadonlyNonEmptyArray.js
  var require_ReadonlyNonEmptyArray = __commonJS({
    "node_modules/fp-ts/lib/ReadonlyNonEmptyArray.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.reduceRight = exports.foldMap = exports.reduce = exports.mapWithIndex = exports.map = exports.flatten = exports.duplicate = exports.extend = exports.chain = exports.ap = exports.alt = exports.altW = exports.of = exports.chunksOf = exports.splitAt = exports.chop = exports.chainWithIndex = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = exports.modifyAt = exports.updateAt = exports.sort = exports.groupBy = exports.group = exports.reverse = exports.concat = exports.concatW = exports.fromArray = exports.unappend = exports.unprepend = exports.range = exports.replicate = exports.makeBy = exports.fromReadonlyArray = exports.rotate = exports.union = exports.sortBy = exports.uniq = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.append = exports.appendW = exports.prepend = exports.prependW = exports.isOutOfBound = exports.isNonEmpty = exports.empty = void 0;
      exports.filter = exports.groupSort = exports.intercalate = exports.updateLast = exports.modifyLast = exports.updateHead = exports.modifyHead = exports.matchRight = exports.matchLeft = exports.concatAll = exports.max = exports.min = exports.init = exports.last = exports.tail = exports.head = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.Comonad = exports.Alt = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getUnionSemigroup = exports.getEq = exports.getSemigroup = exports.getShow = exports.URI = exports.extract = exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = void 0;
      exports.readonlyNonEmptyArray = exports.fold = exports.prependToAll = exports.insertAt = exports.snoc = exports.cons = exports.unsnoc = exports.uncons = exports.filterWithIndex = void 0;
      var Apply_1 = require_Apply();
      var Chain_1 = require_Chain();
      var Eq_1 = require_Eq();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar(require_internal());
      var Ord_1 = require_Ord();
      var Se = __importStar(require_Semigroup());
      exports.empty = _.emptyReadonlyArray;
      exports.isNonEmpty = _.isNonEmpty;
      var isOutOfBound = function(i, as) {
        return i < 0 || i >= as.length;
      };
      exports.isOutOfBound = isOutOfBound;
      var prependW = function(head) {
        return function(tail) {
          return __spreadArray([head], tail, true);
        };
      };
      exports.prependW = prependW;
      exports.prepend = exports.prependW;
      var appendW = function(end) {
        return function(init2) {
          return __spreadArray(__spreadArray([], init2, true), [end], false);
        };
      };
      exports.appendW = appendW;
      exports.append = exports.appendW;
      var unsafeInsertAt = function(i, a, as) {
        if ((0, exports.isNonEmpty)(as)) {
          var xs = _.fromReadonlyNonEmptyArray(as);
          xs.splice(i, 0, a);
          return xs;
        }
        return [a];
      };
      exports.unsafeInsertAt = unsafeInsertAt;
      var unsafeUpdateAt = function(i, a, as) {
        if (as[i] === a) {
          return as;
        } else {
          var xs = _.fromReadonlyNonEmptyArray(as);
          xs[i] = a;
          return xs;
        }
      };
      exports.unsafeUpdateAt = unsafeUpdateAt;
      var uniq = function(E) {
        return function(as) {
          if (as.length === 1) {
            return as;
          }
          var out = [(0, exports.head)(as)];
          var rest = (0, exports.tail)(as);
          var _loop_1 = function(a2) {
            if (out.every(function(o) {
              return !E.equals(o, a2);
            })) {
              out.push(a2);
            }
          };
          for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
            var a = rest_1[_i];
            _loop_1(a);
          }
          return out;
        };
      };
      exports.uniq = uniq;
      var sortBy = function(ords) {
        if ((0, exports.isNonEmpty)(ords)) {
          var M = (0, Ord_1.getMonoid)();
          return (0, exports.sort)(ords.reduce(M.concat, M.empty));
        }
        return function_1.identity;
      };
      exports.sortBy = sortBy;
      var union = function(E) {
        var uniqE = (0, exports.uniq)(E);
        return function(second) {
          return function(first) {
            return uniqE((0, function_1.pipe)(first, concat(second)));
          };
        };
      };
      exports.union = union;
      var rotate = function(n) {
        return function(as) {
          var len = as.length;
          var m = Math.round(n) % len;
          if ((0, exports.isOutOfBound)(Math.abs(m), as) || m === 0) {
            return as;
          }
          if (m < 0) {
            var _a = (0, exports.splitAt)(-m)(as), f = _a[0], s = _a[1];
            return (0, function_1.pipe)(s, concat(f));
          } else {
            return (0, exports.rotate)(m - len)(as);
          }
        };
      };
      exports.rotate = rotate;
      var fromReadonlyArray = function(as) {
        return (0, exports.isNonEmpty)(as) ? _.some(as) : _.none;
      };
      exports.fromReadonlyArray = fromReadonlyArray;
      var makeBy = function(f) {
        return function(n) {
          var j = Math.max(0, Math.floor(n));
          var out = [f(0)];
          for (var i = 1; i < j; i++) {
            out.push(f(i));
          }
          return out;
        };
      };
      exports.makeBy = makeBy;
      var replicate = function(a) {
        return (0, exports.makeBy)(function() {
          return a;
        });
      };
      exports.replicate = replicate;
      var range = function(start, end) {
        return start <= end ? (0, exports.makeBy)(function(i) {
          return start + i;
        })(end - start + 1) : [start];
      };
      exports.range = range;
      var unprepend = function(as) {
        return [(0, exports.head)(as), (0, exports.tail)(as)];
      };
      exports.unprepend = unprepend;
      var unappend = function(as) {
        return [(0, exports.init)(as), (0, exports.last)(as)];
      };
      exports.unappend = unappend;
      var fromArray = function(as) {
        return (0, exports.fromReadonlyArray)(as.slice());
      };
      exports.fromArray = fromArray;
      function concatW(second) {
        return function(first) {
          return first.concat(second);
        };
      }
      exports.concatW = concatW;
      function concat(x, y) {
        return y ? x.concat(y) : function(y2) {
          return y2.concat(x);
        };
      }
      exports.concat = concat;
      var reverse = function(as) {
        return as.length === 1 ? as : __spreadArray([(0, exports.last)(as)], as.slice(0, -1).reverse(), true);
      };
      exports.reverse = reverse;
      function group(E) {
        return function(as) {
          var len = as.length;
          if (len === 0) {
            return exports.empty;
          }
          var out = [];
          var head = as[0];
          var nea = [head];
          for (var i = 1; i < len; i++) {
            var a = as[i];
            if (E.equals(a, head)) {
              nea.push(a);
            } else {
              out.push(nea);
              head = a;
              nea = [head];
            }
          }
          out.push(nea);
          return out;
        };
      }
      exports.group = group;
      var groupBy = function(f) {
        return function(as) {
          var out = {};
          for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
            var a = as_1[_i];
            var k = f(a);
            if (_.has.call(out, k)) {
              out[k].push(a);
            } else {
              out[k] = [a];
            }
          }
          return out;
        };
      };
      exports.groupBy = groupBy;
      var sort = function(O) {
        return function(as) {
          return as.length === 1 ? as : as.slice().sort(O.compare);
        };
      };
      exports.sort = sort;
      var updateAt = function(i, a) {
        return (0, exports.modifyAt)(i, function() {
          return a;
        });
      };
      exports.updateAt = updateAt;
      var modifyAt = function(i, f) {
        return function(as) {
          return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f(as[i]), as));
        };
      };
      exports.modifyAt = modifyAt;
      var zipWith = function(as, bs, f) {
        var cs = [f(as[0], bs[0])];
        var len = Math.min(as.length, bs.length);
        for (var i = 1; i < len; i++) {
          cs[i] = f(as[i], bs[i]);
        }
        return cs;
      };
      exports.zipWith = zipWith;
      function zip(as, bs) {
        if (bs === void 0) {
          return function(bs2) {
            return zip(bs2, as);
          };
        }
        return (0, exports.zipWith)(as, bs, function(a, b) {
          return [a, b];
        });
      }
      exports.zip = zip;
      var unzip = function(abs) {
        var fa = [abs[0][0]];
        var fb = [abs[0][1]];
        for (var i = 1; i < abs.length; i++) {
          fa[i] = abs[i][0];
          fb[i] = abs[i][1];
        }
        return [fa, fb];
      };
      exports.unzip = unzip;
      var prependAll = function(middle) {
        return function(as) {
          var out = [middle, as[0]];
          for (var i = 1; i < as.length; i++) {
            out.push(middle, as[i]);
          }
          return out;
        };
      };
      exports.prependAll = prependAll;
      var intersperse = function(middle) {
        return function(as) {
          var rest = (0, exports.tail)(as);
          return (0, exports.isNonEmpty)(rest) ? (0, function_1.pipe)(rest, (0, exports.prependAll)(middle), (0, exports.prepend)((0, exports.head)(as))) : as;
        };
      };
      exports.intersperse = intersperse;
      var chainWithIndex = function(f) {
        return function(as) {
          var out = _.fromReadonlyNonEmptyArray(f(0, (0, exports.head)(as)));
          for (var i = 1; i < as.length; i++) {
            out.push.apply(out, f(i, as[i]));
          }
          return out;
        };
      };
      exports.chainWithIndex = chainWithIndex;
      var chop = function(f) {
        return function(as) {
          var _a = f(as), b = _a[0], rest = _a[1];
          var out = [b];
          var next = rest;
          while ((0, exports.isNonEmpty)(next)) {
            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];
            out.push(b_1);
            next = rest_2;
          }
          return out;
        };
      };
      exports.chop = chop;
      var splitAt = function(n) {
        return function(as) {
          var m = Math.max(1, n);
          return m >= as.length ? [as, exports.empty] : [(0, function_1.pipe)(as.slice(1, m), (0, exports.prepend)((0, exports.head)(as))), as.slice(m)];
        };
      };
      exports.splitAt = splitAt;
      var chunksOf = function(n) {
        return (0, exports.chop)((0, exports.splitAt)(n));
      };
      exports.chunksOf = chunksOf;
      var _map = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f));
      };
      var _mapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f));
      };
      var _ap = function(fab, fa) {
        return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
      };
      var _chain = function(ma, f) {
        return (0, function_1.pipe)(ma, (0, exports.chain)(f));
      };
      var _extend = function(wa, f) {
        return (0, function_1.pipe)(wa, (0, exports.extend)(f));
      };
      var _reduce = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f));
      };
      var _foldMap = function(M) {
        var foldMapM = (0, exports.foldMap)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapM(f));
        };
      };
      var _reduceRight = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f));
      };
      var _traverse = function(F) {
        var traverseF = (0, exports.traverse)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseF(f));
        };
      };
      var _alt = function(fa, that) {
        return (0, function_1.pipe)(fa, (0, exports.alt)(that));
      };
      var _reduceWithIndex = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f));
      };
      var _foldMapWithIndex = function(M) {
        var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapWithIndexM(f));
        };
      };
      var _reduceRightWithIndex = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f));
      };
      var _traverseWithIndex = function(F) {
        var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseWithIndexF(f));
        };
      };
      exports.of = _.singleton;
      var altW = function(that) {
        return function(as) {
          return (0, function_1.pipe)(as, concatW(that()));
        };
      };
      exports.altW = altW;
      exports.alt = exports.altW;
      var ap = function(as) {
        return (0, exports.chain)(function(f) {
          return (0, function_1.pipe)(as, (0, exports.map)(f));
        });
      };
      exports.ap = ap;
      var chain = function(f) {
        return (0, exports.chainWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.chain = chain;
      var extend = function(f) {
        return function(as) {
          var next = (0, exports.tail)(as);
          var out = [f(as)];
          while ((0, exports.isNonEmpty)(next)) {
            out.push(f(next));
            next = (0, exports.tail)(next);
          }
          return out;
        };
      };
      exports.extend = extend;
      exports.duplicate = /* @__PURE__ */ (0, exports.extend)(function_1.identity);
      exports.flatten = /* @__PURE__ */ (0, exports.chain)(function_1.identity);
      var map = function(f) {
        return (0, exports.mapWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.map = map;
      var mapWithIndex = function(f) {
        return function(as) {
          var out = [f(0, (0, exports.head)(as))];
          for (var i = 1; i < as.length; i++) {
            out.push(f(i, as[i]));
          }
          return out;
        };
      };
      exports.mapWithIndex = mapWithIndex;
      var reduce = function(b, f) {
        return (0, exports.reduceWithIndex)(b, function(_2, b2, a) {
          return f(b2, a);
        });
      };
      exports.reduce = reduce;
      var foldMap = function(S) {
        return function(f) {
          return function(as) {
            return as.slice(1).reduce(function(s, a) {
              return S.concat(s, f(a));
            }, f(as[0]));
          };
        };
      };
      exports.foldMap = foldMap;
      var reduceRight = function(b, f) {
        return (0, exports.reduceRightWithIndex)(b, function(_2, b2, a) {
          return f(b2, a);
        });
      };
      exports.reduceRight = reduceRight;
      var reduceWithIndex = function(b, f) {
        return function(as) {
          return as.reduce(function(b2, a, i) {
            return f(i, b2, a);
          }, b);
        };
      };
      exports.reduceWithIndex = reduceWithIndex;
      var foldMapWithIndex = function(S) {
        return function(f) {
          return function(as) {
            return as.slice(1).reduce(function(s, a, i) {
              return S.concat(s, f(i + 1, a));
            }, f(0, as[0]));
          };
        };
      };
      exports.foldMapWithIndex = foldMapWithIndex;
      var reduceRightWithIndex = function(b, f) {
        return function(as) {
          return as.reduceRight(function(b2, a, i) {
            return f(i, a, b2);
          }, b);
        };
      };
      exports.reduceRightWithIndex = reduceRightWithIndex;
      var traverse = function(F) {
        var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
        return function(f) {
          return traverseWithIndexF(function(_2, a) {
            return f(a);
          });
        };
      };
      exports.traverse = traverse;
      var sequence = function(F) {
        return (0, exports.traverseWithIndex)(F)(function_1.SK);
      };
      exports.sequence = sequence;
      var traverseWithIndex = function(F) {
        return function(f) {
          return function(as) {
            var out = F.map(f(0, (0, exports.head)(as)), exports.of);
            for (var i = 1; i < as.length; i++) {
              out = F.ap(F.map(out, function(bs) {
                return function(b) {
                  return (0, function_1.pipe)(bs, (0, exports.append)(b));
                };
              }), f(i, as[i]));
            }
            return out;
          };
        };
      };
      exports.traverseWithIndex = traverseWithIndex;
      exports.extract = _.head;
      exports.URI = "ReadonlyNonEmptyArray";
      var getShow = function(S) {
        return {
          show: function(as) {
            return "[".concat(as.map(S.show).join(", "), "]");
          }
        };
      };
      exports.getShow = getShow;
      var getSemigroup = function() {
        return {
          concat
        };
      };
      exports.getSemigroup = getSemigroup;
      var getEq = function(E) {
        return (0, Eq_1.fromEquals)(function(xs, ys) {
          return xs.length === ys.length && xs.every(function(x, i) {
            return E.equals(x, ys[i]);
          });
        });
      };
      exports.getEq = getEq;
      var getUnionSemigroup = function(E) {
        var unionE = (0, exports.union)(E);
        return {
          concat: function(first, second) {
            return unionE(second)(first);
          }
        };
      };
      exports.getUnionSemigroup = getUnionSemigroup;
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.Pointed = {
        URI: exports.URI,
        of: exports.of
      };
      exports.FunctorWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex
      };
      exports.Apply = {
        URI: exports.URI,
        map: _map,
        ap: _ap
      };
      exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
      exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
      exports.Applicative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of
      };
      exports.Chain = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain
      };
      exports.chainFirst = (0, Chain_1.chainFirst)(exports.Chain);
      exports.Monad = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain
      };
      exports.Foldable = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight
      };
      exports.FoldableWithIndex = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex
      };
      exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence
      };
      exports.TraversableWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex,
        traverseWithIndex: _traverseWithIndex
      };
      exports.Alt = {
        URI: exports.URI,
        map: _map,
        alt: _alt
      };
      exports.Comonad = {
        URI: exports.URI,
        map: _map,
        extend: _extend,
        extract: exports.extract
      };
      exports.Do = (0, exports.of)(_.emptyRecord);
      exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
      var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
      exports.let = let_;
      exports.bind = (0, Chain_1.bind)(exports.Chain);
      exports.apS = (0, Apply_1.apS)(exports.Apply);
      exports.head = exports.extract;
      exports.tail = _.tail;
      var last = function(as) {
        return as[as.length - 1];
      };
      exports.last = last;
      var init = function(as) {
        return as.slice(0, -1);
      };
      exports.init = init;
      var min = function(O) {
        var S = Se.min(O);
        return function(as) {
          return as.reduce(S.concat);
        };
      };
      exports.min = min;
      var max = function(O) {
        var S = Se.max(O);
        return function(as) {
          return as.reduce(S.concat);
        };
      };
      exports.max = max;
      var concatAll = function(S) {
        return function(as) {
          return as.reduce(S.concat);
        };
      };
      exports.concatAll = concatAll;
      var matchLeft = function(f) {
        return function(as) {
          return f((0, exports.head)(as), (0, exports.tail)(as));
        };
      };
      exports.matchLeft = matchLeft;
      var matchRight = function(f) {
        return function(as) {
          return f((0, exports.init)(as), (0, exports.last)(as));
        };
      };
      exports.matchRight = matchRight;
      var modifyHead = function(f) {
        return function(as) {
          return __spreadArray([f((0, exports.head)(as))], (0, exports.tail)(as), true);
        };
      };
      exports.modifyHead = modifyHead;
      var updateHead = function(a) {
        return (0, exports.modifyHead)(function() {
          return a;
        });
      };
      exports.updateHead = updateHead;
      var modifyLast = function(f) {
        return function(as) {
          return (0, function_1.pipe)((0, exports.init)(as), (0, exports.append)(f((0, exports.last)(as))));
        };
      };
      exports.modifyLast = modifyLast;
      var updateLast = function(a) {
        return (0, exports.modifyLast)(function() {
          return a;
        });
      };
      exports.updateLast = updateLast;
      var intercalate = function(S) {
        var concatAllS = (0, exports.concatAll)(S);
        return function(middle) {
          return (0, function_1.flow)((0, exports.intersperse)(middle), concatAllS);
        };
      };
      exports.intercalate = intercalate;
      function groupSort(O) {
        var sortO = (0, exports.sort)(O);
        var groupO = group(O);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? groupO(sortO(as)) : exports.empty;
        };
      }
      exports.groupSort = groupSort;
      function filter(predicate) {
        return (0, exports.filterWithIndex)(function(_2, a) {
          return predicate(a);
        });
      }
      exports.filter = filter;
      var filterWithIndex = function(predicate) {
        return function(as) {
          return (0, exports.fromReadonlyArray)(as.filter(function(a, i) {
            return predicate(i, a);
          }));
        };
      };
      exports.filterWithIndex = filterWithIndex;
      exports.uncons = exports.unprepend;
      exports.unsnoc = exports.unappend;
      function cons(head, tail) {
        return tail === void 0 ? (0, exports.prepend)(head) : (0, function_1.pipe)(tail, (0, exports.prepend)(head));
      }
      exports.cons = cons;
      var snoc = function(init2, end) {
        return (0, function_1.pipe)(init2, concat([end]));
      };
      exports.snoc = snoc;
      var insertAt = function(i, a) {
        return function(as) {
          return i < 0 || i > as.length ? _.none : _.some((0, exports.unsafeInsertAt)(i, a, as));
        };
      };
      exports.insertAt = insertAt;
      exports.prependToAll = exports.prependAll;
      exports.fold = exports.concatAll;
      exports.readonlyNonEmptyArray = {
        URI: exports.URI,
        of: exports.of,
        map: _map,
        mapWithIndex: _mapWithIndex,
        ap: _ap,
        chain: _chain,
        extend: _extend,
        extract: exports.extract,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex,
        traverseWithIndex: _traverseWithIndex,
        alt: _alt
      };
    }
  });

  // node_modules/fp-ts/lib/NonEmptyArray.js
  var require_NonEmptyArray = __commonJS({
    "node_modules/fp-ts/lib/NonEmptyArray.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mapWithIndex = exports.map = exports.flatten = exports.duplicate = exports.extend = exports.chain = exports.ap = exports.alt = exports.altW = exports.chunksOf = exports.splitAt = exports.chop = exports.chainWithIndex = exports.foldMap = exports.foldMapWithIndex = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = exports.of = exports.copy = exports.modifyAt = exports.updateAt = exports.insertAt = exports.sort = exports.groupBy = exports.group = exports.reverse = exports.concat = exports.concatW = exports.unappend = exports.unprepend = exports.range = exports.replicate = exports.makeBy = exports.fromArray = exports.fromReadonlyNonEmptyArray = exports.rotate = exports.union = exports.sortBy = exports.uniq = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.append = exports.appendW = exports.prepend = exports.prependW = exports.isOutOfBound = exports.isNonEmpty = void 0;
      exports.groupSort = exports.intercalate = exports.updateLast = exports.modifyLast = exports.updateHead = exports.modifyHead = exports.matchRight = exports.matchLeft = exports.concatAll = exports.max = exports.min = exports.init = exports.last = exports.tail = exports.head = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.Comonad = exports.Alt = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getUnionSemigroup = exports.getEq = exports.getSemigroup = exports.getShow = exports.URI = exports.extract = exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.reduce = void 0;
      exports.nonEmptyArray = exports.fold = exports.prependToAll = exports.snoc = exports.cons = exports.unsnoc = exports.uncons = exports.filterWithIndex = exports.filter = void 0;
      var Apply_1 = require_Apply();
      var Chain_1 = require_Chain();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar(require_internal());
      var Ord_1 = require_Ord();
      var RNEA = __importStar(require_ReadonlyNonEmptyArray());
      var isNonEmpty = function(as) {
        return as.length > 0;
      };
      exports.isNonEmpty = isNonEmpty;
      var isOutOfBound = function(i, as) {
        return i < 0 || i >= as.length;
      };
      exports.isOutOfBound = isOutOfBound;
      var prependW = function(head) {
        return function(tail2) {
          return __spreadArray([head], tail2, true);
        };
      };
      exports.prependW = prependW;
      exports.prepend = exports.prependW;
      var appendW = function(end) {
        return function(init2) {
          return __spreadArray(__spreadArray([], init2, true), [end], false);
        };
      };
      exports.appendW = appendW;
      exports.append = exports.appendW;
      var unsafeInsertAt = function(i, a, as) {
        if ((0, exports.isNonEmpty)(as)) {
          var xs = (0, exports.fromReadonlyNonEmptyArray)(as);
          xs.splice(i, 0, a);
          return xs;
        }
        return [a];
      };
      exports.unsafeInsertAt = unsafeInsertAt;
      var unsafeUpdateAt = function(i, a, as) {
        var xs = (0, exports.fromReadonlyNonEmptyArray)(as);
        xs[i] = a;
        return xs;
      };
      exports.unsafeUpdateAt = unsafeUpdateAt;
      var uniq = function(E) {
        return function(as) {
          if (as.length === 1) {
            return (0, exports.copy)(as);
          }
          var out = [(0, exports.head)(as)];
          var rest = (0, exports.tail)(as);
          var _loop_1 = function(a2) {
            if (out.every(function(o) {
              return !E.equals(o, a2);
            })) {
              out.push(a2);
            }
          };
          for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
            var a = rest_1[_i];
            _loop_1(a);
          }
          return out;
        };
      };
      exports.uniq = uniq;
      var sortBy = function(ords) {
        if ((0, exports.isNonEmpty)(ords)) {
          var M = (0, Ord_1.getMonoid)();
          return (0, exports.sort)(ords.reduce(M.concat, M.empty));
        }
        return exports.copy;
      };
      exports.sortBy = sortBy;
      var union = function(E) {
        var uniqE = (0, exports.uniq)(E);
        return function(second) {
          return function(first) {
            return uniqE((0, function_1.pipe)(first, concat(second)));
          };
        };
      };
      exports.union = union;
      var rotate = function(n) {
        return function(as) {
          var len = as.length;
          var m = Math.round(n) % len;
          if ((0, exports.isOutOfBound)(Math.abs(m), as) || m === 0) {
            return (0, exports.copy)(as);
          }
          if (m < 0) {
            var _a = (0, exports.splitAt)(-m)(as), f = _a[0], s = _a[1];
            return (0, function_1.pipe)(s, concat(f));
          } else {
            return (0, exports.rotate)(m - len)(as);
          }
        };
      };
      exports.rotate = rotate;
      exports.fromReadonlyNonEmptyArray = _.fromReadonlyNonEmptyArray;
      var fromArray = function(as) {
        return (0, exports.isNonEmpty)(as) ? _.some(as) : _.none;
      };
      exports.fromArray = fromArray;
      var makeBy = function(f) {
        return function(n) {
          var j = Math.max(0, Math.floor(n));
          var out = [f(0)];
          for (var i = 1; i < j; i++) {
            out.push(f(i));
          }
          return out;
        };
      };
      exports.makeBy = makeBy;
      var replicate = function(a) {
        return (0, exports.makeBy)(function() {
          return a;
        });
      };
      exports.replicate = replicate;
      var range = function(start, end) {
        return start <= end ? (0, exports.makeBy)(function(i) {
          return start + i;
        })(end - start + 1) : [start];
      };
      exports.range = range;
      var unprepend = function(as) {
        return [(0, exports.head)(as), (0, exports.tail)(as)];
      };
      exports.unprepend = unprepend;
      var unappend = function(as) {
        return [(0, exports.init)(as), (0, exports.last)(as)];
      };
      exports.unappend = unappend;
      function concatW(second) {
        return function(first) {
          return first.concat(second);
        };
      }
      exports.concatW = concatW;
      function concat(x, y) {
        return y ? x.concat(y) : function(y2) {
          return y2.concat(x);
        };
      }
      exports.concat = concat;
      var reverse = function(as) {
        return __spreadArray([(0, exports.last)(as)], as.slice(0, -1).reverse(), true);
      };
      exports.reverse = reverse;
      function group(E) {
        return function(as) {
          var len = as.length;
          if (len === 0) {
            return [];
          }
          var out = [];
          var head = as[0];
          var nea = [head];
          for (var i = 1; i < len; i++) {
            var a = as[i];
            if (E.equals(a, head)) {
              nea.push(a);
            } else {
              out.push(nea);
              head = a;
              nea = [head];
            }
          }
          out.push(nea);
          return out;
        };
      }
      exports.group = group;
      var groupBy = function(f) {
        return function(as) {
          var out = {};
          for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
            var a = as_1[_i];
            var k = f(a);
            if (_.has.call(out, k)) {
              out[k].push(a);
            } else {
              out[k] = [a];
            }
          }
          return out;
        };
      };
      exports.groupBy = groupBy;
      var sort = function(O) {
        return function(as) {
          return as.slice().sort(O.compare);
        };
      };
      exports.sort = sort;
      var insertAt = function(i, a) {
        return function(as) {
          return i < 0 || i > as.length ? _.none : _.some((0, exports.unsafeInsertAt)(i, a, as));
        };
      };
      exports.insertAt = insertAt;
      var updateAt = function(i, a) {
        return (0, exports.modifyAt)(i, function() {
          return a;
        });
      };
      exports.updateAt = updateAt;
      var modifyAt = function(i, f) {
        return function(as) {
          return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f(as[i]), as));
        };
      };
      exports.modifyAt = modifyAt;
      exports.copy = exports.fromReadonlyNonEmptyArray;
      var of = function(a) {
        return [a];
      };
      exports.of = of;
      var zipWith = function(as, bs, f) {
        var cs = [f(as[0], bs[0])];
        var len = Math.min(as.length, bs.length);
        for (var i = 1; i < len; i++) {
          cs[i] = f(as[i], bs[i]);
        }
        return cs;
      };
      exports.zipWith = zipWith;
      function zip(as, bs) {
        if (bs === void 0) {
          return function(bs2) {
            return zip(bs2, as);
          };
        }
        return (0, exports.zipWith)(as, bs, function(a, b) {
          return [a, b];
        });
      }
      exports.zip = zip;
      var unzip = function(abs) {
        var fa = [abs[0][0]];
        var fb = [abs[0][1]];
        for (var i = 1; i < abs.length; i++) {
          fa[i] = abs[i][0];
          fb[i] = abs[i][1];
        }
        return [fa, fb];
      };
      exports.unzip = unzip;
      var prependAll = function(middle) {
        return function(as) {
          var out = [middle, as[0]];
          for (var i = 1; i < as.length; i++) {
            out.push(middle, as[i]);
          }
          return out;
        };
      };
      exports.prependAll = prependAll;
      var intersperse = function(middle) {
        return function(as) {
          var rest = (0, exports.tail)(as);
          return (0, exports.isNonEmpty)(rest) ? (0, function_1.pipe)(rest, (0, exports.prependAll)(middle), (0, exports.prepend)((0, exports.head)(as))) : (0, exports.copy)(as);
        };
      };
      exports.intersperse = intersperse;
      exports.foldMapWithIndex = RNEA.foldMapWithIndex;
      exports.foldMap = RNEA.foldMap;
      var chainWithIndex = function(f) {
        return function(as) {
          var out = (0, exports.fromReadonlyNonEmptyArray)(f(0, (0, exports.head)(as)));
          for (var i = 1; i < as.length; i++) {
            out.push.apply(out, f(i, as[i]));
          }
          return out;
        };
      };
      exports.chainWithIndex = chainWithIndex;
      var chop = function(f) {
        return function(as) {
          var _a = f(as), b = _a[0], rest = _a[1];
          var out = [b];
          var next = rest;
          while ((0, exports.isNonEmpty)(next)) {
            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];
            out.push(b_1);
            next = rest_2;
          }
          return out;
        };
      };
      exports.chop = chop;
      var splitAt = function(n) {
        return function(as) {
          var m = Math.max(1, n);
          return m >= as.length ? [(0, exports.copy)(as), []] : [(0, function_1.pipe)(as.slice(1, m), (0, exports.prepend)((0, exports.head)(as))), as.slice(m)];
        };
      };
      exports.splitAt = splitAt;
      var chunksOf = function(n) {
        return (0, exports.chop)((0, exports.splitAt)(n));
      };
      exports.chunksOf = chunksOf;
      var _map = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f));
      };
      var _mapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f));
      };
      var _ap = function(fab, fa) {
        return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
      };
      var _chain = function(ma, f) {
        return (0, function_1.pipe)(ma, (0, exports.chain)(f));
      };
      var _extend = function(wa, f) {
        return (0, function_1.pipe)(wa, (0, exports.extend)(f));
      };
      var _reduce = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f));
      };
      var _foldMap = function(M) {
        var foldMapM = (0, exports.foldMap)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapM(f));
        };
      };
      var _reduceRight = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f));
      };
      var _traverse = function(F) {
        var traverseF = (0, exports.traverse)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseF(f));
        };
      };
      var _alt = function(fa, that) {
        return (0, function_1.pipe)(fa, (0, exports.alt)(that));
      };
      var _reduceWithIndex = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f));
      };
      var _foldMapWithIndex = function(M) {
        var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapWithIndexM(f));
        };
      };
      var _reduceRightWithIndex = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f));
      };
      var _traverseWithIndex = function(F) {
        var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseWithIndexF(f));
        };
      };
      var altW = function(that) {
        return function(as) {
          return (0, function_1.pipe)(as, concatW(that()));
        };
      };
      exports.altW = altW;
      exports.alt = exports.altW;
      var ap = function(as) {
        return (0, exports.chain)(function(f) {
          return (0, function_1.pipe)(as, (0, exports.map)(f));
        });
      };
      exports.ap = ap;
      var chain = function(f) {
        return (0, exports.chainWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.chain = chain;
      var extend = function(f) {
        return function(as) {
          var next = (0, exports.tail)(as);
          var out = [f(as)];
          while ((0, exports.isNonEmpty)(next)) {
            out.push(f(next));
            next = (0, exports.tail)(next);
          }
          return out;
        };
      };
      exports.extend = extend;
      exports.duplicate = (0, exports.extend)(function_1.identity);
      exports.flatten = (0, exports.chain)(function_1.identity);
      var map = function(f) {
        return (0, exports.mapWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.map = map;
      var mapWithIndex = function(f) {
        return function(as) {
          var out = [f(0, (0, exports.head)(as))];
          for (var i = 1; i < as.length; i++) {
            out.push(f(i, as[i]));
          }
          return out;
        };
      };
      exports.mapWithIndex = mapWithIndex;
      exports.reduce = RNEA.reduce;
      exports.reduceWithIndex = RNEA.reduceWithIndex;
      exports.reduceRight = RNEA.reduceRight;
      exports.reduceRightWithIndex = RNEA.reduceRightWithIndex;
      var traverse = function(F) {
        var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
        return function(f) {
          return traverseWithIndexF(function(_2, a) {
            return f(a);
          });
        };
      };
      exports.traverse = traverse;
      var sequence = function(F) {
        return (0, exports.traverseWithIndex)(F)(function(_2, a) {
          return a;
        });
      };
      exports.sequence = sequence;
      var traverseWithIndex = function(F) {
        return function(f) {
          return function(as) {
            var out = F.map(f(0, (0, exports.head)(as)), exports.of);
            for (var i = 1; i < as.length; i++) {
              out = F.ap(F.map(out, function(bs) {
                return function(b) {
                  return (0, function_1.pipe)(bs, (0, exports.append)(b));
                };
              }), f(i, as[i]));
            }
            return out;
          };
        };
      };
      exports.traverseWithIndex = traverseWithIndex;
      exports.extract = RNEA.head;
      exports.URI = "NonEmptyArray";
      exports.getShow = RNEA.getShow;
      var getSemigroup = function() {
        return {
          concat
        };
      };
      exports.getSemigroup = getSemigroup;
      exports.getEq = RNEA.getEq;
      var getUnionSemigroup = function(E) {
        var unionE = (0, exports.union)(E);
        return {
          concat: function(first, second) {
            return unionE(second)(first);
          }
        };
      };
      exports.getUnionSemigroup = getUnionSemigroup;
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.Pointed = {
        URI: exports.URI,
        of: exports.of
      };
      exports.FunctorWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex
      };
      exports.Apply = {
        URI: exports.URI,
        map: _map,
        ap: _ap
      };
      exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
      exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
      exports.Applicative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of
      };
      exports.Chain = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain
      };
      exports.chainFirst = /* @__PURE__ */ (0, Chain_1.chainFirst)(exports.Chain);
      exports.Monad = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain
      };
      exports.Foldable = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight
      };
      exports.FoldableWithIndex = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex
      };
      exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence
      };
      exports.TraversableWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex,
        traverseWithIndex: _traverseWithIndex
      };
      exports.Alt = {
        URI: exports.URI,
        map: _map,
        alt: _alt
      };
      exports.Comonad = {
        URI: exports.URI,
        map: _map,
        extend: _extend,
        extract: exports.extract
      };
      exports.Do = (0, exports.of)(_.emptyRecord);
      exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
      var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
      exports.let = let_;
      exports.bind = (0, Chain_1.bind)(exports.Chain);
      exports.apS = (0, Apply_1.apS)(exports.Apply);
      exports.head = RNEA.head;
      var tail = function(as) {
        return as.slice(1);
      };
      exports.tail = tail;
      exports.last = RNEA.last;
      var init = function(as) {
        return as.slice(0, -1);
      };
      exports.init = init;
      exports.min = RNEA.min;
      exports.max = RNEA.max;
      var concatAll = function(S) {
        return function(as) {
          return as.reduce(S.concat);
        };
      };
      exports.concatAll = concatAll;
      var matchLeft = function(f) {
        return function(as) {
          return f((0, exports.head)(as), (0, exports.tail)(as));
        };
      };
      exports.matchLeft = matchLeft;
      var matchRight = function(f) {
        return function(as) {
          return f((0, exports.init)(as), (0, exports.last)(as));
        };
      };
      exports.matchRight = matchRight;
      var modifyHead = function(f) {
        return function(as) {
          return __spreadArray([f((0, exports.head)(as))], (0, exports.tail)(as), true);
        };
      };
      exports.modifyHead = modifyHead;
      var updateHead = function(a) {
        return (0, exports.modifyHead)(function() {
          return a;
        });
      };
      exports.updateHead = updateHead;
      var modifyLast = function(f) {
        return function(as) {
          return (0, function_1.pipe)((0, exports.init)(as), (0, exports.append)(f((0, exports.last)(as))));
        };
      };
      exports.modifyLast = modifyLast;
      var updateLast = function(a) {
        return (0, exports.modifyLast)(function() {
          return a;
        });
      };
      exports.updateLast = updateLast;
      exports.intercalate = RNEA.intercalate;
      function groupSort(O) {
        var sortO = (0, exports.sort)(O);
        var groupO = group(O);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? groupO(sortO(as)) : [];
        };
      }
      exports.groupSort = groupSort;
      function filter(predicate) {
        return (0, exports.filterWithIndex)(function(_2, a) {
          return predicate(a);
        });
      }
      exports.filter = filter;
      var filterWithIndex = function(predicate) {
        return function(as) {
          return (0, exports.fromArray)(as.filter(function(a, i) {
            return predicate(i, a);
          }));
        };
      };
      exports.filterWithIndex = filterWithIndex;
      exports.uncons = exports.unprepend;
      exports.unsnoc = exports.unappend;
      function cons(head, tail2) {
        return tail2 === void 0 ? (0, exports.prepend)(head) : (0, function_1.pipe)(tail2, (0, exports.prepend)(head));
      }
      exports.cons = cons;
      var snoc = function(init2, end) {
        return (0, function_1.pipe)(init2, (0, exports.append)(end));
      };
      exports.snoc = snoc;
      exports.prependToAll = exports.prependAll;
      exports.fold = RNEA.concatAll;
      exports.nonEmptyArray = {
        URI: exports.URI,
        of: exports.of,
        map: _map,
        mapWithIndex: _mapWithIndex,
        ap: _ap,
        chain: _chain,
        extend: _extend,
        extract: exports.extract,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex,
        traverseWithIndex: _traverseWithIndex,
        alt: _alt
      };
    }
  });

  // node_modules/fp-ts/lib/number.js
  var require_number = __commonJS({
    "node_modules/fp-ts/lib/number.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Field = exports.MonoidProduct = exports.MonoidSum = exports.SemigroupProduct = exports.SemigroupSum = exports.MagmaSub = exports.Show = exports.Bounded = exports.Ord = exports.Eq = exports.isNumber = void 0;
      var isNumber = function(u) {
        return typeof u === "number";
      };
      exports.isNumber = isNumber;
      exports.Eq = {
        equals: function(first, second) {
          return first === second;
        }
      };
      exports.Ord = {
        equals: exports.Eq.equals,
        compare: function(first, second) {
          return first < second ? -1 : first > second ? 1 : 0;
        }
      };
      exports.Bounded = {
        equals: exports.Eq.equals,
        compare: exports.Ord.compare,
        top: Infinity,
        bottom: -Infinity
      };
      exports.Show = {
        show: function(n) {
          return JSON.stringify(n);
        }
      };
      exports.MagmaSub = {
        concat: function(first, second) {
          return first - second;
        }
      };
      exports.SemigroupSum = {
        concat: function(first, second) {
          return first + second;
        }
      };
      exports.SemigroupProduct = {
        concat: function(first, second) {
          return first * second;
        }
      };
      exports.MonoidSum = {
        concat: exports.SemigroupSum.concat,
        empty: 0
      };
      exports.MonoidProduct = {
        concat: exports.SemigroupProduct.concat,
        empty: 1
      };
      exports.Field = {
        add: exports.SemigroupSum.concat,
        zero: 0,
        mul: exports.SemigroupProduct.concat,
        one: 1,
        sub: exports.MagmaSub.concat,
        degree: function(_) {
          return 1;
        },
        div: function(first, second) {
          return first / second;
        },
        mod: function(first, second) {
          return first % second;
        }
      };
    }
  });

  // node_modules/fp-ts/lib/Zero.js
  var require_Zero = __commonJS({
    "node_modules/fp-ts/lib/Zero.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.guard = void 0;
      function guard(F, P) {
        return function(b) {
          return b ? P.of(void 0) : F.zero();
        };
      }
      exports.guard = guard;
    }
  });

  // node_modules/fp-ts/lib/ReadonlyArray.js
  var require_ReadonlyArray = __commonJS({
    "node_modules/fp-ts/lib/ReadonlyArray.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sort = exports.lefts = exports.rights = exports.reverse = exports.modifyAt = exports.deleteAt = exports.updateAt = exports.insertAt = exports.findLastIndex = exports.findLastMap = exports.findLast = exports.findFirstMap = exports.findFirst = exports.findIndex = exports.dropLeftWhile = exports.dropRight = exports.dropLeft = exports.spanLeft = exports.takeLeftWhile = exports.takeRight = exports.takeLeft = exports.init = exports.tail = exports.last = exports.head = exports.lookup = exports.isOutOfBound = exports.size = exports.scanRight = exports.scanLeft = exports.chainWithIndex = exports.foldRight = exports.matchRight = exports.matchRightW = exports.foldLeft = exports.matchLeft = exports.matchLeftW = exports.match = exports.matchW = exports.fromEither = exports.fromOption = exports.fromPredicate = exports.replicate = exports.makeBy = exports.appendW = exports.append = exports.prependW = exports.prepend = exports.isNonEmpty = exports.isEmpty = void 0;
      exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.foldMap = exports.reduce = exports.foldMapWithIndex = exports.duplicate = exports.extend = exports.filterWithIndex = exports.partitionMapWithIndex = exports.partitionMap = exports.partitionWithIndex = exports.partition = exports.compact = exports.filterMap = exports.filterMapWithIndex = exports.filter = exports.separate = exports.mapWithIndex = exports.map = exports.flatten = exports.chain = exports.ap = exports.alt = exports.altW = exports.zero = exports.of = exports._chainRecBreadthFirst = exports._chainRecDepthFirst = exports.difference = exports.intersection = exports.union = exports.concat = exports.concatW = exports.comprehension = exports.fromOptionK = exports.chunksOf = exports.splitAt = exports.chop = exports.sortBy = exports.uniq = exports.elem = exports.rotate = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = void 0;
      exports.toArray = exports.unsafeDeleteAt = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.fromEitherK = exports.FromEither = exports.filterE = exports.Witherable = exports.ChainRecBreadthFirst = exports.chainRecBreadthFirst = exports.ChainRecDepthFirst = exports.chainRecDepthFirst = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.Extend = exports.Alternative = exports.guard = exports.Zero = exports.Alt = exports.Unfoldable = exports.chainFirst = exports.Monad = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getOrd = exports.getEq = exports.getMonoid = exports.getSemigroup = exports.getShow = exports.URI = exports.unfold = exports.wilt = exports.wither = exports.traverseWithIndex = void 0;
      exports.readonlyArray = exports.prependToAll = exports.snoc = exports.cons = exports.range = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.intercalate = exports.exists = exports.some = exports.every = exports.empty = exports.fromArray = void 0;
      var Apply_1 = require_Apply();
      var Chain_1 = require_Chain();
      var Eq_1 = require_Eq();
      var FromEither_1 = require_FromEither();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar(require_internal());
      var N = __importStar(require_number());
      var Ord_1 = require_Ord();
      var RNEA = __importStar(require_ReadonlyNonEmptyArray());
      var Separated_1 = require_Separated();
      var Witherable_1 = require_Witherable();
      var Zero_1 = require_Zero();
      var isEmpty = function(as) {
        return as.length === 0;
      };
      exports.isEmpty = isEmpty;
      exports.isNonEmpty = RNEA.isNonEmpty;
      exports.prepend = RNEA.prepend;
      exports.prependW = RNEA.prependW;
      exports.append = RNEA.append;
      exports.appendW = RNEA.appendW;
      var makeBy = function(n, f) {
        return n <= 0 ? exports.empty : RNEA.makeBy(f)(n);
      };
      exports.makeBy = makeBy;
      var replicate = function(n, a) {
        return (0, exports.makeBy)(n, function() {
          return a;
        });
      };
      exports.replicate = replicate;
      function fromPredicate(predicate) {
        return function(a) {
          return predicate(a) ? [a] : exports.empty;
        };
      }
      exports.fromPredicate = fromPredicate;
      var fromOption = function(ma) {
        return _.isNone(ma) ? exports.empty : [ma.value];
      };
      exports.fromOption = fromOption;
      var fromEither = function(e) {
        return _.isLeft(e) ? exports.empty : [e.right];
      };
      exports.fromEither = fromEither;
      var matchW = function(onEmpty, onNonEmpty) {
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? onNonEmpty(as) : onEmpty();
        };
      };
      exports.matchW = matchW;
      exports.match = exports.matchW;
      var matchLeftW = function(onEmpty, onNonEmpty) {
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();
        };
      };
      exports.matchLeftW = matchLeftW;
      exports.matchLeft = exports.matchLeftW;
      exports.foldLeft = exports.matchLeft;
      var matchRightW = function(onEmpty, onNonEmpty) {
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();
        };
      };
      exports.matchRightW = matchRightW;
      exports.matchRight = exports.matchRightW;
      exports.foldRight = exports.matchRight;
      var chainWithIndex = function(f) {
        return function(as) {
          if ((0, exports.isEmpty)(as)) {
            return exports.empty;
          }
          var out = [];
          for (var i = 0; i < as.length; i++) {
            out.push.apply(out, f(i, as[i]));
          }
          return out;
        };
      };
      exports.chainWithIndex = chainWithIndex;
      var scanLeft = function(b, f) {
        return function(as) {
          var len = as.length;
          var out = new Array(len + 1);
          out[0] = b;
          for (var i = 0; i < len; i++) {
            out[i + 1] = f(out[i], as[i]);
          }
          return out;
        };
      };
      exports.scanLeft = scanLeft;
      var scanRight = function(b, f) {
        return function(as) {
          var len = as.length;
          var out = new Array(len + 1);
          out[len] = b;
          for (var i = len - 1; i >= 0; i--) {
            out[i] = f(as[i], out[i + 1]);
          }
          return out;
        };
      };
      exports.scanRight = scanRight;
      var size = function(as) {
        return as.length;
      };
      exports.size = size;
      exports.isOutOfBound = RNEA.isOutOfBound;
      function lookup(i, as) {
        return as === void 0 ? function(as2) {
          return lookup(i, as2);
        } : (0, exports.isOutOfBound)(i, as) ? _.none : _.some(as[i]);
      }
      exports.lookup = lookup;
      var head = function(as) {
        return (0, exports.isNonEmpty)(as) ? _.some(RNEA.head(as)) : _.none;
      };
      exports.head = head;
      var last = function(as) {
        return (0, exports.isNonEmpty)(as) ? _.some(RNEA.last(as)) : _.none;
      };
      exports.last = last;
      var tail = function(as) {
        return (0, exports.isNonEmpty)(as) ? _.some(RNEA.tail(as)) : _.none;
      };
      exports.tail = tail;
      var init = function(as) {
        return (0, exports.isNonEmpty)(as) ? _.some(RNEA.init(as)) : _.none;
      };
      exports.init = init;
      var takeLeft = function(n) {
        return function(as) {
          return (0, exports.isOutOfBound)(n, as) ? as : n === 0 ? exports.empty : as.slice(0, n);
        };
      };
      exports.takeLeft = takeLeft;
      var takeRight = function(n) {
        return function(as) {
          return (0, exports.isOutOfBound)(n, as) ? as : n === 0 ? exports.empty : as.slice(-n);
        };
      };
      exports.takeRight = takeRight;
      function takeLeftWhile(predicate) {
        return function(as) {
          var out = [];
          for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
            var a = as_1[_i];
            if (!predicate(a)) {
              break;
            }
            out.push(a);
          }
          var len = out.length;
          return len === as.length ? as : len === 0 ? exports.empty : out;
        };
      }
      exports.takeLeftWhile = takeLeftWhile;
      var spanLeftIndex = function(as, predicate) {
        var l = as.length;
        var i = 0;
        for (; i < l; i++) {
          if (!predicate(as[i])) {
            break;
          }
        }
        return i;
      };
      function spanLeft(predicate) {
        return function(as) {
          var _a = (0, exports.splitAt)(spanLeftIndex(as, predicate))(as), init2 = _a[0], rest = _a[1];
          return { init: init2, rest };
        };
      }
      exports.spanLeft = spanLeft;
      var dropLeft = function(n) {
        return function(as) {
          return n <= 0 || (0, exports.isEmpty)(as) ? as : n >= as.length ? exports.empty : as.slice(n, as.length);
        };
      };
      exports.dropLeft = dropLeft;
      var dropRight = function(n) {
        return function(as) {
          return n <= 0 || (0, exports.isEmpty)(as) ? as : n >= as.length ? exports.empty : as.slice(0, as.length - n);
        };
      };
      exports.dropRight = dropRight;
      function dropLeftWhile(predicate) {
        return function(as) {
          var i = spanLeftIndex(as, predicate);
          return i === 0 ? as : i === as.length ? exports.empty : as.slice(i);
        };
      }
      exports.dropLeftWhile = dropLeftWhile;
      var findIndex = function(predicate) {
        return function(as) {
          for (var i = 0; i < as.length; i++) {
            if (predicate(as[i])) {
              return _.some(i);
            }
          }
          return _.none;
        };
      };
      exports.findIndex = findIndex;
      function findFirst(predicate) {
        return function(as) {
          for (var i = 0; i < as.length; i++) {
            if (predicate(as[i])) {
              return _.some(as[i]);
            }
          }
          return _.none;
        };
      }
      exports.findFirst = findFirst;
      var findFirstMap = function(f) {
        return function(as) {
          for (var i = 0; i < as.length; i++) {
            var out = f(as[i]);
            if (_.isSome(out)) {
              return out;
            }
          }
          return _.none;
        };
      };
      exports.findFirstMap = findFirstMap;
      function findLast(predicate) {
        return function(as) {
          for (var i = as.length - 1; i >= 0; i--) {
            if (predicate(as[i])) {
              return _.some(as[i]);
            }
          }
          return _.none;
        };
      }
      exports.findLast = findLast;
      var findLastMap = function(f) {
        return function(as) {
          for (var i = as.length - 1; i >= 0; i--) {
            var out = f(as[i]);
            if (_.isSome(out)) {
              return out;
            }
          }
          return _.none;
        };
      };
      exports.findLastMap = findLastMap;
      var findLastIndex = function(predicate) {
        return function(as) {
          for (var i = as.length - 1; i >= 0; i--) {
            if (predicate(as[i])) {
              return _.some(i);
            }
          }
          return _.none;
        };
      };
      exports.findLastIndex = findLastIndex;
      var insertAt = function(i, a) {
        return function(as) {
          return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));
        };
      };
      exports.insertAt = insertAt;
      var updateAt = function(i, a) {
        return (0, exports.modifyAt)(i, function() {
          return a;
        });
      };
      exports.updateAt = updateAt;
      var deleteAt = function(i) {
        return function(as) {
          return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeDeleteAt)(i, as));
        };
      };
      exports.deleteAt = deleteAt;
      var modifyAt = function(i, f) {
        return function(as) {
          return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f(as[i]), as));
        };
      };
      exports.modifyAt = modifyAt;
      var reverse = function(as) {
        return as.length <= 1 ? as : as.slice().reverse();
      };
      exports.reverse = reverse;
      var rights = function(as) {
        var r = [];
        for (var i = 0; i < as.length; i++) {
          var a = as[i];
          if (a._tag === "Right") {
            r.push(a.right);
          }
        }
        return r;
      };
      exports.rights = rights;
      var lefts = function(as) {
        var r = [];
        for (var i = 0; i < as.length; i++) {
          var a = as[i];
          if (a._tag === "Left") {
            r.push(a.left);
          }
        }
        return r;
      };
      exports.lefts = lefts;
      var sort = function(O) {
        return function(as) {
          return as.length <= 1 ? as : as.slice().sort(O.compare);
        };
      };
      exports.sort = sort;
      var zipWith = function(fa, fb, f) {
        var fc = [];
        var len = Math.min(fa.length, fb.length);
        for (var i = 0; i < len; i++) {
          fc[i] = f(fa[i], fb[i]);
        }
        return fc;
      };
      exports.zipWith = zipWith;
      function zip(as, bs) {
        if (bs === void 0) {
          return function(bs2) {
            return zip(bs2, as);
          };
        }
        return (0, exports.zipWith)(as, bs, function(a, b) {
          return [a, b];
        });
      }
      exports.zip = zip;
      var unzip = function(as) {
        var fa = [];
        var fb = [];
        for (var i = 0; i < as.length; i++) {
          fa[i] = as[i][0];
          fb[i] = as[i][1];
        }
        return [fa, fb];
      };
      exports.unzip = unzip;
      var prependAll = function(middle) {
        var f = RNEA.prependAll(middle);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : as;
        };
      };
      exports.prependAll = prependAll;
      var intersperse = function(middle) {
        var f = RNEA.intersperse(middle);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : as;
        };
      };
      exports.intersperse = intersperse;
      var rotate = function(n) {
        var f = RNEA.rotate(n);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : as;
        };
      };
      exports.rotate = rotate;
      function elem(E) {
        return function(a, as) {
          if (as === void 0) {
            var elemE_1 = elem(E);
            return function(as2) {
              return elemE_1(a, as2);
            };
          }
          var predicate = function(element) {
            return E.equals(element, a);
          };
          var i = 0;
          for (; i < as.length; i++) {
            if (predicate(as[i])) {
              return true;
            }
          }
          return false;
        };
      }
      exports.elem = elem;
      var uniq = function(E) {
        var f = RNEA.uniq(E);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : as;
        };
      };
      exports.uniq = uniq;
      var sortBy = function(ords) {
        var f = RNEA.sortBy(ords);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : as;
        };
      };
      exports.sortBy = sortBy;
      var chop = function(f) {
        var g = RNEA.chop(f);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? g(as) : exports.empty;
        };
      };
      exports.chop = chop;
      var splitAt = function(n) {
        return function(as) {
          return n >= 1 && (0, exports.isNonEmpty)(as) ? RNEA.splitAt(n)(as) : (0, exports.isEmpty)(as) ? [as, exports.empty] : [exports.empty, as];
        };
      };
      exports.splitAt = splitAt;
      var chunksOf = function(n) {
        var f = RNEA.chunksOf(n);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : exports.empty;
        };
      };
      exports.chunksOf = chunksOf;
      var fromOptionK = function(f) {
        return function() {
          var a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
          }
          return (0, exports.fromOption)(f.apply(void 0, a));
        };
      };
      exports.fromOptionK = fromOptionK;
      function comprehension(input, f, g) {
        if (g === void 0) {
          g = function() {
            return true;
          };
        }
        var go = function(scope, input2) {
          return (0, exports.isNonEmpty)(input2) ? (0, function_1.pipe)(RNEA.head(input2), (0, exports.chain)(function(x) {
            return go((0, function_1.pipe)(scope, (0, exports.append)(x)), RNEA.tail(input2));
          })) : g.apply(void 0, scope) ? [f.apply(void 0, scope)] : exports.empty;
        };
        return go(exports.empty, input);
      }
      exports.comprehension = comprehension;
      var concatW = function(second) {
        return function(first) {
          return (0, exports.isEmpty)(first) ? second : (0, exports.isEmpty)(second) ? first : first.concat(second);
        };
      };
      exports.concatW = concatW;
      exports.concat = exports.concatW;
      function union(E) {
        var unionE = RNEA.union(E);
        return function(first, second) {
          if (second === void 0) {
            var unionE_1 = union(E);
            return function(second2) {
              return unionE_1(second2, first);
            };
          }
          return (0, exports.isNonEmpty)(first) && (0, exports.isNonEmpty)(second) ? unionE(second)(first) : (0, exports.isNonEmpty)(first) ? first : second;
        };
      }
      exports.union = union;
      function intersection(E) {
        var elemE = elem(E);
        return function(xs, ys) {
          if (ys === void 0) {
            var intersectionE_1 = intersection(E);
            return function(ys2) {
              return intersectionE_1(ys2, xs);
            };
          }
          return xs.filter(function(a) {
            return elemE(a, ys);
          });
        };
      }
      exports.intersection = intersection;
      function difference(E) {
        var elemE = elem(E);
        return function(xs, ys) {
          if (ys === void 0) {
            var differenceE_1 = difference(E);
            return function(ys2) {
              return differenceE_1(ys2, xs);
            };
          }
          return xs.filter(function(a) {
            return !elemE(a, ys);
          });
        };
      }
      exports.difference = difference;
      var _map = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f));
      };
      var _mapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f));
      };
      var _ap = function(fab, fa) {
        return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
      };
      var _chain = function(ma, f) {
        return (0, function_1.pipe)(ma, (0, exports.chain)(f));
      };
      var _filter = function(fa, predicate) {
        return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));
      };
      var _filterMap = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.filterMap)(f));
      };
      var _partition = function(fa, predicate) {
        return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
      };
      var _partitionMap = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f));
      };
      var _partitionWithIndex = function(fa, predicateWithIndex) {
        return (0, function_1.pipe)(fa, (0, exports.partitionWithIndex)(predicateWithIndex));
      };
      var _partitionMapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.partitionMapWithIndex)(f));
      };
      var _alt = function(fa, that) {
        return (0, function_1.pipe)(fa, (0, exports.alt)(that));
      };
      var _reduce = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f));
      };
      var _foldMap = function(M) {
        var foldMapM = (0, exports.foldMap)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapM(f));
        };
      };
      var _reduceRight = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f));
      };
      var _reduceWithIndex = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f));
      };
      var _foldMapWithIndex = function(M) {
        var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapWithIndexM(f));
        };
      };
      var _reduceRightWithIndex = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f));
      };
      var _filterMapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.filterMapWithIndex)(f));
      };
      var _filterWithIndex = function(fa, predicateWithIndex) {
        return (0, function_1.pipe)(fa, (0, exports.filterWithIndex)(predicateWithIndex));
      };
      var _extend = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.extend)(f));
      };
      var _traverse = function(F) {
        var traverseF = (0, exports.traverse)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseF(f));
        };
      };
      var _traverseWithIndex = function(F) {
        var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseWithIndexF(f));
        };
      };
      var _chainRecDepthFirst = function(a, f) {
        return (0, function_1.pipe)(a, (0, exports.chainRecDepthFirst)(f));
      };
      exports._chainRecDepthFirst = _chainRecDepthFirst;
      var _chainRecBreadthFirst = function(a, f) {
        return (0, function_1.pipe)(a, (0, exports.chainRecBreadthFirst)(f));
      };
      exports._chainRecBreadthFirst = _chainRecBreadthFirst;
      exports.of = RNEA.of;
      var zero = function() {
        return exports.empty;
      };
      exports.zero = zero;
      var altW = function(that) {
        return function(fa) {
          return fa.concat(that());
        };
      };
      exports.altW = altW;
      exports.alt = exports.altW;
      var ap = function(fa) {
        return (0, exports.chain)(function(f) {
          return (0, function_1.pipe)(fa, (0, exports.map)(f));
        });
      };
      exports.ap = ap;
      var chain = function(f) {
        return function(ma) {
          return (0, function_1.pipe)(ma, (0, exports.chainWithIndex)(function(_2, a) {
            return f(a);
          }));
        };
      };
      exports.chain = chain;
      exports.flatten = (0, exports.chain)(function_1.identity);
      var map = function(f) {
        return function(fa) {
          return fa.map(function(a) {
            return f(a);
          });
        };
      };
      exports.map = map;
      var mapWithIndex = function(f) {
        return function(fa) {
          return fa.map(function(a, i) {
            return f(i, a);
          });
        };
      };
      exports.mapWithIndex = mapWithIndex;
      var separate = function(fa) {
        var left = [];
        var right = [];
        for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
          var e = fa_1[_i];
          if (e._tag === "Left") {
            left.push(e.left);
          } else {
            right.push(e.right);
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
      exports.separate = separate;
      var filter = function(predicate) {
        return function(as) {
          return as.filter(predicate);
        };
      };
      exports.filter = filter;
      var filterMapWithIndex = function(f) {
        return function(fa) {
          var out = [];
          for (var i = 0; i < fa.length; i++) {
            var optionB = f(i, fa[i]);
            if (_.isSome(optionB)) {
              out.push(optionB.value);
            }
          }
          return out;
        };
      };
      exports.filterMapWithIndex = filterMapWithIndex;
      var filterMap = function(f) {
        return (0, exports.filterMapWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.filterMap = filterMap;
      exports.compact = (0, exports.filterMap)(function_1.identity);
      var partition = function(predicate) {
        return (0, exports.partitionWithIndex)(function(_2, a) {
          return predicate(a);
        });
      };
      exports.partition = partition;
      var partitionWithIndex = function(predicateWithIndex) {
        return function(as) {
          var left = [];
          var right = [];
          for (var i = 0; i < as.length; i++) {
            var a = as[i];
            if (predicateWithIndex(i, a)) {
              right.push(a);
            } else {
              left.push(a);
            }
          }
          return (0, Separated_1.separated)(left, right);
        };
      };
      exports.partitionWithIndex = partitionWithIndex;
      var partitionMap = function(f) {
        return (0, exports.partitionMapWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.partitionMap = partitionMap;
      var partitionMapWithIndex = function(f) {
        return function(fa) {
          var left = [];
          var right = [];
          for (var i = 0; i < fa.length; i++) {
            var e = f(i, fa[i]);
            if (e._tag === "Left") {
              left.push(e.left);
            } else {
              right.push(e.right);
            }
          }
          return (0, Separated_1.separated)(left, right);
        };
      };
      exports.partitionMapWithIndex = partitionMapWithIndex;
      var filterWithIndex = function(predicateWithIndex) {
        return function(as) {
          return as.filter(function(a, i) {
            return predicateWithIndex(i, a);
          });
        };
      };
      exports.filterWithIndex = filterWithIndex;
      var extend = function(f) {
        return function(wa) {
          return wa.map(function(_2, i) {
            return f(wa.slice(i));
          });
        };
      };
      exports.extend = extend;
      exports.duplicate = (0, exports.extend)(function_1.identity);
      var foldMapWithIndex = function(M) {
        return function(f) {
          return function(fa) {
            return fa.reduce(function(b, a, i) {
              return M.concat(b, f(i, a));
            }, M.empty);
          };
        };
      };
      exports.foldMapWithIndex = foldMapWithIndex;
      var reduce = function(b, f) {
        return (0, exports.reduceWithIndex)(b, function(_2, b2, a) {
          return f(b2, a);
        });
      };
      exports.reduce = reduce;
      var foldMap = function(M) {
        var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
        return function(f) {
          return foldMapWithIndexM(function(_2, a) {
            return f(a);
          });
        };
      };
      exports.foldMap = foldMap;
      var reduceWithIndex = function(b, f) {
        return function(fa) {
          var len = fa.length;
          var out = b;
          for (var i = 0; i < len; i++) {
            out = f(i, out, fa[i]);
          }
          return out;
        };
      };
      exports.reduceWithIndex = reduceWithIndex;
      var reduceRight = function(b, f) {
        return (0, exports.reduceRightWithIndex)(b, function(_2, a, b2) {
          return f(a, b2);
        });
      };
      exports.reduceRight = reduceRight;
      var reduceRightWithIndex = function(b, f) {
        return function(fa) {
          return fa.reduceRight(function(b2, a, i) {
            return f(i, a, b2);
          }, b);
        };
      };
      exports.reduceRightWithIndex = reduceRightWithIndex;
      var traverse = function(F) {
        var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
        return function(f) {
          return traverseWithIndexF(function(_2, a) {
            return f(a);
          });
        };
      };
      exports.traverse = traverse;
      var sequence = function(F) {
        return function(ta) {
          return _reduce(ta, F.of((0, exports.zero)()), function(fas, fa) {
            return F.ap(F.map(fas, function(as) {
              return function(a) {
                return (0, function_1.pipe)(as, (0, exports.append)(a));
              };
            }), fa);
          });
        };
      };
      exports.sequence = sequence;
      var traverseWithIndex = function(F) {
        return function(f) {
          return (0, exports.reduceWithIndex)(F.of((0, exports.zero)()), function(i, fbs, a) {
            return F.ap(F.map(fbs, function(bs) {
              return function(b) {
                return (0, function_1.pipe)(bs, (0, exports.append)(b));
              };
            }), f(i, a));
          });
        };
      };
      exports.traverseWithIndex = traverseWithIndex;
      var wither = function(F) {
        var _witherF = _wither(F);
        return function(f) {
          return function(fa) {
            return _witherF(fa, f);
          };
        };
      };
      exports.wither = wither;
      var wilt = function(F) {
        var _wiltF = _wilt(F);
        return function(f) {
          return function(fa) {
            return _wiltF(fa, f);
          };
        };
      };
      exports.wilt = wilt;
      var unfold = function(b, f) {
        var out = [];
        var bb = b;
        while (true) {
          var mt = f(bb);
          if (_.isSome(mt)) {
            var _a = mt.value, a = _a[0], b_1 = _a[1];
            out.push(a);
            bb = b_1;
          } else {
            break;
          }
        }
        return out;
      };
      exports.unfold = unfold;
      exports.URI = "ReadonlyArray";
      var getShow = function(S) {
        return {
          show: function(as) {
            return "[".concat(as.map(S.show).join(", "), "]");
          }
        };
      };
      exports.getShow = getShow;
      var getSemigroup = function() {
        return {
          concat: function(first, second) {
            return (0, exports.isEmpty)(first) ? second : (0, exports.isEmpty)(second) ? first : first.concat(second);
          }
        };
      };
      exports.getSemigroup = getSemigroup;
      var getMonoid = function() {
        return {
          concat: (0, exports.getSemigroup)().concat,
          empty: exports.empty
        };
      };
      exports.getMonoid = getMonoid;
      var getEq = function(E) {
        return (0, Eq_1.fromEquals)(function(xs, ys) {
          return xs.length === ys.length && xs.every(function(x, i) {
            return E.equals(x, ys[i]);
          });
        });
      };
      exports.getEq = getEq;
      var getOrd = function(O) {
        return (0, Ord_1.fromCompare)(function(a, b) {
          var aLen = a.length;
          var bLen = b.length;
          var len = Math.min(aLen, bLen);
          for (var i = 0; i < len; i++) {
            var ordering = O.compare(a[i], b[i]);
            if (ordering !== 0) {
              return ordering;
            }
          }
          return N.Ord.compare(aLen, bLen);
        });
      };
      exports.getOrd = getOrd;
      var getUnionSemigroup = function(E) {
        var unionE = union(E);
        return {
          concat: function(first, second) {
            return unionE(second)(first);
          }
        };
      };
      exports.getUnionSemigroup = getUnionSemigroup;
      var getUnionMonoid = function(E) {
        return {
          concat: (0, exports.getUnionSemigroup)(E).concat,
          empty: exports.empty
        };
      };
      exports.getUnionMonoid = getUnionMonoid;
      var getIntersectionSemigroup = function(E) {
        var intersectionE = intersection(E);
        return {
          concat: function(first, second) {
            return intersectionE(second)(first);
          }
        };
      };
      exports.getIntersectionSemigroup = getIntersectionSemigroup;
      var getDifferenceMagma = function(E) {
        var differenceE = difference(E);
        return {
          concat: function(first, second) {
            return differenceE(second)(first);
          }
        };
      };
      exports.getDifferenceMagma = getDifferenceMagma;
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.Pointed = {
        URI: exports.URI,
        of: exports.of
      };
      exports.FunctorWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex
      };
      exports.Apply = {
        URI: exports.URI,
        map: _map,
        ap: _ap
      };
      exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
      exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
      exports.Applicative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of
      };
      exports.Chain = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain
      };
      exports.Monad = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain
      };
      exports.chainFirst = /* @__PURE__ */ (0, Chain_1.chainFirst)(exports.Chain);
      exports.Unfoldable = {
        URI: exports.URI,
        unfold: exports.unfold
      };
      exports.Alt = {
        URI: exports.URI,
        map: _map,
        alt: _alt
      };
      exports.Zero = {
        URI: exports.URI,
        zero: exports.zero
      };
      exports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);
      exports.Alternative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        alt: _alt,
        zero: exports.zero
      };
      exports.Extend = {
        URI: exports.URI,
        map: _map,
        extend: _extend
      };
      exports.Compactable = {
        URI: exports.URI,
        compact: exports.compact,
        separate: exports.separate
      };
      exports.Filterable = {
        URI: exports.URI,
        map: _map,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap
      };
      exports.FilterableWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex,
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex
      };
      exports.Foldable = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight
      };
      exports.FoldableWithIndex = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex
      };
      exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence
      };
      exports.TraversableWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex,
        traverse: _traverse,
        sequence: exports.sequence,
        traverseWithIndex: _traverseWithIndex
      };
      var chainRecDepthFirst = function(f) {
        return function(a) {
          var todo = __spreadArray([], f(a), true);
          var out = [];
          while (todo.length > 0) {
            var e = todo.shift();
            if (_.isLeft(e)) {
              todo.unshift.apply(todo, f(e.left));
            } else {
              out.push(e.right);
            }
          }
          return out;
        };
      };
      exports.chainRecDepthFirst = chainRecDepthFirst;
      exports.ChainRecDepthFirst = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain,
        chainRec: exports._chainRecDepthFirst
      };
      var chainRecBreadthFirst = function(f) {
        return function(a) {
          var initial = f(a);
          var todo = [];
          var out = [];
          function go(e2) {
            if (_.isLeft(e2)) {
              f(e2.left).forEach(function(v) {
                return todo.push(v);
              });
            } else {
              out.push(e2.right);
            }
          }
          for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {
            var e = initial_1[_i];
            go(e);
          }
          while (todo.length > 0) {
            go(todo.shift());
          }
          return out;
        };
      };
      exports.chainRecBreadthFirst = chainRecBreadthFirst;
      exports.ChainRecBreadthFirst = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain,
        chainRec: exports._chainRecBreadthFirst
      };
      var _wither = /* @__PURE__ */ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
      var _wilt = /* @__PURE__ */ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
      exports.Witherable = {
        URI: exports.URI,
        map: _map,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        wither: _wither,
        wilt: _wilt
      };
      exports.filterE = (0, Witherable_1.filterE)(exports.Witherable);
      exports.FromEither = {
        URI: exports.URI,
        fromEither: exports.fromEither
      };
      exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
      exports.unsafeInsertAt = RNEA.unsafeInsertAt;
      var unsafeUpdateAt = function(i, a, as) {
        return (0, exports.isNonEmpty)(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;
      };
      exports.unsafeUpdateAt = unsafeUpdateAt;
      var unsafeDeleteAt = function(i, as) {
        var xs = as.slice();
        xs.splice(i, 1);
        return xs;
      };
      exports.unsafeDeleteAt = unsafeDeleteAt;
      var toArray = function(as) {
        return as.slice();
      };
      exports.toArray = toArray;
      var fromArray = function(as) {
        return (0, exports.isEmpty)(as) ? exports.empty : as.slice();
      };
      exports.fromArray = fromArray;
      exports.empty = RNEA.empty;
      function every(predicate) {
        return function(as) {
          return as.every(predicate);
        };
      }
      exports.every = every;
      var some = function(predicate) {
        return function(as) {
          return as.some(predicate);
        };
      };
      exports.some = some;
      exports.exists = exports.some;
      var intercalate = function(M) {
        var intercalateM = RNEA.intercalate(M);
        return function(middle) {
          return (0, exports.match)(function() {
            return M.empty;
          }, intercalateM(middle));
        };
      };
      exports.intercalate = intercalate;
      exports.Do = (0, exports.of)(_.emptyRecord);
      exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
      var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
      exports.let = let_;
      exports.bind = (0, Chain_1.bind)(exports.Chain);
      exports.apS = (0, Apply_1.apS)(exports.Apply);
      exports.range = RNEA.range;
      exports.cons = RNEA.cons;
      exports.snoc = RNEA.snoc;
      exports.prependToAll = exports.prependAll;
      exports.readonlyArray = {
        URI: exports.URI,
        compact: exports.compact,
        separate: exports.separate,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        mapWithIndex: _mapWithIndex,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex,
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex,
        alt: _alt,
        zero: exports.zero,
        unfold: exports.unfold,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex,
        traverseWithIndex: _traverseWithIndex,
        extend: _extend,
        wither: _wither,
        wilt: _wilt
      };
    }
  });

  // node_modules/fp-ts/lib/Array.js
  var require_Array = __commonJS({
    "node_modules/fp-ts/lib/Array.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.lefts = exports.rights = exports.reverse = exports.modifyAt = exports.deleteAt = exports.updateAt = exports.insertAt = exports.copy = exports.findLastIndex = exports.findLastMap = exports.findLast = exports.findFirstMap = exports.findFirst = exports.findIndex = exports.dropLeftWhile = exports.dropRight = exports.dropLeft = exports.spanLeft = exports.takeLeftWhile = exports.takeRight = exports.takeLeft = exports.init = exports.tail = exports.last = exports.head = exports.lookup = exports.isOutOfBound = exports.size = exports.scanRight = exports.scanLeft = exports.chainWithIndex = exports.foldRight = exports.matchRight = exports.matchRightW = exports.foldLeft = exports.matchLeft = exports.matchLeftW = exports.match = exports.matchW = exports.fromEither = exports.fromOption = exports.fromPredicate = exports.replicate = exports.makeBy = exports.appendW = exports.append = exports.prependW = exports.prepend = exports.isNonEmpty = exports.isEmpty = void 0;
      exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.reduce = exports.foldMapWithIndex = exports.foldMap = exports.duplicate = exports.extend = exports.filterWithIndex = exports.alt = exports.altW = exports.partitionMapWithIndex = exports.partitionMap = exports.partitionWithIndex = exports.partition = exports.filter = exports.separate = exports.compact = exports.filterMap = exports.filterMapWithIndex = exports.mapWithIndex = exports.flatten = exports.chain = exports.ap = exports.map = exports.zero = exports.of = exports.difference = exports.intersection = exports.union = exports.concat = exports.concatW = exports.comprehension = exports.fromOptionK = exports.chunksOf = exports.splitAt = exports.chop = exports.sortBy = exports.uniq = exports.elem = exports.rotate = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = exports.sort = void 0;
      exports.some = exports.every = exports.unsafeDeleteAt = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.fromEitherK = exports.FromEither = exports.filterE = exports.ChainRecBreadthFirst = exports.chainRecBreadthFirst = exports.ChainRecDepthFirst = exports.chainRecDepthFirst = exports.Witherable = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.Extend = exports.Alternative = exports.guard = exports.Zero = exports.Alt = exports.Unfoldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getOrd = exports.getEq = exports.getMonoid = exports.getSemigroup = exports.getShow = exports.URI = exports.unfold = exports.wilt = exports.wither = void 0;
      exports.array = exports.prependToAll = exports.snoc = exports.cons = exports.empty = exports.range = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.intercalate = exports.exists = void 0;
      var Apply_1 = require_Apply();
      var Chain_1 = require_Chain();
      var FromEither_1 = require_FromEither();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar(require_internal());
      var NEA = __importStar(require_NonEmptyArray());
      var RA = __importStar(require_ReadonlyArray());
      var Separated_1 = require_Separated();
      var Witherable_1 = require_Witherable();
      var Zero_1 = require_Zero();
      var isEmpty = function(as) {
        return as.length === 0;
      };
      exports.isEmpty = isEmpty;
      exports.isNonEmpty = NEA.isNonEmpty;
      exports.prepend = NEA.prepend;
      exports.prependW = NEA.prependW;
      exports.append = NEA.append;
      exports.appendW = NEA.appendW;
      var makeBy = function(n, f) {
        return n <= 0 ? [] : NEA.makeBy(f)(n);
      };
      exports.makeBy = makeBy;
      var replicate = function(n, a) {
        return (0, exports.makeBy)(n, function() {
          return a;
        });
      };
      exports.replicate = replicate;
      function fromPredicate(predicate) {
        return function(a) {
          return predicate(a) ? [a] : [];
        };
      }
      exports.fromPredicate = fromPredicate;
      var fromOption = function(ma) {
        return _.isNone(ma) ? [] : [ma.value];
      };
      exports.fromOption = fromOption;
      var fromEither = function(e) {
        return _.isLeft(e) ? [] : [e.right];
      };
      exports.fromEither = fromEither;
      var matchW = function(onEmpty, onNonEmpty) {
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? onNonEmpty(as) : onEmpty();
        };
      };
      exports.matchW = matchW;
      exports.match = exports.matchW;
      var matchLeftW = function(onEmpty, onNonEmpty) {
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? onNonEmpty(NEA.head(as), NEA.tail(as)) : onEmpty();
        };
      };
      exports.matchLeftW = matchLeftW;
      exports.matchLeft = exports.matchLeftW;
      exports.foldLeft = exports.matchLeft;
      var matchRightW = function(onEmpty, onNonEmpty) {
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? onNonEmpty(NEA.init(as), NEA.last(as)) : onEmpty();
        };
      };
      exports.matchRightW = matchRightW;
      exports.matchRight = exports.matchRightW;
      exports.foldRight = exports.matchRight;
      var chainWithIndex = function(f) {
        return function(as) {
          var out = [];
          for (var i = 0; i < as.length; i++) {
            out.push.apply(out, f(i, as[i]));
          }
          return out;
        };
      };
      exports.chainWithIndex = chainWithIndex;
      var scanLeft = function(b, f) {
        return function(as) {
          var len = as.length;
          var out = new Array(len + 1);
          out[0] = b;
          for (var i = 0; i < len; i++) {
            out[i + 1] = f(out[i], as[i]);
          }
          return out;
        };
      };
      exports.scanLeft = scanLeft;
      var scanRight = function(b, f) {
        return function(as) {
          var len = as.length;
          var out = new Array(len + 1);
          out[len] = b;
          for (var i = len - 1; i >= 0; i--) {
            out[i] = f(as[i], out[i + 1]);
          }
          return out;
        };
      };
      exports.scanRight = scanRight;
      var size = function(as) {
        return as.length;
      };
      exports.size = size;
      exports.isOutOfBound = NEA.isOutOfBound;
      exports.lookup = RA.lookup;
      exports.head = RA.head;
      exports.last = RA.last;
      var tail = function(as) {
        return (0, exports.isNonEmpty)(as) ? _.some(NEA.tail(as)) : _.none;
      };
      exports.tail = tail;
      var init = function(as) {
        return (0, exports.isNonEmpty)(as) ? _.some(NEA.init(as)) : _.none;
      };
      exports.init = init;
      var takeLeft = function(n) {
        return function(as) {
          return (0, exports.isOutOfBound)(n, as) ? (0, exports.copy)(as) : as.slice(0, n);
        };
      };
      exports.takeLeft = takeLeft;
      var takeRight = function(n) {
        return function(as) {
          return (0, exports.isOutOfBound)(n, as) ? (0, exports.copy)(as) : n === 0 ? [] : as.slice(-n);
        };
      };
      exports.takeRight = takeRight;
      function takeLeftWhile(predicate) {
        return function(as) {
          var out = [];
          for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
            var a = as_1[_i];
            if (!predicate(a)) {
              break;
            }
            out.push(a);
          }
          return out;
        };
      }
      exports.takeLeftWhile = takeLeftWhile;
      var spanLeftIndex = function(as, predicate) {
        var l = as.length;
        var i = 0;
        for (; i < l; i++) {
          if (!predicate(as[i])) {
            break;
          }
        }
        return i;
      };
      function spanLeft(predicate) {
        return function(as) {
          var _a = (0, exports.splitAt)(spanLeftIndex(as, predicate))(as), init2 = _a[0], rest = _a[1];
          return { init: init2, rest };
        };
      }
      exports.spanLeft = spanLeft;
      var dropLeft = function(n) {
        return function(as) {
          return n <= 0 || (0, exports.isEmpty)(as) ? (0, exports.copy)(as) : n >= as.length ? [] : as.slice(n, as.length);
        };
      };
      exports.dropLeft = dropLeft;
      var dropRight = function(n) {
        return function(as) {
          return n <= 0 || (0, exports.isEmpty)(as) ? (0, exports.copy)(as) : n >= as.length ? [] : as.slice(0, as.length - n);
        };
      };
      exports.dropRight = dropRight;
      function dropLeftWhile(predicate) {
        return function(as) {
          return as.slice(spanLeftIndex(as, predicate));
        };
      }
      exports.dropLeftWhile = dropLeftWhile;
      exports.findIndex = RA.findIndex;
      function findFirst(predicate) {
        return RA.findFirst(predicate);
      }
      exports.findFirst = findFirst;
      exports.findFirstMap = RA.findFirstMap;
      function findLast(predicate) {
        return RA.findLast(predicate);
      }
      exports.findLast = findLast;
      exports.findLastMap = RA.findLastMap;
      exports.findLastIndex = RA.findLastIndex;
      var copy = function(as) {
        return as.slice();
      };
      exports.copy = copy;
      var insertAt = function(i, a) {
        return function(as) {
          return i < 0 || i > as.length ? _.none : _.some((0, exports.unsafeInsertAt)(i, a, as));
        };
      };
      exports.insertAt = insertAt;
      var updateAt = function(i, a) {
        return (0, exports.modifyAt)(i, function() {
          return a;
        });
      };
      exports.updateAt = updateAt;
      var deleteAt = function(i) {
        return function(as) {
          return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeDeleteAt)(i, as));
        };
      };
      exports.deleteAt = deleteAt;
      var modifyAt = function(i, f) {
        return function(as) {
          return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f(as[i]), as));
        };
      };
      exports.modifyAt = modifyAt;
      var reverse = function(as) {
        return (0, exports.isEmpty)(as) ? [] : as.slice().reverse();
      };
      exports.reverse = reverse;
      var rights = function(as) {
        var r = [];
        for (var i = 0; i < as.length; i++) {
          var a = as[i];
          if (a._tag === "Right") {
            r.push(a.right);
          }
        }
        return r;
      };
      exports.rights = rights;
      var lefts = function(as) {
        var r = [];
        for (var i = 0; i < as.length; i++) {
          var a = as[i];
          if (a._tag === "Left") {
            r.push(a.left);
          }
        }
        return r;
      };
      exports.lefts = lefts;
      var sort = function(O) {
        return function(as) {
          return as.length <= 1 ? (0, exports.copy)(as) : as.slice().sort(O.compare);
        };
      };
      exports.sort = sort;
      var zipWith = function(fa, fb, f) {
        var fc = [];
        var len = Math.min(fa.length, fb.length);
        for (var i = 0; i < len; i++) {
          fc[i] = f(fa[i], fb[i]);
        }
        return fc;
      };
      exports.zipWith = zipWith;
      function zip(as, bs) {
        if (bs === void 0) {
          return function(bs2) {
            return zip(bs2, as);
          };
        }
        return (0, exports.zipWith)(as, bs, function(a, b) {
          return [a, b];
        });
      }
      exports.zip = zip;
      var unzip = function(as) {
        var fa = [];
        var fb = [];
        for (var i = 0; i < as.length; i++) {
          fa[i] = as[i][0];
          fb[i] = as[i][1];
        }
        return [fa, fb];
      };
      exports.unzip = unzip;
      var prependAll = function(middle) {
        var f = NEA.prependAll(middle);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : [];
        };
      };
      exports.prependAll = prependAll;
      var intersperse = function(middle) {
        var f = NEA.intersperse(middle);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : (0, exports.copy)(as);
        };
      };
      exports.intersperse = intersperse;
      var rotate = function(n) {
        var f = NEA.rotate(n);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : (0, exports.copy)(as);
        };
      };
      exports.rotate = rotate;
      exports.elem = RA.elem;
      var uniq = function(E) {
        var f = NEA.uniq(E);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : (0, exports.copy)(as);
        };
      };
      exports.uniq = uniq;
      var sortBy = function(ords) {
        var f = NEA.sortBy(ords);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : (0, exports.copy)(as);
        };
      };
      exports.sortBy = sortBy;
      var chop = function(f) {
        var g = NEA.chop(f);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? g(as) : [];
        };
      };
      exports.chop = chop;
      var splitAt = function(n) {
        return function(as) {
          return n >= 1 && (0, exports.isNonEmpty)(as) ? NEA.splitAt(n)(as) : (0, exports.isEmpty)(as) ? [(0, exports.copy)(as), []] : [[], (0, exports.copy)(as)];
        };
      };
      exports.splitAt = splitAt;
      var chunksOf = function(n) {
        var f = NEA.chunksOf(n);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : [];
        };
      };
      exports.chunksOf = chunksOf;
      var fromOptionK = function(f) {
        return function() {
          var a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
          }
          return (0, exports.fromOption)(f.apply(void 0, a));
        };
      };
      exports.fromOptionK = fromOptionK;
      function comprehension(input, f, g) {
        if (g === void 0) {
          g = function() {
            return true;
          };
        }
        var go = function(scope, input2) {
          return (0, exports.isNonEmpty)(input2) ? (0, function_1.pipe)(NEA.head(input2), (0, exports.chain)(function(x) {
            return go((0, function_1.pipe)(scope, (0, exports.append)(x)), NEA.tail(input2));
          })) : g.apply(void 0, scope) ? [f.apply(void 0, scope)] : [];
        };
        return go([], input);
      }
      exports.comprehension = comprehension;
      var concatW = function(second) {
        return function(first) {
          return (0, exports.isEmpty)(first) ? (0, exports.copy)(second) : (0, exports.isEmpty)(second) ? (0, exports.copy)(first) : first.concat(second);
        };
      };
      exports.concatW = concatW;
      exports.concat = exports.concatW;
      function union(E) {
        var unionE = NEA.union(E);
        return function(first, second) {
          if (second === void 0) {
            var unionE_1 = union(E);
            return function(second2) {
              return unionE_1(second2, first);
            };
          }
          return (0, exports.isNonEmpty)(first) && (0, exports.isNonEmpty)(second) ? unionE(second)(first) : (0, exports.isNonEmpty)(first) ? (0, exports.copy)(first) : (0, exports.copy)(second);
        };
      }
      exports.union = union;
      function intersection(E) {
        var elemE = (0, exports.elem)(E);
        return function(xs, ys) {
          if (ys === void 0) {
            var intersectionE_1 = intersection(E);
            return function(ys2) {
              return intersectionE_1(ys2, xs);
            };
          }
          return xs.filter(function(a) {
            return elemE(a, ys);
          });
        };
      }
      exports.intersection = intersection;
      function difference(E) {
        var elemE = (0, exports.elem)(E);
        return function(xs, ys) {
          if (ys === void 0) {
            var differenceE_1 = difference(E);
            return function(ys2) {
              return differenceE_1(ys2, xs);
            };
          }
          return xs.filter(function(a) {
            return !elemE(a, ys);
          });
        };
      }
      exports.difference = difference;
      var _map = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f));
      };
      var _mapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f));
      };
      var _ap = function(fab, fa) {
        return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
      };
      var _chain = function(ma, f) {
        return (0, function_1.pipe)(ma, (0, exports.chain)(f));
      };
      var _filter = function(fa, predicate) {
        return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));
      };
      var _filterMap = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.filterMap)(f));
      };
      var _partition = function(fa, predicate) {
        return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
      };
      var _partitionMap = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f));
      };
      var _partitionWithIndex = function(fa, predicateWithIndex) {
        return (0, function_1.pipe)(fa, (0, exports.partitionWithIndex)(predicateWithIndex));
      };
      var _partitionMapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.partitionMapWithIndex)(f));
      };
      var _alt = function(fa, that) {
        return (0, function_1.pipe)(fa, (0, exports.alt)(that));
      };
      var _reduce = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f));
      };
      var _foldMap = function(M) {
        var foldMapM = (0, exports.foldMap)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapM(f));
        };
      };
      var _reduceRight = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f));
      };
      var _reduceWithIndex = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f));
      };
      var _foldMapWithIndex = function(M) {
        var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapWithIndexM(f));
        };
      };
      var _reduceRightWithIndex = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f));
      };
      var _filterMapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.filterMapWithIndex)(f));
      };
      var _filterWithIndex = function(fa, predicateWithIndex) {
        return (0, function_1.pipe)(fa, (0, exports.filterWithIndex)(predicateWithIndex));
      };
      var _extend = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.extend)(f));
      };
      var _traverse = function(F) {
        var traverseF = (0, exports.traverse)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseF(f));
        };
      };
      var _traverseWithIndex = function(F) {
        var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseWithIndexF(f));
        };
      };
      var _chainRecDepthFirst = RA._chainRecDepthFirst;
      var _chainRecBreadthFirst = RA._chainRecBreadthFirst;
      exports.of = NEA.of;
      var zero = function() {
        return [];
      };
      exports.zero = zero;
      var map = function(f) {
        return function(fa) {
          return fa.map(function(a) {
            return f(a);
          });
        };
      };
      exports.map = map;
      var ap = function(fa) {
        return (0, exports.chain)(function(f) {
          return (0, function_1.pipe)(fa, (0, exports.map)(f));
        });
      };
      exports.ap = ap;
      var chain = function(f) {
        return function(ma) {
          return (0, function_1.pipe)(ma, (0, exports.chainWithIndex)(function(_2, a) {
            return f(a);
          }));
        };
      };
      exports.chain = chain;
      exports.flatten = (0, exports.chain)(function_1.identity);
      var mapWithIndex = function(f) {
        return function(fa) {
          return fa.map(function(a, i) {
            return f(i, a);
          });
        };
      };
      exports.mapWithIndex = mapWithIndex;
      var filterMapWithIndex = function(f) {
        return function(fa) {
          var out = [];
          for (var i = 0; i < fa.length; i++) {
            var optionB = f(i, fa[i]);
            if (_.isSome(optionB)) {
              out.push(optionB.value);
            }
          }
          return out;
        };
      };
      exports.filterMapWithIndex = filterMapWithIndex;
      var filterMap = function(f) {
        return (0, exports.filterMapWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.filterMap = filterMap;
      exports.compact = (0, exports.filterMap)(function_1.identity);
      var separate = function(fa) {
        var left = [];
        var right = [];
        for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
          var e = fa_1[_i];
          if (e._tag === "Left") {
            left.push(e.left);
          } else {
            right.push(e.right);
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
      exports.separate = separate;
      var filter = function(predicate) {
        return function(as) {
          return as.filter(predicate);
        };
      };
      exports.filter = filter;
      var partition = function(predicate) {
        return (0, exports.partitionWithIndex)(function(_2, a) {
          return predicate(a);
        });
      };
      exports.partition = partition;
      var partitionWithIndex = function(predicateWithIndex) {
        return function(as) {
          var left = [];
          var right = [];
          for (var i = 0; i < as.length; i++) {
            var b = as[i];
            if (predicateWithIndex(i, b)) {
              right.push(b);
            } else {
              left.push(b);
            }
          }
          return (0, Separated_1.separated)(left, right);
        };
      };
      exports.partitionWithIndex = partitionWithIndex;
      var partitionMap = function(f) {
        return (0, exports.partitionMapWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.partitionMap = partitionMap;
      var partitionMapWithIndex = function(f) {
        return function(fa) {
          var left = [];
          var right = [];
          for (var i = 0; i < fa.length; i++) {
            var e = f(i, fa[i]);
            if (e._tag === "Left") {
              left.push(e.left);
            } else {
              right.push(e.right);
            }
          }
          return (0, Separated_1.separated)(left, right);
        };
      };
      exports.partitionMapWithIndex = partitionMapWithIndex;
      var altW = function(that) {
        return function(fa) {
          return fa.concat(that());
        };
      };
      exports.altW = altW;
      exports.alt = exports.altW;
      var filterWithIndex = function(predicateWithIndex) {
        return function(as) {
          return as.filter(function(b, i) {
            return predicateWithIndex(i, b);
          });
        };
      };
      exports.filterWithIndex = filterWithIndex;
      var extend = function(f) {
        return function(wa) {
          return wa.map(function(_2, i) {
            return f(wa.slice(i));
          });
        };
      };
      exports.extend = extend;
      exports.duplicate = (0, exports.extend)(function_1.identity);
      exports.foldMap = RA.foldMap;
      exports.foldMapWithIndex = RA.foldMapWithIndex;
      exports.reduce = RA.reduce;
      exports.reduceWithIndex = RA.reduceWithIndex;
      exports.reduceRight = RA.reduceRight;
      exports.reduceRightWithIndex = RA.reduceRightWithIndex;
      var traverse = function(F) {
        var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
        return function(f) {
          return traverseWithIndexF(function(_2, a) {
            return f(a);
          });
        };
      };
      exports.traverse = traverse;
      var sequence = function(F) {
        return function(ta) {
          return _reduce(ta, F.of((0, exports.zero)()), function(fas, fa) {
            return F.ap(F.map(fas, function(as) {
              return function(a) {
                return (0, function_1.pipe)(as, (0, exports.append)(a));
              };
            }), fa);
          });
        };
      };
      exports.sequence = sequence;
      var traverseWithIndex = function(F) {
        return function(f) {
          return (0, exports.reduceWithIndex)(F.of((0, exports.zero)()), function(i, fbs, a) {
            return F.ap(F.map(fbs, function(bs) {
              return function(b) {
                return (0, function_1.pipe)(bs, (0, exports.append)(b));
              };
            }), f(i, a));
          });
        };
      };
      exports.traverseWithIndex = traverseWithIndex;
      var wither = function(F) {
        var _witherF = _wither(F);
        return function(f) {
          return function(fa) {
            return _witherF(fa, f);
          };
        };
      };
      exports.wither = wither;
      var wilt = function(F) {
        var _wiltF = _wilt(F);
        return function(f) {
          return function(fa) {
            return _wiltF(fa, f);
          };
        };
      };
      exports.wilt = wilt;
      var unfold = function(b, f) {
        var out = [];
        var bb = b;
        while (true) {
          var mt = f(bb);
          if (_.isSome(mt)) {
            var _a = mt.value, a = _a[0], b_1 = _a[1];
            out.push(a);
            bb = b_1;
          } else {
            break;
          }
        }
        return out;
      };
      exports.unfold = unfold;
      exports.URI = "Array";
      exports.getShow = RA.getShow;
      var getSemigroup = function() {
        return {
          concat: function(first, second) {
            return first.concat(second);
          }
        };
      };
      exports.getSemigroup = getSemigroup;
      var getMonoid = function() {
        return {
          concat: (0, exports.getSemigroup)().concat,
          empty: []
        };
      };
      exports.getMonoid = getMonoid;
      exports.getEq = RA.getEq;
      exports.getOrd = RA.getOrd;
      var getUnionSemigroup = function(E) {
        var unionE = union(E);
        return {
          concat: function(first, second) {
            return unionE(second)(first);
          }
        };
      };
      exports.getUnionSemigroup = getUnionSemigroup;
      var getUnionMonoid = function(E) {
        return {
          concat: (0, exports.getUnionSemigroup)(E).concat,
          empty: []
        };
      };
      exports.getUnionMonoid = getUnionMonoid;
      var getIntersectionSemigroup = function(E) {
        var intersectionE = intersection(E);
        return {
          concat: function(first, second) {
            return intersectionE(second)(first);
          }
        };
      };
      exports.getIntersectionSemigroup = getIntersectionSemigroup;
      var getDifferenceMagma = function(E) {
        var differenceE = difference(E);
        return {
          concat: function(first, second) {
            return differenceE(second)(first);
          }
        };
      };
      exports.getDifferenceMagma = getDifferenceMagma;
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.Pointed = {
        URI: exports.URI,
        of: exports.of
      };
      exports.FunctorWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex
      };
      exports.Apply = {
        URI: exports.URI,
        map: _map,
        ap: _ap
      };
      exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
      exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
      exports.Applicative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of
      };
      exports.Chain = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain
      };
      exports.chainFirst = /* @__PURE__ */ (0, Chain_1.chainFirst)(exports.Chain);
      exports.Monad = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain
      };
      exports.Unfoldable = {
        URI: exports.URI,
        unfold: exports.unfold
      };
      exports.Alt = {
        URI: exports.URI,
        map: _map,
        alt: _alt
      };
      exports.Zero = {
        URI: exports.URI,
        zero: exports.zero
      };
      exports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);
      exports.Alternative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        alt: _alt,
        zero: exports.zero
      };
      exports.Extend = {
        URI: exports.URI,
        map: _map,
        extend: _extend
      };
      exports.Compactable = {
        URI: exports.URI,
        compact: exports.compact,
        separate: exports.separate
      };
      exports.Filterable = {
        URI: exports.URI,
        map: _map,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap
      };
      exports.FilterableWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex,
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex
      };
      exports.Foldable = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight
      };
      exports.FoldableWithIndex = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex
      };
      exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence
      };
      exports.TraversableWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex,
        traverse: _traverse,
        sequence: exports.sequence,
        traverseWithIndex: _traverseWithIndex
      };
      var _wither = /* @__PURE__ */ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
      var _wilt = /* @__PURE__ */ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
      exports.Witherable = {
        URI: exports.URI,
        map: _map,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        wither: _wither,
        wilt: _wilt
      };
      exports.chainRecDepthFirst = RA.chainRecDepthFirst;
      exports.ChainRecDepthFirst = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain,
        chainRec: _chainRecDepthFirst
      };
      exports.chainRecBreadthFirst = RA.chainRecBreadthFirst;
      exports.ChainRecBreadthFirst = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain,
        chainRec: _chainRecBreadthFirst
      };
      exports.filterE = (0, Witherable_1.filterE)(exports.Witherable);
      exports.FromEither = {
        URI: exports.URI,
        fromEither: exports.fromEither
      };
      exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
      exports.unsafeInsertAt = NEA.unsafeInsertAt;
      var unsafeUpdateAt = function(i, a, as) {
        return (0, exports.isNonEmpty)(as) ? NEA.unsafeUpdateAt(i, a, as) : [];
      };
      exports.unsafeUpdateAt = unsafeUpdateAt;
      var unsafeDeleteAt = function(i, as) {
        var xs = as.slice();
        xs.splice(i, 1);
        return xs;
      };
      exports.unsafeDeleteAt = unsafeDeleteAt;
      exports.every = RA.every;
      var some = function(predicate) {
        return function(as) {
          return as.some(predicate);
        };
      };
      exports.some = some;
      exports.exists = exports.some;
      exports.intercalate = RA.intercalate;
      exports.Do = (0, exports.of)(_.emptyRecord);
      exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
      var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
      exports.let = let_;
      exports.bind = (0, Chain_1.bind)(exports.Chain);
      exports.apS = (0, Apply_1.apS)(exports.Apply);
      exports.range = NEA.range;
      exports.empty = [];
      exports.cons = NEA.cons;
      exports.snoc = NEA.snoc;
      exports.prependToAll = exports.prependAll;
      exports.array = {
        URI: exports.URI,
        compact: exports.compact,
        separate: exports.separate,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        mapWithIndex: _mapWithIndex,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex,
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex,
        alt: _alt,
        zero: exports.zero,
        unfold: exports.unfold,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex,
        traverseWithIndex: _traverseWithIndex,
        extend: _extend,
        wither: _wither,
        wilt: _wilt
      };
    }
  });

  // node_modules/fp-ts/lib/Predicate.js
  var require_Predicate = __commonJS({
    "node_modules/fp-ts/lib/Predicate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.and = exports.or = exports.not = exports.Contravariant = exports.getMonoidAll = exports.getSemigroupAll = exports.getMonoidAny = exports.getSemigroupAny = exports.URI = exports.contramap = void 0;
      var function_1 = require_function();
      var contramap_ = function(predicate, f) {
        return (0, function_1.pipe)(predicate, (0, exports.contramap)(f));
      };
      var contramap = function(f) {
        return function(predicate) {
          return (0, function_1.flow)(f, predicate);
        };
      };
      exports.contramap = contramap;
      exports.URI = "Predicate";
      var getSemigroupAny = function() {
        return {
          concat: function(first, second) {
            return (0, function_1.pipe)(first, (0, exports.or)(second));
          }
        };
      };
      exports.getSemigroupAny = getSemigroupAny;
      var getMonoidAny = function() {
        return {
          concat: (0, exports.getSemigroupAny)().concat,
          empty: function_1.constFalse
        };
      };
      exports.getMonoidAny = getMonoidAny;
      var getSemigroupAll = function() {
        return {
          concat: function(first, second) {
            return (0, function_1.pipe)(first, (0, exports.and)(second));
          }
        };
      };
      exports.getSemigroupAll = getSemigroupAll;
      var getMonoidAll = function() {
        return {
          concat: (0, exports.getSemigroupAll)().concat,
          empty: function_1.constTrue
        };
      };
      exports.getMonoidAll = getMonoidAll;
      exports.Contravariant = {
        URI: exports.URI,
        contramap: contramap_
      };
      var not = function(predicate) {
        return function(a) {
          return !predicate(a);
        };
      };
      exports.not = not;
      var or = function(second) {
        return function(first) {
          return function(a) {
            return first(a) || second(a);
          };
        };
      };
      exports.or = or;
      var and = function(second) {
        return function(first) {
          return function(a) {
            return first(a) && second(a);
          };
        };
      };
      exports.and = and;
    }
  });

  // node_modules/fp-ts/lib/Option.js
  var require_Option = __commonJS({
    "node_modules/fp-ts/lib/Option.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromEither = exports.MonadThrow = exports.throwError = exports.Witherable = exports.wilt = exports.wither = exports.Traversable = exports.sequence = exports.traverse = exports.Filterable = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.Compactable = exports.separate = exports.compact = exports.Extend = exports.extend = exports.Alternative = exports.guard = exports.Zero = exports.zero = exports.Alt = exports.alt = exports.altW = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.chain = exports.Applicative = exports.Apply = exports.ap = exports.Pointed = exports.of = exports.Functor = exports.map = exports.getMonoid = exports.getOrd = exports.getEq = exports.getShow = exports.URI = exports.getRight = exports.getLeft = exports.fromPredicate = exports.some = exports.none = void 0;
      exports.getLastMonoid = exports.getFirstMonoid = exports.getApplyMonoid = exports.getApplySemigroup = exports.option = exports.mapNullable = exports.getRefinement = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toUndefined = exports.toNullable = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.duplicate = exports.chainFirst = exports.flatten = exports.apSecond = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = exports.fold = exports.match = exports.foldW = exports.matchW = exports.isNone = exports.isSome = exports.FromEither = void 0;
      var Applicative_1 = require_Applicative();
      var Apply_1 = require_Apply();
      var Chain_1 = require_Chain();
      var FromEither_1 = require_FromEither();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar(require_internal());
      var Predicate_1 = require_Predicate();
      var Semigroup_1 = require_Semigroup();
      var Separated_1 = require_Separated();
      var Witherable_1 = require_Witherable();
      var Zero_1 = require_Zero();
      exports.none = _.none;
      exports.some = _.some;
      function fromPredicate(predicate) {
        return function(a) {
          return predicate(a) ? (0, exports.some)(a) : exports.none;
        };
      }
      exports.fromPredicate = fromPredicate;
      var getLeft = function(ma) {
        return ma._tag === "Right" ? exports.none : (0, exports.some)(ma.left);
      };
      exports.getLeft = getLeft;
      var getRight = function(ma) {
        return ma._tag === "Left" ? exports.none : (0, exports.some)(ma.right);
      };
      exports.getRight = getRight;
      var _map = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f));
      };
      var _ap = function(fab, fa) {
        return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
      };
      var _chain = function(ma, f) {
        return (0, function_1.pipe)(ma, (0, exports.chain)(f));
      };
      var _reduce = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f));
      };
      var _foldMap = function(M) {
        var foldMapM = (0, exports.foldMap)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapM(f));
        };
      };
      var _reduceRight = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f));
      };
      var _traverse = function(F) {
        var traverseF = (0, exports.traverse)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseF(f));
        };
      };
      var _alt = function(fa, that) {
        return (0, function_1.pipe)(fa, (0, exports.alt)(that));
      };
      var _filter = function(fa, predicate) {
        return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));
      };
      var _filterMap = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.filterMap)(f));
      };
      var _extend = function(wa, f) {
        return (0, function_1.pipe)(wa, (0, exports.extend)(f));
      };
      var _partition = function(fa, predicate) {
        return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
      };
      var _partitionMap = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f));
      };
      exports.URI = "Option";
      var getShow = function(S) {
        return {
          show: function(ma) {
            return (0, exports.isNone)(ma) ? "none" : "some(".concat(S.show(ma.value), ")");
          }
        };
      };
      exports.getShow = getShow;
      var getEq = function(E) {
        return {
          equals: function(x, y) {
            return x === y || ((0, exports.isNone)(x) ? (0, exports.isNone)(y) : (0, exports.isNone)(y) ? false : E.equals(x.value, y.value));
          }
        };
      };
      exports.getEq = getEq;
      var getOrd = function(O) {
        return {
          equals: (0, exports.getEq)(O).equals,
          compare: function(x, y) {
            return x === y ? 0 : (0, exports.isSome)(x) ? (0, exports.isSome)(y) ? O.compare(x.value, y.value) : 1 : -1;
          }
        };
      };
      exports.getOrd = getOrd;
      var getMonoid = function(S) {
        return {
          concat: function(x, y) {
            return (0, exports.isNone)(x) ? y : (0, exports.isNone)(y) ? x : (0, exports.some)(S.concat(x.value, y.value));
          },
          empty: exports.none
        };
      };
      exports.getMonoid = getMonoid;
      var map = function(f) {
        return function(fa) {
          return (0, exports.isNone)(fa) ? exports.none : (0, exports.some)(f(fa.value));
        };
      };
      exports.map = map;
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.of = exports.some;
      exports.Pointed = {
        URI: exports.URI,
        of: exports.of
      };
      var ap = function(fa) {
        return function(fab) {
          return (0, exports.isNone)(fab) ? exports.none : (0, exports.isNone)(fa) ? exports.none : (0, exports.some)(fab.value(fa.value));
        };
      };
      exports.ap = ap;
      exports.Apply = {
        URI: exports.URI,
        map: _map,
        ap: _ap
      };
      exports.Applicative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of
      };
      var chain = function(f) {
        return function(ma) {
          return (0, exports.isNone)(ma) ? exports.none : f(ma.value);
        };
      };
      exports.chain = chain;
      exports.Chain = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain
      };
      exports.Monad = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain
      };
      var reduce = function(b, f) {
        return function(fa) {
          return (0, exports.isNone)(fa) ? b : f(b, fa.value);
        };
      };
      exports.reduce = reduce;
      var foldMap = function(M) {
        return function(f) {
          return function(fa) {
            return (0, exports.isNone)(fa) ? M.empty : f(fa.value);
          };
        };
      };
      exports.foldMap = foldMap;
      var reduceRight = function(b, f) {
        return function(fa) {
          return (0, exports.isNone)(fa) ? b : f(fa.value, b);
        };
      };
      exports.reduceRight = reduceRight;
      exports.Foldable = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight
      };
      var altW = function(that) {
        return function(fa) {
          return (0, exports.isNone)(fa) ? that() : fa;
        };
      };
      exports.altW = altW;
      exports.alt = exports.altW;
      exports.Alt = {
        URI: exports.URI,
        map: _map,
        alt: _alt
      };
      var zero = function() {
        return exports.none;
      };
      exports.zero = zero;
      exports.Zero = {
        URI: exports.URI,
        zero: exports.zero
      };
      exports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);
      exports.Alternative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        alt: _alt,
        zero: exports.zero
      };
      var extend = function(f) {
        return function(wa) {
          return (0, exports.isNone)(wa) ? exports.none : (0, exports.some)(f(wa));
        };
      };
      exports.extend = extend;
      exports.Extend = {
        URI: exports.URI,
        map: _map,
        extend: _extend
      };
      exports.compact = (0, exports.chain)(function_1.identity);
      var defaultSeparated = /* @__PURE__ */ (0, Separated_1.separated)(exports.none, exports.none);
      var separate = function(ma) {
        return (0, exports.isNone)(ma) ? defaultSeparated : (0, Separated_1.separated)((0, exports.getLeft)(ma.value), (0, exports.getRight)(ma.value));
      };
      exports.separate = separate;
      exports.Compactable = {
        URI: exports.URI,
        compact: exports.compact,
        separate: exports.separate
      };
      var filter = function(predicate) {
        return function(fa) {
          return (0, exports.isNone)(fa) ? exports.none : predicate(fa.value) ? fa : exports.none;
        };
      };
      exports.filter = filter;
      var filterMap = function(f) {
        return function(fa) {
          return (0, exports.isNone)(fa) ? exports.none : f(fa.value);
        };
      };
      exports.filterMap = filterMap;
      var partition = function(predicate) {
        return function(fa) {
          return (0, Separated_1.separated)(_filter(fa, (0, Predicate_1.not)(predicate)), _filter(fa, predicate));
        };
      };
      exports.partition = partition;
      var partitionMap = function(f) {
        return (0, function_1.flow)((0, exports.map)(f), exports.separate);
      };
      exports.partitionMap = partitionMap;
      exports.Filterable = {
        URI: exports.URI,
        map: _map,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap
      };
      var traverse = function(F) {
        return function(f) {
          return function(ta) {
            return (0, exports.isNone)(ta) ? F.of(exports.none) : F.map(f(ta.value), exports.some);
          };
        };
      };
      exports.traverse = traverse;
      var sequence = function(F) {
        return function(ta) {
          return (0, exports.isNone)(ta) ? F.of(exports.none) : F.map(ta.value, exports.some);
        };
      };
      exports.sequence = sequence;
      exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence
      };
      var _wither = /* @__PURE__ */ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
      var _wilt = /* @__PURE__ */ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
      var wither = function(F) {
        var _witherF = _wither(F);
        return function(f) {
          return function(fa) {
            return _witherF(fa, f);
          };
        };
      };
      exports.wither = wither;
      var wilt = function(F) {
        var _wiltF = _wilt(F);
        return function(f) {
          return function(fa) {
            return _wiltF(fa, f);
          };
        };
      };
      exports.wilt = wilt;
      exports.Witherable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        wither: _wither,
        wilt: _wilt
      };
      var throwError = function() {
        return exports.none;
      };
      exports.throwError = throwError;
      exports.MonadThrow = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain,
        throwError: exports.throwError
      };
      exports.fromEither = exports.getRight;
      exports.FromEither = {
        URI: exports.URI,
        fromEither: exports.fromEither
      };
      exports.isSome = _.isSome;
      var isNone = function(fa) {
        return fa._tag === "None";
      };
      exports.isNone = isNone;
      var matchW = function(onNone, onSome) {
        return function(ma) {
          return (0, exports.isNone)(ma) ? onNone() : onSome(ma.value);
        };
      };
      exports.matchW = matchW;
      exports.foldW = exports.matchW;
      exports.match = exports.matchW;
      exports.fold = exports.match;
      var getOrElseW = function(onNone) {
        return function(ma) {
          return (0, exports.isNone)(ma) ? onNone() : ma.value;
        };
      };
      exports.getOrElseW = getOrElseW;
      exports.getOrElse = exports.getOrElseW;
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
      exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
      exports.flatten = exports.compact;
      exports.chainFirst = /* @__PURE__ */ (0, Chain_1.chainFirst)(exports.Chain);
      exports.duplicate = (0, exports.extend)(function_1.identity);
      exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
      exports.chainEitherK = /* @__PURE__ */ (0, FromEither_1.chainEitherK)(exports.FromEither, exports.Chain);
      exports.chainFirstEitherK = /* @__PURE__ */ (0, FromEither_1.chainFirstEitherK)(exports.FromEither, exports.Chain);
      var fromNullable = function(a) {
        return a == null ? exports.none : (0, exports.some)(a);
      };
      exports.fromNullable = fromNullable;
      var tryCatch = function(f) {
        try {
          return (0, exports.some)(f());
        } catch (e) {
          return exports.none;
        }
      };
      exports.tryCatch = tryCatch;
      var tryCatchK = function(f) {
        return function() {
          var a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
          }
          return (0, exports.tryCatch)(function() {
            return f.apply(void 0, a);
          });
        };
      };
      exports.tryCatchK = tryCatchK;
      var fromNullableK = function(f) {
        return (0, function_1.flow)(f, exports.fromNullable);
      };
      exports.fromNullableK = fromNullableK;
      var chainNullableK = function(f) {
        return function(ma) {
          return (0, exports.isNone)(ma) ? exports.none : (0, exports.fromNullable)(f(ma.value));
        };
      };
      exports.chainNullableK = chainNullableK;
      exports.toNullable = (0, exports.match)(function_1.constNull, function_1.identity);
      exports.toUndefined = (0, exports.match)(function_1.constUndefined, function_1.identity);
      function elem(E) {
        return function(a, ma) {
          if (ma === void 0) {
            var elemE_1 = elem(E);
            return function(ma2) {
              return elemE_1(a, ma2);
            };
          }
          return (0, exports.isNone)(ma) ? false : E.equals(a, ma.value);
        };
      }
      exports.elem = elem;
      var exists = function(predicate) {
        return function(ma) {
          return (0, exports.isNone)(ma) ? false : predicate(ma.value);
        };
      };
      exports.exists = exists;
      exports.Do = (0, exports.of)(_.emptyRecord);
      exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
      var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
      exports.let = let_;
      exports.bind = (0, Chain_1.bind)(exports.Chain);
      exports.apS = (0, Apply_1.apS)(exports.Apply);
      exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
      var traverseReadonlyNonEmptyArrayWithIndex = function(f) {
        return function(as) {
          var o = f(0, _.head(as));
          if ((0, exports.isNone)(o)) {
            return exports.none;
          }
          var out = [o.value];
          for (var i = 1; i < as.length; i++) {
            var o_1 = f(i, as[i]);
            if ((0, exports.isNone)(o_1)) {
              return exports.none;
            }
            out.push(o_1.value);
          }
          return (0, exports.some)(out);
        };
      };
      exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
      var traverseReadonlyArrayWithIndex = function(f) {
        var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);
        return function(as) {
          return _.isNonEmpty(as) ? g(as) : exports.ApT;
        };
      };
      exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
      exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
      var traverseArray = function(f) {
        return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.traverseArray = traverseArray;
      exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
      function getRefinement(getOption) {
        return function(a) {
          return (0, exports.isSome)(getOption(a));
        };
      }
      exports.getRefinement = getRefinement;
      exports.mapNullable = exports.chainNullableK;
      exports.option = {
        URI: exports.URI,
        map: _map,
        of: exports.of,
        ap: _ap,
        chain: _chain,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        zero: exports.zero,
        alt: _alt,
        extend: _extend,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        wither: _wither,
        wilt: _wilt,
        throwError: exports.throwError
      };
      exports.getApplySemigroup = (0, Apply_1.getApplySemigroup)(exports.Apply);
      exports.getApplyMonoid = (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);
      var getFirstMonoid = function() {
        return (0, exports.getMonoid)((0, Semigroup_1.first)());
      };
      exports.getFirstMonoid = getFirstMonoid;
      var getLastMonoid = function() {
        return (0, exports.getMonoid)((0, Semigroup_1.last)());
      };
      exports.getLastMonoid = getLastMonoid;
    }
  });

  // node_modules/fp-ts/lib/string.js
  var require_string = __commonJS({
    "node_modules/fp-ts/lib/string.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.endsWith = exports.startsWith = exports.includes = exports.split = exports.size = exports.isEmpty = exports.slice = exports.trimRight = exports.trimLeft = exports.trim = exports.replace = exports.toLowerCase = exports.toUpperCase = exports.isString = exports.Show = exports.Ord = exports.Monoid = exports.empty = exports.Semigroup = exports.Eq = void 0;
      var ReadonlyNonEmptyArray_1 = require_ReadonlyNonEmptyArray();
      exports.Eq = {
        equals: function(first, second) {
          return first === second;
        }
      };
      exports.Semigroup = {
        concat: function(first, second) {
          return first + second;
        }
      };
      exports.empty = "";
      exports.Monoid = {
        concat: exports.Semigroup.concat,
        empty: exports.empty
      };
      exports.Ord = {
        equals: exports.Eq.equals,
        compare: function(first, second) {
          return first < second ? -1 : first > second ? 1 : 0;
        }
      };
      exports.Show = {
        show: function(s) {
          return JSON.stringify(s);
        }
      };
      var isString = function(u) {
        return typeof u === "string";
      };
      exports.isString = isString;
      var toUpperCase = function(s) {
        return s.toUpperCase();
      };
      exports.toUpperCase = toUpperCase;
      var toLowerCase = function(s) {
        return s.toLowerCase();
      };
      exports.toLowerCase = toLowerCase;
      var replace = function(searchValue, replaceValue) {
        return function(s) {
          return s.replace(searchValue, replaceValue);
        };
      };
      exports.replace = replace;
      var trim = function(s) {
        return s.trim();
      };
      exports.trim = trim;
      var trimLeft = function(s) {
        return s.trimLeft();
      };
      exports.trimLeft = trimLeft;
      var trimRight = function(s) {
        return s.trimRight();
      };
      exports.trimRight = trimRight;
      var slice = function(start, end) {
        return function(s) {
          return s.slice(start, end);
        };
      };
      exports.slice = slice;
      var isEmpty = function(s) {
        return s.length === 0;
      };
      exports.isEmpty = isEmpty;
      var size = function(s) {
        return s.length;
      };
      exports.size = size;
      var split = function(separator) {
        return function(s) {
          var out = s.split(separator);
          return (0, ReadonlyNonEmptyArray_1.isNonEmpty)(out) ? out : [s];
        };
      };
      exports.split = split;
      var includes = function(searchString, position) {
        return function(s) {
          return s.includes(searchString, position);
        };
      };
      exports.includes = includes;
      var startsWith = function(searchString, position) {
        return function(s) {
          return s.startsWith(searchString, position);
        };
      };
      exports.startsWith = startsWith;
      var endsWith = function(searchString, position) {
        return function(s) {
          return s.endsWith(searchString, position);
        };
      };
      exports.endsWith = endsWith;
    }
  });

  // node_modules/fp-ts/lib/ReadonlyRecord.js
  var require_ReadonlyRecord = __commonJS({
    "node_modules/fp-ts/lib/ReadonlyRecord.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._partition = exports._filterMap = exports._filter = exports._reduceRight = exports._foldMap = exports._reduce = exports._mapWithIndex = exports._map = exports.difference = exports.intersection = exports.union = exports.elem = exports.some = exports.every = exports.fromEntries = exports.toEntries = exports.fromFoldableMap = exports.fromFoldable = exports.filterWithIndex = exports.filterMapWithIndex = exports.partitionWithIndex = exports.partitionMapWithIndex = exports.wilt = exports.wither = exports.sequence = exports.traverse = exports.traverseWithIndex = exports.singleton = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.map = exports.mapWithIndex = exports.empty = exports.lookup = exports.isSubrecord = exports.pop = exports.modifyAt = exports.updateAt = exports.deleteAt = exports.has = exports.upsertAt = exports.toUnfoldable = exports.toReadonlyArray = exports.collect = exports.keys = exports.isEmpty = exports.size = exports.toRecord = exports.fromRecord = void 0;
      exports.readonlyRecord = exports.hasOwnProperty = exports.insertAt = exports.Witherable = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getWitherable = exports.getTraversableWithIndex = exports.getTraversable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.getFoldableWithIndex = exports.getFoldable = exports.FunctorWithIndex = exports.flap = exports.Functor = exports.getMonoid = exports.getEq = exports.getShow = exports.URI = exports.separate = exports.compact = exports.reduceRight = exports.foldMap = exports.reduce = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports._sequence = exports._traverse = exports._filterWithIndex = exports._filterMapWithIndex = exports._partitionWithIndex = exports._partitionMapWithIndex = exports._reduceRightWithIndex = exports._foldMapWithIndex = exports._reduceWithIndex = exports._partitionMap = void 0;
      var Eq_1 = require_Eq();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar(require_internal());
      var Separated_1 = require_Separated();
      var S = __importStar(require_string());
      var Witherable_1 = require_Witherable();
      var fromRecord = function(r) {
        return Object.assign({}, r);
      };
      exports.fromRecord = fromRecord;
      var toRecord = function(r) {
        return Object.assign({}, r);
      };
      exports.toRecord = toRecord;
      var size = function(r) {
        return Object.keys(r).length;
      };
      exports.size = size;
      var isEmpty = function(r) {
        for (var k in r) {
          if (_.has.call(r, k)) {
            return false;
          }
        }
        return true;
      };
      exports.isEmpty = isEmpty;
      var keys_ = function(O) {
        return function(r) {
          return Object.keys(r).sort(O.compare);
        };
      };
      exports.keys = keys_(S.Ord);
      function collect(O) {
        if (typeof O === "function") {
          return collect(S.Ord)(O);
        }
        var keysO = keys_(O);
        return function(f) {
          return function(r) {
            var out = [];
            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
              var key = _a[_i];
              out.push(f(key, r[key]));
            }
            return out;
          };
        };
      }
      exports.collect = collect;
      exports.toReadonlyArray = /* @__PURE__ */ collect(S.Ord)(function(k, a) {
        return [k, a];
      });
      function toUnfoldable(U) {
        return function(r) {
          var sas = (0, exports.toReadonlyArray)(r);
          var len = sas.length;
          return U.unfold(0, function(b) {
            return b < len ? _.some([sas[b], b + 1]) : _.none;
          });
        };
      }
      exports.toUnfoldable = toUnfoldable;
      var upsertAt = function(k, a) {
        return function(r) {
          if (_.has.call(r, k) && r[k] === a) {
            return r;
          }
          var out = Object.assign({}, r);
          out[k] = a;
          return out;
        };
      };
      exports.upsertAt = upsertAt;
      var has = function(k, r) {
        return _.has.call(r, k);
      };
      exports.has = has;
      function deleteAt(k) {
        return function(r) {
          if (!_.has.call(r, k)) {
            return r;
          }
          var out = Object.assign({}, r);
          delete out[k];
          return out;
        };
      }
      exports.deleteAt = deleteAt;
      var updateAt = function(k, a) {
        return function(r) {
          if (!(0, exports.has)(k, r)) {
            return _.none;
          }
          if (r[k] === a) {
            return _.some(r);
          }
          var out = Object.assign({}, r);
          out[k] = a;
          return _.some(out);
        };
      };
      exports.updateAt = updateAt;
      var modifyAt = function(k, f) {
        return function(r) {
          if (!(0, exports.has)(k, r)) {
            return _.none;
          }
          var next = f(r[k]);
          if (next === r[k]) {
            return _.some(r);
          }
          var out = Object.assign({}, r);
          out[k] = next;
          return _.some(out);
        };
      };
      exports.modifyAt = modifyAt;
      function pop(k) {
        var deleteAtk = deleteAt(k);
        return function(r) {
          var oa = lookup(k, r);
          return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);
        };
      }
      exports.pop = pop;
      function isSubrecord(E) {
        return function(me, that) {
          if (that === void 0) {
            var isSubrecordE_1 = isSubrecord(E);
            return function(that2) {
              return isSubrecordE_1(that2, me);
            };
          }
          for (var k in me) {
            if (!_.has.call(that, k) || !E.equals(me[k], that[k])) {
              return false;
            }
          }
          return true;
        };
      }
      exports.isSubrecord = isSubrecord;
      function lookup(k, r) {
        if (r === void 0) {
          return function(r2) {
            return lookup(k, r2);
          };
        }
        return _.has.call(r, k) ? _.some(r[k]) : _.none;
      }
      exports.lookup = lookup;
      exports.empty = {};
      function mapWithIndex(f) {
        return function(r) {
          var out = {};
          for (var k in r) {
            if (_.has.call(r, k)) {
              out[k] = f(k, r[k]);
            }
          }
          return out;
        };
      }
      exports.mapWithIndex = mapWithIndex;
      function map(f) {
        return mapWithIndex(function(_2, a) {
          return f(a);
        });
      }
      exports.map = map;
      function reduceWithIndex() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (args.length === 2) {
          return reduceWithIndex(S.Ord).apply(void 0, args);
        }
        var keysO = keys_(args[0]);
        return function(b, f) {
          return function(fa) {
            var out = b;
            var ks = keysO(fa);
            var len = ks.length;
            for (var i = 0; i < len; i++) {
              var k = ks[i];
              out = f(k, out, fa[k]);
            }
            return out;
          };
        };
      }
      exports.reduceWithIndex = reduceWithIndex;
      function foldMapWithIndex(O) {
        if ("compare" in O) {
          var keysO_1 = keys_(O);
          return function(M) {
            return function(f) {
              return function(fa) {
                var out = M.empty;
                var ks = keysO_1(fa);
                var len = ks.length;
                for (var i = 0; i < len; i++) {
                  var k = ks[i];
                  out = M.concat(out, f(k, fa[k]));
                }
                return out;
              };
            };
          };
        }
        return foldMapWithIndex(S.Ord)(O);
      }
      exports.foldMapWithIndex = foldMapWithIndex;
      function reduceRightWithIndex() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (args.length === 2) {
          return reduceRightWithIndex(S.Ord).apply(void 0, args);
        }
        var keysO = keys_(args[0]);
        return function(b, f) {
          return function(fa) {
            var out = b;
            var ks = keysO(fa);
            var len = ks.length;
            for (var i = len - 1; i >= 0; i--) {
              var k = ks[i];
              out = f(k, fa[k], out);
            }
            return out;
          };
        };
      }
      exports.reduceRightWithIndex = reduceRightWithIndex;
      var singleton = function(k, a) {
        var _a;
        return _a = {}, _a[k] = a, _a;
      };
      exports.singleton = singleton;
      function traverseWithIndex(F) {
        var traverseWithIndexOF = _traverseWithIndex(S.Ord)(F);
        return function(f) {
          return function(ta) {
            return traverseWithIndexOF(ta, f);
          };
        };
      }
      exports.traverseWithIndex = traverseWithIndex;
      function traverse(F) {
        var traverseOF = (0, exports._traverse)(S.Ord)(F);
        return function(f) {
          return function(ta) {
            return traverseOF(ta, f);
          };
        };
      }
      exports.traverse = traverse;
      function sequence(F) {
        return (0, exports._sequence)(S.Ord)(F);
      }
      exports.sequence = sequence;
      var wither = function(F) {
        var traverseF = traverse(F);
        return function(f) {
          return function(fa) {
            return F.map((0, function_1.pipe)(fa, traverseF(f)), exports.compact);
          };
        };
      };
      exports.wither = wither;
      var wilt = function(F) {
        var traverseF = traverse(F);
        return function(f) {
          return function(fa) {
            return F.map((0, function_1.pipe)(fa, traverseF(f)), exports.separate);
          };
        };
      };
      exports.wilt = wilt;
      function partitionMapWithIndex(f) {
        return function(r) {
          var left = {};
          var right = {};
          for (var k in r) {
            if (_.has.call(r, k)) {
              var e = f(k, r[k]);
              switch (e._tag) {
                case "Left":
                  left[k] = e.left;
                  break;
                case "Right":
                  right[k] = e.right;
                  break;
              }
            }
          }
          return (0, Separated_1.separated)(left, right);
        };
      }
      exports.partitionMapWithIndex = partitionMapWithIndex;
      function partitionWithIndex(predicateWithIndex) {
        return function(r) {
          var left = {};
          var right = {};
          for (var k in r) {
            if (_.has.call(r, k)) {
              var a = r[k];
              if (predicateWithIndex(k, a)) {
                right[k] = a;
              } else {
                left[k] = a;
              }
            }
          }
          return (0, Separated_1.separated)(left, right);
        };
      }
      exports.partitionWithIndex = partitionWithIndex;
      function filterMapWithIndex(f) {
        return function(r) {
          var out = {};
          for (var k in r) {
            if (_.has.call(r, k)) {
              var ob = f(k, r[k]);
              if (_.isSome(ob)) {
                out[k] = ob.value;
              }
            }
          }
          return out;
        };
      }
      exports.filterMapWithIndex = filterMapWithIndex;
      function filterWithIndex(predicateWithIndex) {
        return function(fa) {
          var out = {};
          var changed = false;
          for (var key in fa) {
            if (_.has.call(fa, key)) {
              var a = fa[key];
              if (predicateWithIndex(key, a)) {
                out[key] = a;
              } else {
                changed = true;
              }
            }
          }
          return changed ? out : fa;
        };
      }
      exports.filterWithIndex = filterWithIndex;
      function fromFoldable(M, F) {
        var fromFoldableMapM = fromFoldableMap(M, F);
        return function(fka) {
          return fromFoldableMapM(fka, function_1.identity);
        };
      }
      exports.fromFoldable = fromFoldable;
      function fromFoldableMap(M, F) {
        return function(ta, f) {
          return F.reduce(ta, {}, function(r, a) {
            var _a = f(a), k = _a[0], b = _a[1];
            r[k] = _.has.call(r, k) ? M.concat(r[k], b) : b;
            return r;
          });
        };
      }
      exports.fromFoldableMap = fromFoldableMap;
      exports.toEntries = exports.toReadonlyArray;
      var fromEntries = function(fa) {
        var out = {};
        for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
          var a = fa_1[_i];
          out[a[0]] = a[1];
        }
        return out;
      };
      exports.fromEntries = fromEntries;
      function every(predicate) {
        return function(r) {
          for (var k in r) {
            if (!predicate(r[k])) {
              return false;
            }
          }
          return true;
        };
      }
      exports.every = every;
      function some(predicate) {
        return function(r) {
          for (var k in r) {
            if (predicate(r[k])) {
              return true;
            }
          }
          return false;
        };
      }
      exports.some = some;
      function elem(E) {
        return function(a, fa) {
          if (fa === void 0) {
            var elemE_1 = elem(E);
            return function(fa2) {
              return elemE_1(a, fa2);
            };
          }
          for (var k in fa) {
            if (E.equals(fa[k], a)) {
              return true;
            }
          }
          return false;
        };
      }
      exports.elem = elem;
      var union = function(M) {
        return function(second) {
          return function(first) {
            if ((0, exports.isEmpty)(first)) {
              return second;
            }
            if ((0, exports.isEmpty)(second)) {
              return first;
            }
            var out = {};
            for (var k in first) {
              if ((0, exports.has)(k, second)) {
                out[k] = M.concat(first[k], second[k]);
              } else {
                out[k] = first[k];
              }
            }
            for (var k in second) {
              if (!(0, exports.has)(k, out)) {
                out[k] = second[k];
              }
            }
            return out;
          };
        };
      };
      exports.union = union;
      var intersection = function(M) {
        return function(second) {
          return function(first) {
            if ((0, exports.isEmpty)(first) || (0, exports.isEmpty)(second)) {
              return exports.empty;
            }
            var out = {};
            for (var k in first) {
              if ((0, exports.has)(k, second)) {
                out[k] = M.concat(first[k], second[k]);
              }
            }
            return out;
          };
        };
      };
      exports.intersection = intersection;
      var difference = function(second) {
        return function(first) {
          if ((0, exports.isEmpty)(first)) {
            return second;
          }
          if ((0, exports.isEmpty)(second)) {
            return first;
          }
          var out = {};
          for (var k in first) {
            if (!(0, exports.has)(k, second)) {
              out[k] = first[k];
            }
          }
          for (var k in second) {
            if (!(0, exports.has)(k, first)) {
              out[k] = second[k];
            }
          }
          return out;
        };
      };
      exports.difference = difference;
      var _map = function(fa, f) {
        return (0, function_1.pipe)(fa, map(f));
      };
      exports._map = _map;
      var _mapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, mapWithIndex(f));
      };
      exports._mapWithIndex = _mapWithIndex;
      var _reduce = function(O) {
        var reduceO = reduce(O);
        return function(fa, b, f) {
          return (0, function_1.pipe)(fa, reduceO(b, f));
        };
      };
      exports._reduce = _reduce;
      var _foldMap = function(O) {
        return function(M) {
          var foldMapM = foldMap(O)(M);
          return function(fa, f) {
            return (0, function_1.pipe)(fa, foldMapM(f));
          };
        };
      };
      exports._foldMap = _foldMap;
      var _reduceRight = function(O) {
        var reduceRightO = reduceRight(O);
        return function(fa, b, f) {
          return (0, function_1.pipe)(fa, reduceRightO(b, f));
        };
      };
      exports._reduceRight = _reduceRight;
      var _filter = function(fa, predicate) {
        return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));
      };
      exports._filter = _filter;
      var _filterMap = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.filterMap)(f));
      };
      exports._filterMap = _filterMap;
      var _partition = function(fa, predicate) {
        return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
      };
      exports._partition = _partition;
      var _partitionMap = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f));
      };
      exports._partitionMap = _partitionMap;
      var _reduceWithIndex = function(O) {
        var reduceWithIndexO = reduceWithIndex(O);
        return function(fa, b, f) {
          return (0, function_1.pipe)(fa, reduceWithIndexO(b, f));
        };
      };
      exports._reduceWithIndex = _reduceWithIndex;
      var _foldMapWithIndex = function(O) {
        var foldMapWithIndexO = foldMapWithIndex(O);
        return function(M) {
          var foldMapWithIndexM = foldMapWithIndexO(M);
          return function(fa, f) {
            return (0, function_1.pipe)(fa, foldMapWithIndexM(f));
          };
        };
      };
      exports._foldMapWithIndex = _foldMapWithIndex;
      var _reduceRightWithIndex = function(O) {
        var reduceRightWithIndexO = reduceRightWithIndex(O);
        return function(fa, b, f) {
          return (0, function_1.pipe)(fa, reduceRightWithIndexO(b, f));
        };
      };
      exports._reduceRightWithIndex = _reduceRightWithIndex;
      var _partitionMapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, partitionMapWithIndex(f));
      };
      exports._partitionMapWithIndex = _partitionMapWithIndex;
      var _partitionWithIndex = function(fa, predicateWithIndex) {
        return (0, function_1.pipe)(fa, partitionWithIndex(predicateWithIndex));
      };
      exports._partitionWithIndex = _partitionWithIndex;
      var _filterMapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, filterMapWithIndex(f));
      };
      exports._filterMapWithIndex = _filterMapWithIndex;
      var _filterWithIndex = function(fa, predicateWithIndex) {
        return (0, function_1.pipe)(fa, filterWithIndex(predicateWithIndex));
      };
      exports._filterWithIndex = _filterWithIndex;
      var _traverse = function(O) {
        var traverseWithIndexO = _traverseWithIndex(O);
        return function(F) {
          var traverseWithIndexOF = traverseWithIndexO(F);
          return function(ta, f) {
            return traverseWithIndexOF(ta, (0, function_1.flow)(function_1.SK, f));
          };
        };
      };
      exports._traverse = _traverse;
      var _sequence = function(O) {
        var traverseO = (0, exports._traverse)(O);
        return function(F) {
          var traverseOF = traverseO(F);
          return function(ta) {
            return traverseOF(ta, function_1.identity);
          };
        };
      };
      exports._sequence = _sequence;
      var _traverseWithIndex = function(O) {
        return function(F) {
          var keysO = keys_(O);
          return function(ta, f) {
            var ks = keysO(ta);
            if (ks.length === 0) {
              return F.of(exports.empty);
            }
            var fr = F.of({});
            var _loop_1 = function(key2) {
              fr = F.ap(F.map(fr, function(r) {
                return function(b) {
                  var _a;
                  return Object.assign({}, r, (_a = {}, _a[key2] = b, _a));
                };
              }), f(key2, ta[key2]));
            };
            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
              var key = ks_1[_i];
              _loop_1(key);
            }
            return fr;
          };
        };
      };
      var filter = function(predicate) {
        return filterWithIndex(function(_2, a) {
          return predicate(a);
        });
      };
      exports.filter = filter;
      var filterMap = function(f) {
        return filterMapWithIndex(function(_2, a) {
          return f(a);
        });
      };
      exports.filterMap = filterMap;
      var partition = function(predicate) {
        return partitionWithIndex(function(_2, a) {
          return predicate(a);
        });
      };
      exports.partition = partition;
      var partitionMap = function(f) {
        return partitionMapWithIndex(function(_2, a) {
          return f(a);
        });
      };
      exports.partitionMap = partitionMap;
      function reduce() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (args.length === 1) {
          var reduceWithIndexO_1 = reduceWithIndex(args[0]);
          return function(b, f) {
            return reduceWithIndexO_1(b, function(_2, b2, a) {
              return f(b2, a);
            });
          };
        }
        return reduce(S.Ord).apply(void 0, args);
      }
      exports.reduce = reduce;
      function foldMap(O) {
        if ("compare" in O) {
          var foldMapWithIndexO_1 = foldMapWithIndex(O);
          return function(M) {
            var foldMapWithIndexM = foldMapWithIndexO_1(M);
            return function(f) {
              return foldMapWithIndexM(function(_2, a) {
                return f(a);
              });
            };
          };
        }
        return foldMap(S.Ord)(O);
      }
      exports.foldMap = foldMap;
      function reduceRight() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (args.length === 1) {
          var reduceRightWithIndexO_1 = reduceRightWithIndex(args[0]);
          return function(b, f) {
            return reduceRightWithIndexO_1(b, function(_2, b2, a) {
              return f(b2, a);
            });
          };
        }
        return reduceRight(S.Ord).apply(void 0, args);
      }
      exports.reduceRight = reduceRight;
      var compact = function(r) {
        var out = {};
        for (var k in r) {
          if (_.has.call(r, k)) {
            var oa = r[k];
            if (_.isSome(oa)) {
              out[k] = oa.value;
            }
          }
        }
        return out;
      };
      exports.compact = compact;
      var separate = function(r) {
        var left = {};
        var right = {};
        for (var k in r) {
          if (_.has.call(r, k)) {
            var e = r[k];
            if (_.isLeft(e)) {
              left[k] = e.left;
            } else {
              right[k] = e.right;
            }
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
      exports.separate = separate;
      exports.URI = "ReadonlyRecord";
      function getShow(O) {
        if ("compare" in O) {
          return function(S2) {
            return {
              show: function(r) {
                var elements = collect(O)(function(k, a) {
                  return "".concat(JSON.stringify(k), ": ").concat(S2.show(a));
                })(r).join(", ");
                return elements === "" ? "{}" : "{ ".concat(elements, " }");
              }
            };
          };
        }
        return getShow(S.Ord)(O);
      }
      exports.getShow = getShow;
      function getEq(E) {
        var isSubrecordE = isSubrecord(E);
        return (0, Eq_1.fromEquals)(function(x, y) {
          return isSubrecordE(x)(y) && isSubrecordE(y)(x);
        });
      }
      exports.getEq = getEq;
      function getMonoid(S2) {
        return {
          concat: function(first, second) {
            if ((0, exports.isEmpty)(first)) {
              return second;
            }
            if ((0, exports.isEmpty)(second)) {
              return first;
            }
            var r = Object.assign({}, first);
            for (var k in second) {
              if (_.has.call(second, k)) {
                r[k] = _.has.call(first, k) ? S2.concat(first[k], second[k]) : second[k];
              }
            }
            return r;
          },
          empty: exports.empty
        };
      }
      exports.getMonoid = getMonoid;
      exports.Functor = {
        URI: exports.URI,
        map: exports._map
      };
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.FunctorWithIndex = {
        URI: exports.URI,
        map: exports._map,
        mapWithIndex: exports._mapWithIndex
      };
      var getFoldable = function(O) {
        return {
          URI: exports.URI,
          reduce: (0, exports._reduce)(O),
          foldMap: (0, exports._foldMap)(O),
          reduceRight: (0, exports._reduceRight)(O)
        };
      };
      exports.getFoldable = getFoldable;
      var getFoldableWithIndex = function(O) {
        return {
          URI: exports.URI,
          reduce: (0, exports._reduce)(O),
          foldMap: (0, exports._foldMap)(O),
          reduceRight: (0, exports._reduceRight)(O),
          reduceWithIndex: (0, exports._reduceWithIndex)(O),
          foldMapWithIndex: (0, exports._foldMapWithIndex)(O),
          reduceRightWithIndex: (0, exports._reduceRightWithIndex)(O)
        };
      };
      exports.getFoldableWithIndex = getFoldableWithIndex;
      exports.Compactable = {
        URI: exports.URI,
        compact: exports.compact,
        separate: exports.separate
      };
      exports.Filterable = {
        URI: exports.URI,
        map: exports._map,
        compact: exports.compact,
        separate: exports.separate,
        filter: exports._filter,
        filterMap: exports._filterMap,
        partition: exports._partition,
        partitionMap: exports._partitionMap
      };
      exports.FilterableWithIndex = {
        URI: exports.URI,
        map: exports._map,
        mapWithIndex: exports._mapWithIndex,
        compact: exports.compact,
        separate: exports.separate,
        filter: exports._filter,
        filterMap: exports._filterMap,
        partition: exports._partition,
        partitionMap: exports._partitionMap,
        filterMapWithIndex: exports._filterMapWithIndex,
        filterWithIndex: exports._filterWithIndex,
        partitionMapWithIndex: exports._partitionMapWithIndex,
        partitionWithIndex: exports._partitionWithIndex
      };
      var getTraversable = function(O) {
        return {
          URI: exports.URI,
          map: exports._map,
          reduce: (0, exports._reduce)(O),
          foldMap: (0, exports._foldMap)(O),
          reduceRight: (0, exports._reduceRight)(O),
          traverse: (0, exports._traverse)(O),
          sequence: (0, exports._sequence)(O)
        };
      };
      exports.getTraversable = getTraversable;
      var getTraversableWithIndex = function(O) {
        return {
          URI: exports.URI,
          map: exports._map,
          mapWithIndex: exports._mapWithIndex,
          reduce: (0, exports._reduce)(O),
          foldMap: (0, exports._foldMap)(O),
          reduceRight: (0, exports._reduceRight)(O),
          reduceWithIndex: (0, exports._reduceWithIndex)(O),
          foldMapWithIndex: (0, exports._foldMapWithIndex)(O),
          reduceRightWithIndex: (0, exports._reduceRightWithIndex)(O),
          traverse: (0, exports._traverse)(O),
          sequence: (0, exports._sequence)(O),
          traverseWithIndex: _traverseWithIndex(O)
        };
      };
      exports.getTraversableWithIndex = getTraversableWithIndex;
      var getWitherable = function(O) {
        var T = (0, exports.getTraversable)(O);
        return {
          URI: exports.URI,
          map: exports._map,
          reduce: (0, exports._reduce)(O),
          foldMap: (0, exports._foldMap)(O),
          reduceRight: (0, exports._reduceRight)(O),
          traverse: T.traverse,
          sequence: T.sequence,
          compact: exports.compact,
          separate: exports.separate,
          filter: exports._filter,
          filterMap: exports._filterMap,
          partition: exports._partition,
          partitionMap: exports._partitionMap,
          wither: (0, Witherable_1.witherDefault)(T, exports.Compactable),
          wilt: (0, Witherable_1.wiltDefault)(T, exports.Compactable)
        };
      };
      exports.getWitherable = getWitherable;
      var getUnionSemigroup = function(S2) {
        var unionS = (0, exports.union)(S2);
        return {
          concat: function(first, second) {
            return unionS(second)(first);
          }
        };
      };
      exports.getUnionSemigroup = getUnionSemigroup;
      var getUnionMonoid = function(S2) {
        return {
          concat: (0, exports.getUnionSemigroup)(S2).concat,
          empty: exports.empty
        };
      };
      exports.getUnionMonoid = getUnionMonoid;
      var getIntersectionSemigroup = function(S2) {
        var intersectionS = (0, exports.intersection)(S2);
        return {
          concat: function(first, second) {
            return intersectionS(second)(first);
          }
        };
      };
      exports.getIntersectionSemigroup = getIntersectionSemigroup;
      var getDifferenceMagma = function() {
        return {
          concat: function(first, second) {
            return (0, exports.difference)(second)(first);
          }
        };
      };
      exports.getDifferenceMagma = getDifferenceMagma;
      exports.Foldable = {
        URI: exports.URI,
        reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
        foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
        reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord)
      };
      exports.FoldableWithIndex = {
        URI: exports.URI,
        reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
        foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
        reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord),
        reduceWithIndex: /* @__PURE__ */ (0, exports._reduceWithIndex)(S.Ord),
        foldMapWithIndex: /* @__PURE__ */ (0, exports._foldMapWithIndex)(S.Ord),
        reduceRightWithIndex: /* @__PURE__ */ (0, exports._reduceRightWithIndex)(S.Ord)
      };
      exports.Traversable = {
        URI: exports.URI,
        map: exports._map,
        reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
        foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
        reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord),
        traverse: /* @__PURE__ */ (0, exports._traverse)(S.Ord),
        sequence
      };
      exports.TraversableWithIndex = {
        URI: exports.URI,
        map: exports._map,
        mapWithIndex: exports._mapWithIndex,
        reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
        foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
        reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord),
        reduceWithIndex: /* @__PURE__ */ (0, exports._reduceWithIndex)(S.Ord),
        foldMapWithIndex: /* @__PURE__ */ (0, exports._foldMapWithIndex)(S.Ord),
        reduceRightWithIndex: /* @__PURE__ */ (0, exports._reduceRightWithIndex)(S.Ord),
        traverse: /* @__PURE__ */ (0, exports._traverse)(S.Ord),
        sequence,
        traverseWithIndex: /* @__PURE__ */ _traverseWithIndex(S.Ord)
      };
      var _wither = /* @__PURE__ */ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
      var _wilt = /* @__PURE__ */ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
      exports.Witherable = {
        URI: exports.URI,
        map: exports._map,
        reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
        foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
        reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord),
        traverse: /* @__PURE__ */ (0, exports._traverse)(S.Ord),
        sequence,
        compact: exports.compact,
        separate: exports.separate,
        filter: exports._filter,
        filterMap: exports._filterMap,
        partition: exports._partition,
        partitionMap: exports._partitionMap,
        wither: _wither,
        wilt: _wilt
      };
      exports.insertAt = exports.upsertAt;
      function hasOwnProperty(k, r) {
        return _.has.call(r === void 0 ? this : r, k);
      }
      exports.hasOwnProperty = hasOwnProperty;
      exports.readonlyRecord = {
        URI: exports.URI,
        map: exports._map,
        reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
        foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
        reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord),
        traverse: /* @__PURE__ */ (0, exports._traverse)(S.Ord),
        sequence,
        compact: exports.compact,
        separate: exports.separate,
        filter: exports._filter,
        filterMap: exports._filterMap,
        partition: exports._partition,
        partitionMap: exports._partitionMap,
        mapWithIndex: exports._mapWithIndex,
        reduceWithIndex: /* @__PURE__ */ (0, exports._reduceWithIndex)(S.Ord),
        foldMapWithIndex: /* @__PURE__ */ (0, exports._foldMapWithIndex)(S.Ord),
        reduceRightWithIndex: /* @__PURE__ */ (0, exports._reduceRightWithIndex)(S.Ord),
        filterMapWithIndex: exports._filterMapWithIndex,
        filterWithIndex: exports._filterWithIndex,
        partitionMapWithIndex: exports._partitionMapWithIndex,
        partitionWithIndex: exports._partitionWithIndex,
        traverseWithIndex: /* @__PURE__ */ _traverseWithIndex(S.Ord),
        wither: _wither,
        wilt: _wilt
      };
    }
  });

  // node_modules/fp-ts/lib/Record.js
  var require_Record = __commonJS({
    "node_modules/fp-ts/lib/Record.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getShow = exports.URI = exports.separate = exports.compact = exports.reduceRight = exports.foldMap = exports.reduce = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.difference = exports.intersection = exports.union = exports.elem = exports.some = exports.every = exports.fromFoldableMap = exports.fromEntries = exports.toEntries = exports.fromFoldable = exports.filterWithIndex = exports.filterMapWithIndex = exports.partitionWithIndex = exports.partitionMapWithIndex = exports.wilt = exports.wither = exports.sequence = exports.traverse = exports.traverseWithIndex = exports.singleton = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.map = exports.mapWithIndex = exports.lookup = exports.isSubrecord = exports.pop = exports.modifyAt = exports.updateAt = exports.deleteAt = exports.has = exports.upsertAt = exports.toUnfoldable = exports.toArray = exports.collect = exports.keys = exports.isEmpty = exports.size = void 0;
      exports.record = exports.hasOwnProperty = exports.insertAt = exports.empty = exports.Witherable = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getWitherable = exports.getTraversableWithIndex = exports.getTraversable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.getFoldableWithIndex = exports.getFoldable = exports.FunctorWithIndex = exports.flap = exports.Functor = exports.getMonoid = exports.getEq = void 0;
      var A = __importStar(require_Array());
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar(require_internal());
      var RR = __importStar(require_ReadonlyRecord());
      var Se = __importStar(require_Semigroup());
      var S = __importStar(require_string());
      var Witherable_1 = require_Witherable();
      exports.size = RR.size;
      exports.isEmpty = RR.isEmpty;
      var keys_ = function(O) {
        return function(r) {
          return Object.keys(r).sort(O.compare);
        };
      };
      exports.keys = keys_(S.Ord);
      function collect(O) {
        if (typeof O === "function") {
          return collect(S.Ord)(O);
        }
        var keysO = keys_(O);
        return function(f) {
          return function(r) {
            var out = [];
            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
              var key = _a[_i];
              out.push(f(key, r[key]));
            }
            return out;
          };
        };
      }
      exports.collect = collect;
      exports.toArray = collect(S.Ord)(function(k, a) {
        return [
          k,
          a
        ];
      });
      function toUnfoldable(U) {
        return function(r) {
          var sas = (0, exports.toArray)(r);
          var len = sas.length;
          return U.unfold(0, function(b) {
            return b < len ? _.some([sas[b], b + 1]) : _.none;
          });
        };
      }
      exports.toUnfoldable = toUnfoldable;
      exports.upsertAt = RR.upsertAt;
      exports.has = RR.has;
      function deleteAt(k) {
        return function(r) {
          if (!_.has.call(r, k)) {
            return r;
          }
          var out = Object.assign({}, r);
          delete out[k];
          return out;
        };
      }
      exports.deleteAt = deleteAt;
      var updateAt = function(k, a) {
        return (0, exports.modifyAt)(k, function() {
          return a;
        });
      };
      exports.updateAt = updateAt;
      var modifyAt = function(k, f) {
        return function(r) {
          if (!(0, exports.has)(k, r)) {
            return _.none;
          }
          var out = Object.assign({}, r);
          out[k] = f(r[k]);
          return _.some(out);
        };
      };
      exports.modifyAt = modifyAt;
      function pop(k) {
        var deleteAtk = deleteAt(k);
        return function(r) {
          var oa = (0, exports.lookup)(k, r);
          return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);
        };
      }
      exports.pop = pop;
      exports.isSubrecord = RR.isSubrecord;
      exports.lookup = RR.lookup;
      exports.mapWithIndex = RR.mapWithIndex;
      exports.map = RR.map;
      function reduceWithIndex() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return args.length === 1 ? RR.reduceWithIndex(args[0]) : RR.reduceWithIndex(S.Ord).apply(void 0, args);
      }
      exports.reduceWithIndex = reduceWithIndex;
      function foldMapWithIndex(O) {
        return "compare" in O ? RR.foldMapWithIndex(O) : RR.foldMapWithIndex(S.Ord)(O);
      }
      exports.foldMapWithIndex = foldMapWithIndex;
      function reduceRightWithIndex() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return args.length === 1 ? RR.reduceRightWithIndex(args[0]) : RR.reduceRightWithIndex(S.Ord).apply(void 0, args);
      }
      exports.reduceRightWithIndex = reduceRightWithIndex;
      exports.singleton = RR.singleton;
      function traverseWithIndex(F) {
        return RR.traverseWithIndex(F);
      }
      exports.traverseWithIndex = traverseWithIndex;
      function traverse(F) {
        return RR.traverse(F);
      }
      exports.traverse = traverse;
      function sequence(F) {
        return RR.sequence(F);
      }
      exports.sequence = sequence;
      var wither = function(F) {
        var traverseF = traverse(F);
        return function(f) {
          return function(fa) {
            return F.map((0, function_1.pipe)(fa, traverseF(f)), exports.compact);
          };
        };
      };
      exports.wither = wither;
      var wilt = function(F) {
        var traverseF = traverse(F);
        return function(f) {
          return function(fa) {
            return F.map((0, function_1.pipe)(fa, traverseF(f)), exports.separate);
          };
        };
      };
      exports.wilt = wilt;
      exports.partitionMapWithIndex = RR.partitionMapWithIndex;
      function partitionWithIndex(predicateWithIndex) {
        return RR.partitionWithIndex(predicateWithIndex);
      }
      exports.partitionWithIndex = partitionWithIndex;
      exports.filterMapWithIndex = RR.filterMapWithIndex;
      function filterWithIndex(predicateWithIndex) {
        return RR.filterWithIndex(predicateWithIndex);
      }
      exports.filterWithIndex = filterWithIndex;
      function fromFoldable(M, F) {
        return RR.fromFoldable(M, F);
      }
      exports.fromFoldable = fromFoldable;
      exports.toEntries = exports.toArray;
      var fromEntries = function(fa) {
        return fromFoldable(Se.last(), A.Foldable)(fa);
      };
      exports.fromEntries = fromEntries;
      function fromFoldableMap(M, F) {
        return RR.fromFoldableMap(M, F);
      }
      exports.fromFoldableMap = fromFoldableMap;
      exports.every = RR.every;
      exports.some = RR.some;
      exports.elem = RR.elem;
      var union = function(M) {
        var unionM = RR.union(M);
        return function(second) {
          return function(first) {
            if ((0, exports.isEmpty)(first)) {
              return __assign({}, second);
            }
            if ((0, exports.isEmpty)(second)) {
              return __assign({}, first);
            }
            return unionM(second)(first);
          };
        };
      };
      exports.union = union;
      var intersection = function(M) {
        return function(second) {
          return function(first) {
            if ((0, exports.isEmpty)(first) || (0, exports.isEmpty)(second)) {
              return {};
            }
            return RR.intersection(M)(second)(first);
          };
        };
      };
      exports.intersection = intersection;
      var difference = function(second) {
        return function(first) {
          if ((0, exports.isEmpty)(first)) {
            return __assign({}, second);
          }
          if ((0, exports.isEmpty)(second)) {
            return __assign({}, first);
          }
          return RR.difference(second)(first);
        };
      };
      exports.difference = difference;
      var _map = RR._map;
      var _mapWithIndex = RR._mapWithIndex;
      var _reduce = RR._reduce;
      var _foldMap = RR._foldMap;
      var _reduceRight = RR._reduceRight;
      var _filter = RR._filter;
      var _filterMap = RR._filterMap;
      var _partition = RR._partition;
      var _partitionMap = RR._partitionMap;
      var _reduceWithIndex = RR._reduceWithIndex;
      var _foldMapWithIndex = RR._foldMapWithIndex;
      var _reduceRightWithIndex = RR._reduceRightWithIndex;
      var _partitionMapWithIndex = RR._partitionMapWithIndex;
      var _partitionWithIndex = RR._partitionWithIndex;
      var _filterMapWithIndex = RR._filterMapWithIndex;
      var _filterWithIndex = RR._filterWithIndex;
      var _traverse = RR._traverse;
      var _sequence = RR._sequence;
      var _traverseWithIndex = function(O) {
        return function(F) {
          var keysO = keys_(O);
          return function(ta, f) {
            var ks = keysO(ta);
            if (ks.length === 0) {
              return F.of({});
            }
            var fr = F.of({});
            var _loop_1 = function(key2) {
              fr = F.ap(F.map(fr, function(r) {
                return function(b) {
                  r[key2] = b;
                  return r;
                };
              }), f(key2, ta[key2]));
            };
            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
              var key = ks_1[_i];
              _loop_1(key);
            }
            return fr;
          };
        };
      };
      exports.filter = RR.filter;
      exports.filterMap = RR.filterMap;
      exports.partition = RR.partition;
      exports.partitionMap = RR.partitionMap;
      function reduce() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return args.length === 1 ? RR.reduce(args[0]) : RR.reduce(S.Ord).apply(void 0, args);
      }
      exports.reduce = reduce;
      function foldMap(O) {
        return "compare" in O ? RR.foldMap(O) : RR.foldMap(S.Ord)(O);
      }
      exports.foldMap = foldMap;
      function reduceRight() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return args.length === 1 ? RR.reduceRight(args[0]) : RR.reduceRight(S.Ord).apply(void 0, args);
      }
      exports.reduceRight = reduceRight;
      exports.compact = RR.compact;
      exports.separate = RR.separate;
      exports.URI = "Record";
      function getShow(O) {
        return "compare" in O ? RR.getShow(O) : RR.getShow(S.Ord)(O);
      }
      exports.getShow = getShow;
      exports.getEq = RR.getEq;
      exports.getMonoid = RR.getMonoid;
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.FunctorWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex
      };
      var getFoldable = function(O) {
        return {
          URI: exports.URI,
          reduce: _reduce(O),
          foldMap: _foldMap(O),
          reduceRight: _reduceRight(O)
        };
      };
      exports.getFoldable = getFoldable;
      var getFoldableWithIndex = function(O) {
        return {
          URI: exports.URI,
          reduce: _reduce(O),
          foldMap: _foldMap(O),
          reduceRight: _reduceRight(O),
          reduceWithIndex: _reduceWithIndex(O),
          foldMapWithIndex: _foldMapWithIndex(O),
          reduceRightWithIndex: _reduceRightWithIndex(O)
        };
      };
      exports.getFoldableWithIndex = getFoldableWithIndex;
      exports.Compactable = {
        URI: exports.URI,
        compact: exports.compact,
        separate: exports.separate
      };
      exports.Filterable = {
        URI: exports.URI,
        map: _map,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap
      };
      exports.FilterableWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex
      };
      var getTraversable = function(O) {
        return {
          URI: exports.URI,
          map: _map,
          reduce: _reduce(O),
          foldMap: _foldMap(O),
          reduceRight: _reduceRight(O),
          traverse: _traverse(O),
          sequence: _sequence(O)
        };
      };
      exports.getTraversable = getTraversable;
      var getTraversableWithIndex = function(O) {
        return {
          URI: exports.URI,
          map: _map,
          mapWithIndex: _mapWithIndex,
          reduce: _reduce(O),
          foldMap: _foldMap(O),
          reduceRight: _reduceRight(O),
          reduceWithIndex: _reduceWithIndex(O),
          foldMapWithIndex: _foldMapWithIndex(O),
          reduceRightWithIndex: _reduceRightWithIndex(O),
          traverse: _traverse(O),
          sequence: _sequence(O),
          traverseWithIndex: _traverseWithIndex(O)
        };
      };
      exports.getTraversableWithIndex = getTraversableWithIndex;
      var getWitherable = function(O) {
        var T = (0, exports.getTraversable)(O);
        return {
          URI: exports.URI,
          map: _map,
          reduce: _reduce(O),
          foldMap: _foldMap(O),
          reduceRight: _reduceRight(O),
          traverse: T.traverse,
          sequence: T.sequence,
          compact: exports.compact,
          separate: exports.separate,
          filter: _filter,
          filterMap: _filterMap,
          partition: _partition,
          partitionMap: _partitionMap,
          wither: (0, Witherable_1.witherDefault)(T, exports.Compactable),
          wilt: (0, Witherable_1.wiltDefault)(T, exports.Compactable)
        };
      };
      exports.getWitherable = getWitherable;
      var getUnionSemigroup = function(S2) {
        var unionS = (0, exports.union)(S2);
        return {
          concat: function(first, second) {
            return unionS(second)(first);
          }
        };
      };
      exports.getUnionSemigroup = getUnionSemigroup;
      var getUnionMonoid = function(S2) {
        return {
          concat: (0, exports.getUnionSemigroup)(S2).concat,
          empty: {}
        };
      };
      exports.getUnionMonoid = getUnionMonoid;
      var getIntersectionSemigroup = function(S2) {
        var intersectionS = (0, exports.intersection)(S2);
        return {
          concat: function(first, second) {
            return intersectionS(second)(first);
          }
        };
      };
      exports.getIntersectionSemigroup = getIntersectionSemigroup;
      var getDifferenceMagma = function() {
        return {
          concat: function(first, second) {
            return (0, exports.difference)(second)(first);
          }
        };
      };
      exports.getDifferenceMagma = getDifferenceMagma;
      exports.Foldable = {
        URI: exports.URI,
        reduce: /* @__PURE__ */ _reduce(S.Ord),
        foldMap: /* @__PURE__ */ _foldMap(S.Ord),
        reduceRight: /* @__PURE__ */ _reduceRight(S.Ord)
      };
      exports.FoldableWithIndex = {
        URI: exports.URI,
        reduce: /* @__PURE__ */ _reduce(S.Ord),
        foldMap: /* @__PURE__ */ _foldMap(S.Ord),
        reduceRight: /* @__PURE__ */ _reduceRight(S.Ord),
        reduceWithIndex: /* @__PURE__ */ _reduceWithIndex(S.Ord),
        foldMapWithIndex: /* @__PURE__ */ _foldMapWithIndex(S.Ord),
        reduceRightWithIndex: /* @__PURE__ */ _reduceRightWithIndex(S.Ord)
      };
      exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: /* @__PURE__ */ _reduce(S.Ord),
        foldMap: /* @__PURE__ */ _foldMap(S.Ord),
        reduceRight: /* @__PURE__ */ _reduceRight(S.Ord),
        traverse: /* @__PURE__ */ _traverse(S.Ord),
        sequence
      };
      exports.TraversableWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex,
        reduce: /* @__PURE__ */ _reduce(S.Ord),
        foldMap: /* @__PURE__ */ _foldMap(S.Ord),
        reduceRight: /* @__PURE__ */ _reduceRight(S.Ord),
        reduceWithIndex: /* @__PURE__ */ _reduceWithIndex(S.Ord),
        foldMapWithIndex: /* @__PURE__ */ _foldMapWithIndex(S.Ord),
        reduceRightWithIndex: /* @__PURE__ */ _reduceRightWithIndex(S.Ord),
        traverse: /* @__PURE__ */ _traverse(S.Ord),
        sequence,
        traverseWithIndex: /* @__PURE__ */ _traverseWithIndex(S.Ord)
      };
      var _wither = /* @__PURE__ */ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
      var _wilt = /* @__PURE__ */ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
      exports.Witherable = {
        URI: exports.URI,
        map: _map,
        reduce: /* @__PURE__ */ _reduce(S.Ord),
        foldMap: /* @__PURE__ */ _foldMap(S.Ord),
        reduceRight: /* @__PURE__ */ _reduceRight(S.Ord),
        traverse: /* @__PURE__ */ _traverse(S.Ord),
        sequence,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        wither: _wither,
        wilt: _wilt
      };
      exports.empty = {};
      exports.insertAt = exports.upsertAt;
      exports.hasOwnProperty = RR.hasOwnProperty;
      exports.record = {
        URI: exports.URI,
        map: _map,
        reduce: /* @__PURE__ */ _reduce(S.Ord),
        foldMap: /* @__PURE__ */ _foldMap(S.Ord),
        reduceRight: /* @__PURE__ */ _reduceRight(S.Ord),
        traverse: /* @__PURE__ */ _traverse(S.Ord),
        sequence,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        mapWithIndex: _mapWithIndex,
        reduceWithIndex: /* @__PURE__ */ _reduceWithIndex(S.Ord),
        foldMapWithIndex: /* @__PURE__ */ _foldMapWithIndex(S.Ord),
        reduceRightWithIndex: /* @__PURE__ */ _reduceRightWithIndex(S.Ord),
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex,
        traverseWithIndex: /* @__PURE__ */ _traverseWithIndex(S.Ord),
        wither: _wither,
        wilt: _wilt
      };
    }
  });

  // node_modules/fp-ts/lib/pipeable.js
  var require_pipeable = __commonJS({
    "node_modules/fp-ts/lib/pipeable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pipe = exports.pipeable = exports.compose = exports.promap = exports.partitionMapWithIndex = exports.partitionWithIndex = exports.filterMapWithIndex = exports.filterWithIndex = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.alt = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.reduceRight = exports.foldMap = exports.reduce = exports.extend = exports.mapLeft = exports.bimap = exports.chain = exports.ap = exports.mapWithIndex = exports.contramap = exports.map = void 0;
      var Apply_1 = require_Apply();
      var Chain_1 = require_Chain();
      var function_1 = require_function();
      function map(F) {
        return function(f) {
          return function(fa) {
            return F.map(fa, f);
          };
        };
      }
      exports.map = map;
      function contramap(F) {
        return function(f) {
          return function(fa) {
            return F.contramap(fa, f);
          };
        };
      }
      exports.contramap = contramap;
      function mapWithIndex(F) {
        return function(f) {
          return function(fa) {
            return F.mapWithIndex(fa, f);
          };
        };
      }
      exports.mapWithIndex = mapWithIndex;
      function ap(F) {
        return function(fa) {
          return function(fab) {
            return F.ap(fab, fa);
          };
        };
      }
      exports.ap = ap;
      function chain(F) {
        return function(f) {
          return function(fa) {
            return F.chain(fa, f);
          };
        };
      }
      exports.chain = chain;
      function bimap(F) {
        return function(f, g) {
          return function(fea) {
            return F.bimap(fea, f, g);
          };
        };
      }
      exports.bimap = bimap;
      function mapLeft(F) {
        return function(f) {
          return function(fea) {
            return F.mapLeft(fea, f);
          };
        };
      }
      exports.mapLeft = mapLeft;
      function extend(F) {
        return function(f) {
          return function(wa) {
            return F.extend(wa, f);
          };
        };
      }
      exports.extend = extend;
      function reduce(F) {
        return function(b, f) {
          return function(fa) {
            return F.reduce(fa, b, f);
          };
        };
      }
      exports.reduce = reduce;
      function foldMap(F) {
        return function(M) {
          var foldMapM = F.foldMap(M);
          return function(f) {
            return function(fa) {
              return foldMapM(fa, f);
            };
          };
        };
      }
      exports.foldMap = foldMap;
      function reduceRight(F) {
        return function(b, f) {
          return function(fa) {
            return F.reduceRight(fa, b, f);
          };
        };
      }
      exports.reduceRight = reduceRight;
      function reduceWithIndex(F) {
        return function(b, f) {
          return function(fa) {
            return F.reduceWithIndex(fa, b, f);
          };
        };
      }
      exports.reduceWithIndex = reduceWithIndex;
      function foldMapWithIndex(F) {
        return function(M) {
          var foldMapWithIndexM = F.foldMapWithIndex(M);
          return function(f) {
            return function(fa) {
              return foldMapWithIndexM(fa, f);
            };
          };
        };
      }
      exports.foldMapWithIndex = foldMapWithIndex;
      function reduceRightWithIndex(F) {
        return function(b, f) {
          return function(fa) {
            return F.reduceRightWithIndex(fa, b, f);
          };
        };
      }
      exports.reduceRightWithIndex = reduceRightWithIndex;
      function alt(F) {
        return function(that) {
          return function(fa) {
            return F.alt(fa, that);
          };
        };
      }
      exports.alt = alt;
      function filter(F) {
        return function(predicate) {
          return function(fa) {
            return F.filter(fa, predicate);
          };
        };
      }
      exports.filter = filter;
      function filterMap(F) {
        return function(f) {
          return function(fa) {
            return F.filterMap(fa, f);
          };
        };
      }
      exports.filterMap = filterMap;
      function partition(F) {
        return function(f) {
          return function(fa) {
            return F.partition(fa, f);
          };
        };
      }
      exports.partition = partition;
      function partitionMap(F) {
        return function(f) {
          return function(fa) {
            return F.partitionMap(fa, f);
          };
        };
      }
      exports.partitionMap = partitionMap;
      function filterWithIndex(F) {
        return function(predicate) {
          return function(fa) {
            return F.filterWithIndex(fa, predicate);
          };
        };
      }
      exports.filterWithIndex = filterWithIndex;
      function filterMapWithIndex(F) {
        return function(f) {
          return function(fa) {
            return F.filterMapWithIndex(fa, f);
          };
        };
      }
      exports.filterMapWithIndex = filterMapWithIndex;
      function partitionWithIndex(F) {
        return function(f) {
          return function(fa) {
            return F.partitionWithIndex(fa, f);
          };
        };
      }
      exports.partitionWithIndex = partitionWithIndex;
      function partitionMapWithIndex(F) {
        return function(f) {
          return function(fa) {
            return F.partitionMapWithIndex(fa, f);
          };
        };
      }
      exports.partitionMapWithIndex = partitionMapWithIndex;
      function promap(F) {
        return function(f, g) {
          return function(fbc) {
            return F.promap(fbc, f, g);
          };
        };
      }
      exports.promap = promap;
      function compose(F) {
        return function(ea) {
          return function(ab) {
            return F.compose(ab, ea);
          };
        };
      }
      exports.compose = compose;
      var isFunctor = function(I) {
        return typeof I.map === "function";
      };
      var isContravariant = function(I) {
        return typeof I.contramap === "function";
      };
      var isFunctorWithIndex = function(I) {
        return typeof I.mapWithIndex === "function";
      };
      var isApply = function(I) {
        return typeof I.ap === "function";
      };
      var isChain = function(I) {
        return typeof I.chain === "function";
      };
      var isBifunctor = function(I) {
        return typeof I.bimap === "function";
      };
      var isExtend = function(I) {
        return typeof I.extend === "function";
      };
      var isFoldable = function(I) {
        return typeof I.reduce === "function";
      };
      var isFoldableWithIndex = function(I) {
        return typeof I.reduceWithIndex === "function";
      };
      var isAlt = function(I) {
        return typeof I.alt === "function";
      };
      var isCompactable = function(I) {
        return typeof I.compact === "function";
      };
      var isFilterable = function(I) {
        return typeof I.filter === "function";
      };
      var isFilterableWithIndex = function(I) {
        return typeof I.filterWithIndex === "function";
      };
      var isProfunctor = function(I) {
        return typeof I.promap === "function";
      };
      var isSemigroupoid = function(I) {
        return typeof I.compose === "function";
      };
      var isMonadThrow = function(I) {
        return typeof I.throwError === "function";
      };
      function pipeable(I) {
        var r = {};
        if (isFunctor(I)) {
          r.map = map(I);
        }
        if (isContravariant(I)) {
          r.contramap = contramap(I);
        }
        if (isFunctorWithIndex(I)) {
          r.mapWithIndex = mapWithIndex(I);
        }
        if (isApply(I)) {
          r.ap = ap(I);
          r.apFirst = (0, Apply_1.apFirst)(I);
          r.apSecond = (0, Apply_1.apSecond)(I);
        }
        if (isChain(I)) {
          r.chain = chain(I);
          r.chainFirst = (0, Chain_1.chainFirst)(I);
          r.flatten = r.chain(function_1.identity);
        }
        if (isBifunctor(I)) {
          r.bimap = bimap(I);
          r.mapLeft = mapLeft(I);
        }
        if (isExtend(I)) {
          r.extend = extend(I);
          r.duplicate = r.extend(function_1.identity);
        }
        if (isFoldable(I)) {
          r.reduce = reduce(I);
          r.foldMap = foldMap(I);
          r.reduceRight = reduceRight(I);
        }
        if (isFoldableWithIndex(I)) {
          r.reduceWithIndex = reduceWithIndex(I);
          r.foldMapWithIndex = foldMapWithIndex(I);
          r.reduceRightWithIndex = reduceRightWithIndex(I);
        }
        if (isAlt(I)) {
          r.alt = alt(I);
        }
        if (isCompactable(I)) {
          r.compact = I.compact;
          r.separate = I.separate;
        }
        if (isFilterable(I)) {
          r.filter = filter(I);
          r.filterMap = filterMap(I);
          r.partition = partition(I);
          r.partitionMap = partitionMap(I);
        }
        if (isFilterableWithIndex(I)) {
          r.filterWithIndex = filterWithIndex(I);
          r.filterMapWithIndex = filterMapWithIndex(I);
          r.partitionWithIndex = partitionWithIndex(I);
          r.partitionMapWithIndex = partitionMapWithIndex(I);
        }
        if (isProfunctor(I)) {
          r.promap = promap(I);
        }
        if (isSemigroupoid(I)) {
          r.compose = compose(I);
        }
        if (isMonadThrow(I)) {
          var fromOption = function(onNone) {
            return function(ma) {
              return ma._tag === "None" ? I.throwError(onNone()) : I.of(ma.value);
            };
          };
          var fromEither = function(ma) {
            return ma._tag === "Left" ? I.throwError(ma.left) : I.of(ma.right);
          };
          var fromPredicate = function(predicate, onFalse) {
            return function(a) {
              return predicate(a) ? I.of(a) : I.throwError(onFalse(a));
            };
          };
          var filterOrElse = function(predicate, onFalse) {
            return function(ma) {
              return I.chain(ma, function(a) {
                return predicate(a) ? I.of(a) : I.throwError(onFalse(a));
              });
            };
          };
          r.fromOption = fromOption;
          r.fromEither = fromEither;
          r.fromPredicate = fromPredicate;
          r.filterOrElse = filterOrElse;
        }
        return r;
      }
      exports.pipeable = pipeable;
      exports.pipe = function_1.pipe;
    }
  });

  // node_modules/io-ts-reporters/target/src/utils.js
  var require_utils = __commonJS({
    "node_modules/io-ts-reporters/target/src/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.takeUntil = void 0;
      var takeUntil = function(predicate) {
        return function(as) {
          var init = [];
          for (var i = 0; i < as.length; i++) {
            init[i] = as[i];
            if (predicate(as[i])) {
              return init;
            }
          }
          return init;
        };
      };
      exports.takeUntil = takeUntil;
    }
  });

  // node_modules/io-ts-reporters/target/src/index.js
  var require_src = __commonJS({
    "node_modules/io-ts-reporters/target/src/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.reporter = exports.formatValidationErrors = exports.formatValidationError = exports.TYPE_MAX_LEN = void 0;
      var A = require_Array();
      var E = require_Either();
      var NEA = require_NonEmptyArray();
      var O = require_Option();
      var R = require_Record();
      var pipeable_1 = require_pipeable();
      var t = require_lib();
      var utils_1 = require_utils();
      var isUnionType = function(_a) {
        var type = _a.type;
        return type instanceof t.UnionType;
      };
      var jsToString = function(value) {
        return value === void 0 ? "undefined" : JSON.stringify(value);
      };
      var keyPath = function(ctx) {
        return ctx.map(function(c) {
          return c.key;
        }).filter(Boolean).join(".");
      };
      var getErrorFromCtx = function(validation) {
        return A.last(validation.context);
      };
      var getValidationContext = function(validation) {
        return validation.context;
      };
      exports.TYPE_MAX_LEN = 160;
      var truncateType = function(type, options) {
        if (options === void 0) {
          options = {};
        }
        var _a = options.truncateLongTypes, truncateLongTypes = _a === void 0 ? true : _a;
        if (truncateLongTypes && type.length > exports.TYPE_MAX_LEN) {
          return type.slice(0, exports.TYPE_MAX_LEN - 3) + "...";
        }
        return type;
      };
      var errorMessageSimple = function(expectedType, path, error, options) {
        return [
          "Expecting " + truncateType(expectedType, options),
          path === "" ? "" : "at " + path,
          "but instead got: " + jsToString(error.value),
          error.message ? "(" + error.message + ")" : ""
        ].filter(Boolean).join(" ");
      };
      var errorMessageUnion = function(expectedTypes, path, value, options) {
        return [
          "Expecting one of:\n",
          expectedTypes.map(function(type) {
            return "    " + truncateType(type, options);
          }).join("\n"),
          path === "" ? "\n" : "\nat " + path + " ",
          "but instead got: " + jsToString(value)
        ].filter(Boolean).join("");
      };
      var findExpectedType = function(ctx) {
        return pipeable_1.pipe(ctx, A.findIndex(isUnionType), O.chain(function(n) {
          return A.lookup(n + 1, ctx);
        }));
      };
      var formatValidationErrorOfUnion = function(path, errors, options) {
        var expectedTypes = pipeable_1.pipe(errors, A.map(getValidationContext), A.map(findExpectedType), A.compact);
        var value = pipeable_1.pipe(expectedTypes, A.head, O.map(function(v) {
          return v.actual;
        }), O.getOrElse(function() {
          return void 0;
        }));
        var expected = expectedTypes.map(function(_a) {
          var type = _a.type;
          return type.name;
        });
        return expected.length > 0 ? O.some(errorMessageUnion(expected, path, value, options)) : O.none;
      };
      var formatValidationCommonError = function(path, error, options) {
        return pipeable_1.pipe(error, getErrorFromCtx, O.map(function(errorContext) {
          return errorMessageSimple(errorContext.type.name, path, error, options);
        }));
      };
      var groupByKey = NEA.groupBy(function(error) {
        return pipeable_1.pipe(error.context, utils_1.takeUntil(isUnionType), keyPath);
      });
      var format = function(path, errors, options) {
        return NEA.tail(errors).length > 0 ? formatValidationErrorOfUnion(path, errors, options) : formatValidationCommonError(path, NEA.head(errors), options);
      };
      var formatValidationError = function(error, options) {
        return formatValidationCommonError(keyPath(error.context), error, options);
      };
      exports.formatValidationError = formatValidationError;
      var formatValidationErrors = function(errors, options) {
        return pipeable_1.pipe(errors, groupByKey, R.mapWithIndex(function(path, errors2) {
          return format(path, errors2, options);
        }), R.compact, R.toArray, A.map(function(_a) {
          var _key = _a[0], error = _a[1];
          return error;
        }));
      };
      exports.formatValidationErrors = formatValidationErrors;
      var reporter = function(validation, options) {
        return pipeable_1.pipe(validation, E.mapLeft(function(errors) {
          return exports.formatValidationErrors(errors, options);
        }), E.fold(function(errors) {
          return errors;
        }, function() {
          return [];
        }));
      };
      exports.reporter = reporter;
      var prettyReporter = { report: exports.reporter };
      exports.default = prettyReporter;
    }
  });

  // node_modules/dataloader/index.js
  var require_dataloader = __commonJS({
    "node_modules/dataloader/index.js"(exports, module) {
      "use strict";
      var DataLoader = /* @__PURE__ */ function() {
        function DataLoader2(batchLoadFn, options) {
          if (typeof batchLoadFn !== "function") {
            throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
          }
          this._batchLoadFn = batchLoadFn;
          this._maxBatchSize = getValidMaxBatchSize(options);
          this._batchScheduleFn = getValidBatchScheduleFn(options);
          this._cacheKeyFn = getValidCacheKeyFn(options);
          this._cacheMap = getValidCacheMap(options);
          this._batch = null;
        }
        var _proto = DataLoader2.prototype;
        _proto.load = function load(key) {
          if (key === null || key === void 0) {
            throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key) + "."));
          }
          var batch = getCurrentBatch(this);
          var cacheMap = this._cacheMap;
          var cacheKey = this._cacheKeyFn(key);
          if (cacheMap) {
            var cachedPromise = cacheMap.get(cacheKey);
            if (cachedPromise) {
              var cacheHits = batch.cacheHits || (batch.cacheHits = []);
              return new Promise(function(resolve) {
                cacheHits.push(function() {
                  resolve(cachedPromise);
                });
              });
            }
          }
          batch.keys.push(key);
          var promise = new Promise(function(resolve, reject) {
            batch.callbacks.push({
              resolve,
              reject
            });
          });
          if (cacheMap) {
            cacheMap.set(cacheKey, promise);
          }
          return promise;
        };
        _proto.loadMany = function loadMany(keys) {
          if (!isArrayLike(keys)) {
            throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys + "."));
          }
          var loadPromises = [];
          for (var i = 0; i < keys.length; i++) {
            loadPromises.push(this.load(keys[i])["catch"](function(error) {
              return error;
            }));
          }
          return Promise.all(loadPromises);
        };
        _proto.clear = function clear(key) {
          var cacheMap = this._cacheMap;
          if (cacheMap) {
            var cacheKey = this._cacheKeyFn(key);
            cacheMap["delete"](cacheKey);
          }
          return this;
        };
        _proto.clearAll = function clearAll() {
          var cacheMap = this._cacheMap;
          if (cacheMap) {
            cacheMap.clear();
          }
          return this;
        };
        _proto.prime = function prime(key, value) {
          var cacheMap = this._cacheMap;
          if (cacheMap) {
            var cacheKey = this._cacheKeyFn(key);
            if (cacheMap.get(cacheKey) === void 0) {
              var promise;
              if (value instanceof Error) {
                promise = Promise.reject(value);
                promise["catch"](function() {
                });
              } else {
                promise = Promise.resolve(value);
              }
              cacheMap.set(cacheKey, promise);
            }
          }
          return this;
        };
        return DataLoader2;
      }();
      var enqueuePostPromiseJob = typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
        if (!resolvedPromise) {
          resolvedPromise = Promise.resolve();
        }
        resolvedPromise.then(function() {
          process.nextTick(fn);
        });
      } : typeof setImmediate === "function" ? function(fn) {
        setImmediate(fn);
      } : function(fn) {
        setTimeout(fn);
      };
      var resolvedPromise;
      function getCurrentBatch(loader) {
        var existingBatch = loader._batch;
        if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize && (!existingBatch.cacheHits || existingBatch.cacheHits.length < loader._maxBatchSize)) {
          return existingBatch;
        }
        var newBatch = {
          hasDispatched: false,
          keys: [],
          callbacks: []
        };
        loader._batch = newBatch;
        loader._batchScheduleFn(function() {
          dispatchBatch(loader, newBatch);
        });
        return newBatch;
      }
      function dispatchBatch(loader, batch) {
        batch.hasDispatched = true;
        if (batch.keys.length === 0) {
          resolveCacheHits(batch);
          return;
        }
        var batchPromise = loader._batchLoadFn(batch.keys);
        if (!batchPromise || typeof batchPromise.then !== "function") {
          return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
        }
        batchPromise.then(function(values) {
          if (!isArrayLike(values)) {
            throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
          }
          if (values.length !== batch.keys.length) {
            throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
          }
          resolveCacheHits(batch);
          for (var i = 0; i < batch.callbacks.length; i++) {
            var value = values[i];
            if (value instanceof Error) {
              batch.callbacks[i].reject(value);
            } else {
              batch.callbacks[i].resolve(value);
            }
          }
        })["catch"](function(error) {
          failedDispatch(loader, batch, error);
        });
      }
      function failedDispatch(loader, batch, error) {
        resolveCacheHits(batch);
        for (var i = 0; i < batch.keys.length; i++) {
          loader.clear(batch.keys[i]);
          batch.callbacks[i].reject(error);
        }
      }
      function resolveCacheHits(batch) {
        if (batch.cacheHits) {
          for (var i = 0; i < batch.cacheHits.length; i++) {
            batch.cacheHits[i]();
          }
        }
      }
      function getValidMaxBatchSize(options) {
        var shouldBatch = !options || options.batch !== false;
        if (!shouldBatch) {
          return 1;
        }
        var maxBatchSize = options && options.maxBatchSize;
        if (maxBatchSize === void 0) {
          return Infinity;
        }
        if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
          throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
        }
        return maxBatchSize;
      }
      function getValidBatchScheduleFn(options) {
        var batchScheduleFn = options && options.batchScheduleFn;
        if (batchScheduleFn === void 0) {
          return enqueuePostPromiseJob;
        }
        if (typeof batchScheduleFn !== "function") {
          throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
        }
        return batchScheduleFn;
      }
      function getValidCacheKeyFn(options) {
        var cacheKeyFn = options && options.cacheKeyFn;
        if (cacheKeyFn === void 0) {
          return function(key) {
            return key;
          };
        }
        if (typeof cacheKeyFn !== "function") {
          throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
        }
        return cacheKeyFn;
      }
      function getValidCacheMap(options) {
        var shouldCache = !options || options.cache !== false;
        if (!shouldCache) {
          return null;
        }
        var cacheMap = options && options.cacheMap;
        if (cacheMap === void 0) {
          return /* @__PURE__ */ new Map();
        }
        if (cacheMap !== null) {
          var cacheFunctions = ["get", "set", "delete", "clear"];
          var missingFunctions = cacheFunctions.filter(function(fnName) {
            return cacheMap && typeof cacheMap[fnName] !== "function";
          });
          if (missingFunctions.length !== 0) {
            throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
          }
        }
        return cacheMap;
      }
      function isArrayLike(x) {
        return typeof x === "object" && x !== null && typeof x.length === "number" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
      }
      module.exports = DataLoader;
    }
  });

  // node_modules/axios/lib/helpers/bind.js
  var require_bind = __commonJS({
    "node_modules/axios/lib/helpers/bind.js"(exports, module) {
      "use strict";
      module.exports = function bind(fn, thisArg) {
        return function wrap() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          return fn.apply(thisArg, args);
        };
      };
    }
  });

  // node_modules/axios/lib/utils.js
  var require_utils2 = __commonJS({
    "node_modules/axios/lib/utils.js"(exports, module) {
      "use strict";
      var bind = require_bind();
      var toString = Object.prototype.toString;
      function isArray(val) {
        return Array.isArray(val);
      }
      function isUndefined(val) {
        return typeof val === "undefined";
      }
      function isBuffer(val) {
        return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
      }
      function isArrayBuffer(val) {
        return toString.call(val) === "[object ArrayBuffer]";
      }
      function isFormData(val) {
        return toString.call(val) === "[object FormData]";
      }
      function isArrayBufferView(val) {
        var result;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && isArrayBuffer(val.buffer);
        }
        return result;
      }
      function isString(val) {
        return typeof val === "string";
      }
      function isNumber(val) {
        return typeof val === "number";
      }
      function isObject(val) {
        return val !== null && typeof val === "object";
      }
      function isPlainObject(val) {
        if (toString.call(val) !== "[object Object]") {
          return false;
        }
        var prototype = Object.getPrototypeOf(val);
        return prototype === null || prototype === Object.prototype;
      }
      function isDate(val) {
        return toString.call(val) === "[object Date]";
      }
      function isFile(val) {
        return toString.call(val) === "[object File]";
      }
      function isBlob(val) {
        return toString.call(val) === "[object Blob]";
      }
      function isFunction(val) {
        return toString.call(val) === "[object Function]";
      }
      function isStream(val) {
        return isObject(val) && isFunction(val.pipe);
      }
      function isURLSearchParams(val) {
        return toString.call(val) === "[object URLSearchParams]";
      }
      function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function isStandardBrowserEnv() {
        if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
          return false;
        }
        return typeof window !== "undefined" && typeof document !== "undefined";
      }
      function forEach(obj, fn) {
        if (obj === null || typeof obj === "undefined") {
          return;
        }
        if (typeof obj !== "object") {
          obj = [obj];
        }
        if (isArray(obj)) {
          for (var i = 0, l = obj.length; i < l; i++) {
            fn.call(null, obj[i], i, obj);
          }
        } else {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              fn.call(null, obj[key], key, obj);
            }
          }
        }
      }
      function merge() {
        var result = {};
        function assignValue(val, key) {
          if (isPlainObject(result[key]) && isPlainObject(val)) {
            result[key] = merge(result[key], val);
          } else if (isPlainObject(val)) {
            result[key] = merge({}, val);
          } else if (isArray(val)) {
            result[key] = val.slice();
          } else {
            result[key] = val;
          }
        }
        for (var i = 0, l = arguments.length; i < l; i++) {
          forEach(arguments[i], assignValue);
        }
        return result;
      }
      function extend(a, b, thisArg) {
        forEach(b, function assignValue(val, key) {
          if (thisArg && typeof val === "function") {
            a[key] = bind(val, thisArg);
          } else {
            a[key] = val;
          }
        });
        return a;
      }
      function stripBOM(content) {
        if (content.charCodeAt(0) === 65279) {
          content = content.slice(1);
        }
        return content;
      }
      module.exports = {
        isArray,
        isArrayBuffer,
        isBuffer,
        isFormData,
        isArrayBufferView,
        isString,
        isNumber,
        isObject,
        isPlainObject,
        isUndefined,
        isDate,
        isFile,
        isBlob,
        isFunction,
        isStream,
        isURLSearchParams,
        isStandardBrowserEnv,
        forEach,
        merge,
        extend,
        trim,
        stripBOM
      };
    }
  });

  // node_modules/axios/lib/helpers/buildURL.js
  var require_buildURL = __commonJS({
    "node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      function encode(val) {
        return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      module.exports = function buildURL(url, params, paramsSerializer) {
        if (!params) {
          return url;
        }
        var serializedParams;
        if (paramsSerializer) {
          serializedParams = paramsSerializer(params);
        } else if (utils.isURLSearchParams(params)) {
          serializedParams = params.toString();
        } else {
          var parts = [];
          utils.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === "undefined") {
              return;
            }
            if (utils.isArray(val)) {
              key = key + "[]";
            } else {
              val = [val];
            }
            utils.forEach(val, function parseValue(v) {
              if (utils.isDate(v)) {
                v = v.toISOString();
              } else if (utils.isObject(v)) {
                v = JSON.stringify(v);
              }
              parts.push(encode(key) + "=" + encode(v));
            });
          });
          serializedParams = parts.join("&");
        }
        if (serializedParams) {
          var hashmarkIndex = url.indexOf("#");
          if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
          }
          url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }
        return url;
      };
    }
  });

  // node_modules/axios/lib/core/InterceptorManager.js
  var require_InterceptorManager = __commonJS({
    "node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      function InterceptorManager() {
        this.handlers = [];
      }
      InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      };
      InterceptorManager.prototype.eject = function eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      };
      InterceptorManager.prototype.forEach = function forEach(fn) {
        utils.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      };
      module.exports = InterceptorManager;
    }
  });

  // node_modules/axios/lib/helpers/normalizeHeaderName.js
  var require_normalizeHeaderName = __commonJS({
    "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      module.exports = function normalizeHeaderName(headers, normalizedName) {
        utils.forEach(headers, function processHeader(value, name) {
          if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
            headers[normalizedName] = value;
            delete headers[name];
          }
        });
      };
    }
  });

  // node_modules/axios/lib/core/enhanceError.js
  var require_enhanceError = __commonJS({
    "node_modules/axios/lib/core/enhanceError.js"(exports, module) {
      "use strict";
      module.exports = function enhanceError(error, config, code, request, response) {
        error.config = config;
        if (code) {
          error.code = code;
        }
        error.request = request;
        error.response = response;
        error.isAxiosError = true;
        error.toJSON = function toJSON() {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: this.config,
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
          };
        };
        return error;
      };
    }
  });

  // node_modules/axios/lib/core/createError.js
  var require_createError = __commonJS({
    "node_modules/axios/lib/core/createError.js"(exports, module) {
      "use strict";
      var enhanceError = require_enhanceError();
      module.exports = function createError(message, config, code, request, response) {
        var error = new Error(message);
        return enhanceError(error, config, code, request, response);
      };
    }
  });

  // node_modules/axios/lib/core/settle.js
  var require_settle = __commonJS({
    "node_modules/axios/lib/core/settle.js"(exports, module) {
      "use strict";
      var createError = require_createError();
      module.exports = function settle(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;
        if (!response.status || !validateStatus || validateStatus(response.status)) {
          resolve(response);
        } else {
          reject(createError(
            "Request failed with status code " + response.status,
            response.config,
            null,
            response.request,
            response
          ));
        }
      };
    }
  });

  // node_modules/axios/lib/helpers/cookies.js
  var require_cookies = __commonJS({
    "node_modules/axios/lib/helpers/cookies.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }() : function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }();
    }
  });

  // node_modules/axios/lib/helpers/isAbsoluteURL.js
  var require_isAbsoluteURL = __commonJS({
    "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
      "use strict";
      module.exports = function isAbsoluteURL(url) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
      };
    }
  });

  // node_modules/axios/lib/helpers/combineURLs.js
  var require_combineURLs = __commonJS({
    "node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
      "use strict";
      module.exports = function combineURLs(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      };
    }
  });

  // node_modules/axios/lib/core/buildFullPath.js
  var require_buildFullPath = __commonJS({
    "node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
      "use strict";
      var isAbsoluteURL = require_isAbsoluteURL();
      var combineURLs = require_combineURLs();
      module.exports = function buildFullPath(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL(requestedURL)) {
          return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
      };
    }
  });

  // node_modules/axios/lib/helpers/parseHeaders.js
  var require_parseHeaders = __commonJS({
    "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      var ignoreDuplicateOf = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ];
      module.exports = function parseHeaders(headers) {
        var parsed = {};
        var key;
        var val;
        var i;
        if (!headers) {
          return parsed;
        }
        utils.forEach(headers.split("\n"), function parser(line) {
          i = line.indexOf(":");
          key = utils.trim(line.substr(0, i)).toLowerCase();
          val = utils.trim(line.substr(i + 1));
          if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
              return;
            }
            if (key === "set-cookie") {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
          }
        });
        return parsed;
      };
    }
  });

  // node_modules/axios/lib/helpers/isURLSameOrigin.js
  var require_isURLSameOrigin = __commonJS({
    "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }() : function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }();
    }
  });

  // node_modules/axios/lib/cancel/Cancel.js
  var require_Cancel = __commonJS({
    "node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
      "use strict";
      function Cancel(message) {
        this.message = message;
      }
      Cancel.prototype.toString = function toString() {
        return "Cancel" + (this.message ? ": " + this.message : "");
      };
      Cancel.prototype.__CANCEL__ = true;
      module.exports = Cancel;
    }
  });

  // node_modules/axios/lib/adapters/xhr.js
  var require_xhr = __commonJS({
    "node_modules/axios/lib/adapters/xhr.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      var settle = require_settle();
      var cookies = require_cookies();
      var buildURL = require_buildURL();
      var buildFullPath = require_buildFullPath();
      var parseHeaders = require_parseHeaders();
      var isURLSameOrigin = require_isURLSameOrigin();
      var createError = require_createError();
      var defaults = require_defaults();
      var Cancel = require_Cancel();
      module.exports = function xhrAdapter(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          var requestData = config.data;
          var requestHeaders = config.headers;
          var responseType = config.responseType;
          var onCanceled;
          function done() {
            if (config.cancelToken) {
              config.cancelToken.unsubscribe(onCanceled);
            }
            if (config.signal) {
              config.signal.removeEventListener("abort", onCanceled);
            }
          }
          if (utils.isFormData(requestData)) {
            delete requestHeaders["Content-Type"];
          }
          var request = new XMLHttpRequest();
          if (config.auth) {
            var username = config.auth.username || "";
            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
          }
          var fullPath = buildFullPath(config.baseURL, config.url);
          request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
          request.timeout = config.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config,
              request
            };
            settle(function _resolve(value) {
              resolve(value);
              done();
            }, function _reject(err) {
              reject(err);
              done();
            }, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(createError("Request aborted", config, "ECONNABORTED", request));
            request = null;
          };
          request.onerror = function handleError() {
            reject(createError("Network Error", config, null, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            var transitional = config.transitional || defaults.transitional;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(createError(
              timeoutErrorMessage,
              config,
              transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
              request
            ));
            request = null;
          };
          if (utils.isStandardBrowserEnv()) {
            var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
            if (xsrfValue) {
              requestHeaders[config.xsrfHeaderName] = xsrfValue;
            }
          }
          if ("setRequestHeader" in request) {
            utils.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                delete requestHeaders[key];
              } else {
                request.setRequestHeader(key, val);
              }
            });
          }
          if (!utils.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = config.responseType;
          }
          if (typeof config.onDownloadProgress === "function") {
            request.addEventListener("progress", config.onDownloadProgress);
          }
          if (typeof config.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", config.onUploadProgress);
          }
          if (config.cancelToken || config.signal) {
            onCanceled = function(cancel) {
              if (!request) {
                return;
              }
              reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
              request.abort();
              request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) {
              config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
            }
          }
          if (!requestData) {
            requestData = null;
          }
          request.send(requestData);
        });
      };
    }
  });

  // node_modules/axios/lib/defaults.js
  var require_defaults = __commonJS({
    "node_modules/axios/lib/defaults.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      var normalizeHeaderName = require_normalizeHeaderName();
      var enhanceError = require_enhanceError();
      var DEFAULT_CONTENT_TYPE = {
        "Content-Type": "application/x-www-form-urlencoded"
      };
      function setContentTypeIfUnset(headers, value) {
        if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
          headers["Content-Type"] = value;
        }
      }
      function getDefaultAdapter() {
        var adapter;
        if (typeof XMLHttpRequest !== "undefined") {
          adapter = require_xhr();
        } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
          adapter = require_xhr();
        }
        return adapter;
      }
      function stringifySafely(rawValue, parser, encoder) {
        if (utils.isString(rawValue)) {
          try {
            (parser || JSON.parse)(rawValue);
            return utils.trim(rawValue);
          } catch (e) {
            if (e.name !== "SyntaxError") {
              throw e;
            }
          }
        }
        return (encoder || JSON.stringify)(rawValue);
      }
      var defaults = {
        transitional: {
          silentJSONParsing: true,
          forcedJSONParsing: true,
          clarifyTimeoutError: false
        },
        adapter: getDefaultAdapter(),
        transformRequest: [function transformRequest(data, headers) {
          normalizeHeaderName(headers, "Accept");
          normalizeHeaderName(headers, "Content-Type");
          if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
            return data;
          }
          if (utils.isArrayBufferView(data)) {
            return data.buffer;
          }
          if (utils.isURLSearchParams(data)) {
            setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
            return data.toString();
          }
          if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
            setContentTypeIfUnset(headers, "application/json");
            return stringifySafely(data);
          }
          return data;
        }],
        transformResponse: [function transformResponse(data) {
          var transitional = this.transitional || defaults.transitional;
          var silentJSONParsing = transitional && transitional.silentJSONParsing;
          var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
          var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
          if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
            try {
              return JSON.parse(data);
            } catch (e) {
              if (strictJSONParsing) {
                if (e.name === "SyntaxError") {
                  throw enhanceError(e, this, "E_JSON_PARSE");
                }
                throw e;
              }
            }
          }
          return data;
        }],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        validateStatus: function validateStatus(status) {
          return status >= 200 && status < 300;
        },
        headers: {
          common: {
            "Accept": "application/json, text/plain, */*"
          }
        }
      };
      utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
        defaults.headers[method] = {};
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
      });
      module.exports = defaults;
    }
  });

  // node_modules/axios/lib/core/transformData.js
  var require_transformData = __commonJS({
    "node_modules/axios/lib/core/transformData.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      var defaults = require_defaults();
      module.exports = function transformData(data, headers, fns) {
        var context = this || defaults;
        utils.forEach(fns, function transform(fn) {
          data = fn.call(context, data, headers);
        });
        return data;
      };
    }
  });

  // node_modules/axios/lib/cancel/isCancel.js
  var require_isCancel = __commonJS({
    "node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
      "use strict";
      module.exports = function isCancel(value) {
        return !!(value && value.__CANCEL__);
      };
    }
  });

  // node_modules/axios/lib/core/dispatchRequest.js
  var require_dispatchRequest = __commonJS({
    "node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      var transformData = require_transformData();
      var isCancel = require_isCancel();
      var defaults = require_defaults();
      var Cancel = require_Cancel();
      function throwIfCancellationRequested(config) {
        if (config.cancelToken) {
          config.cancelToken.throwIfRequested();
        }
        if (config.signal && config.signal.aborted) {
          throw new Cancel("canceled");
        }
      }
      module.exports = function dispatchRequest(config) {
        throwIfCancellationRequested(config);
        config.headers = config.headers || {};
        config.data = transformData.call(
          config,
          config.data,
          config.headers,
          config.transformRequest
        );
        config.headers = utils.merge(
          config.headers.common || {},
          config.headers[config.method] || {},
          config.headers
        );
        utils.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          function cleanHeaderConfig(method) {
            delete config.headers[method];
          }
        );
        var adapter = config.adapter || defaults.adapter;
        return adapter(config).then(function onAdapterResolution(response) {
          throwIfCancellationRequested(config);
          response.data = transformData.call(
            config,
            response.data,
            response.headers,
            config.transformResponse
          );
          return response;
        }, function onAdapterRejection(reason) {
          if (!isCancel(reason)) {
            throwIfCancellationRequested(config);
            if (reason && reason.response) {
              reason.response.data = transformData.call(
                config,
                reason.response.data,
                reason.response.headers,
                config.transformResponse
              );
            }
          }
          return Promise.reject(reason);
        });
      };
    }
  });

  // node_modules/axios/lib/core/mergeConfig.js
  var require_mergeConfig = __commonJS({
    "node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      module.exports = function mergeConfig(config1, config2) {
        config2 = config2 || {};
        var config = {};
        function getMergedValue(target, source) {
          if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
            return utils.merge(target, source);
          } else if (utils.isPlainObject(source)) {
            return utils.merge({}, source);
          } else if (utils.isArray(source)) {
            return source.slice();
          }
          return source;
        }
        function mergeDeepProperties(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(config1[prop], config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        function valueFromConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(void 0, config2[prop]);
          }
        }
        function defaultToConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(void 0, config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        function mergeDirectKeys(prop) {
          if (prop in config2) {
            return getMergedValue(config1[prop], config2[prop]);
          } else if (prop in config1) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        var mergeMap = {
          "url": valueFromConfig2,
          "method": valueFromConfig2,
          "data": valueFromConfig2,
          "baseURL": defaultToConfig2,
          "transformRequest": defaultToConfig2,
          "transformResponse": defaultToConfig2,
          "paramsSerializer": defaultToConfig2,
          "timeout": defaultToConfig2,
          "timeoutMessage": defaultToConfig2,
          "withCredentials": defaultToConfig2,
          "adapter": defaultToConfig2,
          "responseType": defaultToConfig2,
          "xsrfCookieName": defaultToConfig2,
          "xsrfHeaderName": defaultToConfig2,
          "onUploadProgress": defaultToConfig2,
          "onDownloadProgress": defaultToConfig2,
          "decompress": defaultToConfig2,
          "maxContentLength": defaultToConfig2,
          "maxBodyLength": defaultToConfig2,
          "transport": defaultToConfig2,
          "httpAgent": defaultToConfig2,
          "httpsAgent": defaultToConfig2,
          "cancelToken": defaultToConfig2,
          "socketPath": defaultToConfig2,
          "responseEncoding": defaultToConfig2,
          "validateStatus": mergeDirectKeys
        };
        utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
          var merge = mergeMap[prop] || mergeDeepProperties;
          var configValue = merge(prop);
          utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
        });
        return config;
      };
    }
  });

  // node_modules/axios/lib/env/data.js
  var require_data = __commonJS({
    "node_modules/axios/lib/env/data.js"(exports, module) {
      module.exports = {
        "version": "0.25.0"
      };
    }
  });

  // node_modules/axios/lib/helpers/validator.js
  var require_validator = __commonJS({
    "node_modules/axios/lib/helpers/validator.js"(exports, module) {
      "use strict";
      var VERSION = require_data().version;
      var validators = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
        validators[type] = function validator(thing) {
          return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
        };
      });
      var deprecatedWarnings = {};
      validators.transitional = function transitional(validator, version, message) {
        function formatMessage(opt, desc) {
          return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
        }
        return function(value, opt, opts) {
          if (validator === false) {
            throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
          }
          if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            console.warn(
              formatMessage(
                opt,
                " has been deprecated since v" + version + " and will be removed in the near future"
              )
            );
          }
          return validator ? validator(value, opt, opts) : true;
        };
      };
      function assertOptions(options, schema, allowUnknown) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        var keys = Object.keys(options);
        var i = keys.length;
        while (i-- > 0) {
          var opt = keys[i];
          var validator = schema[opt];
          if (validator) {
            var value = options[opt];
            var result = value === void 0 || validator(value, opt, options);
            if (result !== true) {
              throw new TypeError("option " + opt + " must be " + result);
            }
            continue;
          }
          if (allowUnknown !== true) {
            throw Error("Unknown option " + opt);
          }
        }
      }
      module.exports = {
        assertOptions,
        validators
      };
    }
  });

  // node_modules/axios/lib/core/Axios.js
  var require_Axios = __commonJS({
    "node_modules/axios/lib/core/Axios.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      var buildURL = require_buildURL();
      var InterceptorManager = require_InterceptorManager();
      var dispatchRequest = require_dispatchRequest();
      var mergeConfig = require_mergeConfig();
      var validator = require_validator();
      var validators = validator.validators;
      function Axios(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }
      Axios.prototype.request = function request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        if (!config.url) {
          throw new Error("Provided config url is not valid");
        }
        config = mergeConfig(this.defaults, config);
        if (config.method) {
          config.method = config.method.toLowerCase();
        } else if (this.defaults.method) {
          config.method = this.defaults.method.toLowerCase();
        } else {
          config.method = "get";
        }
        var transitional = config.transitional;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        var requestInterceptorChain = [];
        var synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        var responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        var promise;
        if (!synchronousRequestInterceptors) {
          var chain = [dispatchRequest, void 0];
          Array.prototype.unshift.apply(chain, requestInterceptorChain);
          chain = chain.concat(responseInterceptorChain);
          promise = Promise.resolve(config);
          while (chain.length) {
            promise = promise.then(chain.shift(), chain.shift());
          }
          return promise;
        }
        var newConfig = config;
        while (requestInterceptorChain.length) {
          var onFulfilled = requestInterceptorChain.shift();
          var onRejected = requestInterceptorChain.shift();
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected(error);
            break;
          }
        }
        try {
          promise = dispatchRequest(newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        while (responseInterceptorChain.length) {
          promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
        }
        return promise;
      };
      Axios.prototype.getUri = function getUri(config) {
        if (!config.url) {
          throw new Error("Provided config url is not valid");
        }
        config = mergeConfig(this.defaults, config);
        return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
      };
      utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
        Axios.prototype[method] = function(url, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            url,
            data: (config || {}).data
          }));
        };
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        Axios.prototype[method] = function(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            url,
            data
          }));
        };
      });
      module.exports = Axios;
    }
  });

  // node_modules/axios/lib/cancel/CancelToken.js
  var require_CancelToken = __commonJS({
    "node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
      "use strict";
      var Cancel = require_Cancel();
      function CancelToken(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        var token = this;
        this.promise.then(function(cancel) {
          if (!token._listeners)
            return;
          var i;
          var l = token._listeners.length;
          for (i = 0; i < l; i++) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = function(onfulfilled) {
          var _resolve;
          var promise = new Promise(function(resolve) {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message) {
          if (token.reason) {
            return;
          }
          token.reason = new Cancel(message);
          resolvePromise(token.reason);
        });
      }
      CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };
      CancelToken.prototype.subscribe = function subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      };
      CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        var index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      };
      CancelToken.source = function source() {
        var cancel;
        var token = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      };
      module.exports = CancelToken;
    }
  });

  // node_modules/axios/lib/helpers/spread.js
  var require_spread = __commonJS({
    "node_modules/axios/lib/helpers/spread.js"(exports, module) {
      "use strict";
      module.exports = function spread(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      };
    }
  });

  // node_modules/axios/lib/helpers/isAxiosError.js
  var require_isAxiosError = __commonJS({
    "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      module.exports = function isAxiosError(payload) {
        return utils.isObject(payload) && payload.isAxiosError === true;
      };
    }
  });

  // node_modules/axios/lib/axios.js
  var require_axios = __commonJS({
    "node_modules/axios/lib/axios.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      var bind = require_bind();
      var Axios = require_Axios();
      var mergeConfig = require_mergeConfig();
      var defaults = require_defaults();
      function createInstance(defaultConfig) {
        var context = new Axios(defaultConfig);
        var instance = bind(Axios.prototype.request, context);
        utils.extend(instance, Axios.prototype, context);
        utils.extend(instance, context);
        instance.create = function create(instanceConfig) {
          return createInstance(mergeConfig(defaultConfig, instanceConfig));
        };
        return instance;
      }
      var axios = createInstance(defaults);
      axios.Axios = Axios;
      axios.Cancel = require_Cancel();
      axios.CancelToken = require_CancelToken();
      axios.isCancel = require_isCancel();
      axios.VERSION = require_data().version;
      axios.all = function all(promises) {
        return Promise.all(promises);
      };
      axios.spread = require_spread();
      axios.isAxiosError = require_isAxiosError();
      module.exports = axios;
      module.exports.default = axios;
    }
  });

  // node_modules/axios/index.js
  var require_axios2 = __commonJS({
    "node_modules/axios/index.js"(exports, module) {
      module.exports = require_axios();
    }
  });

  // node_modules/ton/package.json
  var require_package = __commonJS({
    "node_modules/ton/package.json"(exports, module) {
      module.exports = {
        name: "ton",
        version: "12.1.5",
        repository: "https://github.com/tonwhales/ton.git",
        author: "Steve Korshakov <steve@korshakov.com>",
        license: "MIT",
        main: "dist/index.js",
        files: [
          "dist"
        ],
        scripts: {
          build: "rm -fr dist && tsc --declaration",
          test: "jest --verbose --runInBand",
          release: "yarn build && yarn test && yarn publish"
        },
        devDependencies: {
          "@types/bn.js": "^5.1.0",
          "@types/jest": "^27.0.1",
          "@types/node": "^16.7.10",
          buffer: "^6.0.3",
          expect: "^27.1.0",
          jest: "^27.1.0",
          "jest-mock": "^27.1.0",
          karma: "^6.3.4",
          "karma-chrome-launcher": "^3.1.0",
          "karma-jasmine": "^4.0.1",
          "karma-typescript": "^5.5.2",
          "karma-webpack": "^5.0.0",
          tonweb: "0.0.18",
          "ts-jest": "^27.0.5",
          "ts-loader": "^9.2.5",
          "ts-node": "^10.7.0",
          typescript: "^4.4.2",
          webpack: "^5.51.2"
        },
        dependencies: {
          axios: "^0.25.0",
          "bn.js": "5.2.0",
          dataloader: "^2.0.0",
          "ethjs-unit": "0.1.6",
          "fp-ts": "^2.11.1",
          "io-ts": "^2.2.16",
          "io-ts-reporters": "^2.0.0",
          "symbol.inspect": "1.0.1",
          teslabot: "^1.3.0",
          "ton-crypto": "2.1.0",
          tweetnacl: "1.0.3"
        }
      };
    }
  });

  // node_modules/ton/dist/client/api/HttpApi.js
  var require_HttpApi = __commonJS({
    "node_modules/ton/dist/client/api/HttpApi.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HttpApi = void 0;
      var t = __importStar(require_lib());
      var Either_1 = require_Either();
      var io_ts_reporters_1 = __importDefault(require_src());
      var dataloader_1 = __importDefault(require_dataloader());
      var axios_1 = __importDefault(require_axios2());
      var version = require_package().version;
      var blockIdExt = t.type({
        "@type": t.literal("ton.blockIdExt"),
        workchain: t.number,
        shard: t.string,
        seqno: t.number,
        root_hash: t.string,
        file_hash: t.string
      });
      var addressInformation = t.type({
        balance: t.union([t.number, t.string]),
        state: t.union([t.literal("active"), t.literal("uninitialized"), t.literal("frozen")]),
        data: t.string,
        code: t.string,
        last_transaction_id: t.type({
          "@type": t.literal("internal.transactionId"),
          lt: t.string,
          hash: t.string
        }),
        block_id: blockIdExt,
        sync_utime: t.number
      });
      var bocResponse = t.type({
        "@type": t.literal("ok")
      });
      var feeResponse = t.type({
        "@type": t.literal("query.fees"),
        source_fees: t.type({
          "@type": t.literal("fees"),
          in_fwd_fee: t.number,
          storage_fee: t.number,
          gas_fee: t.number,
          fwd_fee: t.number
        })
      });
      var callGetMethod = t.type({
        gas_used: t.number,
        exit_code: t.number,
        stack: t.array(t.unknown)
      });
      var messageData = t.union([
        t.type({
          "@type": t.literal("msg.dataRaw"),
          "body": t.string
        }),
        t.type({
          "@type": t.literal("msg.dataText"),
          "text": t.string
        }),
        t.type({
          "@type": t.literal("msg.dataDecryptedText"),
          "text": t.string
        }),
        t.type({
          "@type": t.literal("msg.dataEncryptedText"),
          "text": t.string
        })
      ]);
      var message = t.type({
        source: t.string,
        destination: t.string,
        value: t.string,
        fwd_fee: t.string,
        ihr_fee: t.string,
        created_lt: t.string,
        body_hash: t.string,
        msg_data: messageData
      });
      var transaction = t.type({
        data: t.string,
        utime: t.number,
        transaction_id: t.type({
          lt: t.string,
          hash: t.string
        }),
        fee: t.string,
        storage_fee: t.string,
        other_fee: t.string,
        in_msg: t.union([t.undefined, message]),
        out_msgs: t.array(message)
      });
      var getTransactions = t.array(transaction);
      var getMasterchain = t.type({
        state_root_hash: t.string,
        last: blockIdExt,
        init: blockIdExt
      });
      var getShards = t.type({
        shards: t.array(blockIdExt)
      });
      var blockShortTxt = t.type({
        "@type": t.literal("blocks.shortTxId"),
        mode: t.number,
        account: t.string,
        lt: t.string,
        hash: t.string
      });
      var getBlockTransactions = t.type({
        id: blockIdExt,
        req_count: t.number,
        incomplete: t.boolean,
        transactions: t.array(blockShortTxt)
      });
      var TypedCache = class {
        constructor(namespace, cache, codec, keyEncoder) {
          this.namespace = namespace;
          this.cache = cache;
          this.codec = codec;
          this.keyEncoder = keyEncoder;
        }
        get(key) {
          return __async(this, null, function* () {
            let ex = yield this.cache.get(this.namespace, this.keyEncoder(key));
            if (ex) {
              let decoded = this.codec.decode(JSON.parse(ex));
              if ((0, Either_1.isRight)(decoded)) {
                return decoded.right;
              }
            }
            return null;
          });
        }
        set(key, value) {
          return __async(this, null, function* () {
            if (value !== null) {
              yield this.cache.set(this.namespace, this.keyEncoder(key), JSON.stringify(value));
            } else {
              yield this.cache.set(this.namespace, this.keyEncoder(key), null);
            }
          });
        }
      };
      var HttpApi = class {
        constructor(endpoint, cache, parameters) {
          this.endpoint = endpoint;
          this.cache = cache;
          this.parameters = {
            timeout: (parameters === null || parameters === void 0 ? void 0 : parameters.timeout) || 3e4,
            apiKey: parameters === null || parameters === void 0 ? void 0 : parameters.apiKey
          };
          this.shardCache = new TypedCache("ton-shard", cache, t.array(blockIdExt), (src) => src + "");
          this.shardLoader = new dataloader_1.default((src) => __async(this, null, function* () {
            return yield Promise.all(src.map((v) => __async(this, null, function* () {
              const cached = yield this.shardCache.get(v);
              if (cached) {
                return cached;
              }
              let loaded = (yield this.doCall("shards", { seqno: v }, getShards)).shards;
              yield this.shardCache.set(v, loaded);
              return loaded;
            })));
          }));
          this.shardTransactionsCache = new TypedCache("ton-shard-tx", cache, getBlockTransactions, (src) => src.workchain + ":" + src.shard + ":" + src.seqno);
          this.shardTransactionsLoader = new dataloader_1.default((src) => __async(this, null, function* () {
            return yield Promise.all(src.map((v) => __async(this, null, function* () {
              const cached = yield this.shardTransactionsCache.get(v);
              if (cached) {
                return cached;
              }
              let loaded = yield this.doCall("getBlockTransactions", { workchain: v.workchain, seqno: v.seqno, shard: v.shard }, getBlockTransactions);
              yield this.shardTransactionsCache.set(v, loaded);
              return loaded;
            })));
          }), { cacheKeyFn: (src) => src.workchain + ":" + src.shard + ":" + src.seqno });
        }
        getAddressInformation(address) {
          return this.doCall("getAddressInformation", { address: address.toString() }, addressInformation);
        }
        getTransactions(address, opts) {
          return __async(this, null, function* () {
            const inclusive = opts.inclusive;
            delete opts.inclusive;
            let hash = void 0;
            if (opts.hash) {
              hash = Buffer.from(opts.hash, "base64").toString("hex");
            }
            let limit = opts.limit;
            if (opts.hash && opts.lt && inclusive !== true) {
              limit++;
            }
            let res = yield this.doCall("getTransactions", __spreadProps(__spreadValues({ address: address.toString() }, opts), { limit, hash }), getTransactions);
            if (res.length > limit) {
              res = res.slice(0, limit);
            }
            if (opts.hash && opts.lt && inclusive !== true) {
              res.shift();
              return res;
            } else {
              return res;
            }
          });
        }
        getMasterchainInfo() {
          return __async(this, null, function* () {
            return yield this.doCall("getMasterchainInfo", {}, getMasterchain);
          });
        }
        getShards(seqno) {
          return __async(this, null, function* () {
            return yield this.shardLoader.load(seqno);
          });
        }
        getBlockTransactions(workchain, seqno, shard) {
          return __async(this, null, function* () {
            return yield this.shardTransactionsLoader.load({ workchain, seqno, shard });
          });
        }
        getTransaction(address, lt, hash) {
          return __async(this, null, function* () {
            let convHash = Buffer.from(hash, "base64").toString("hex");
            let res = yield this.doCall("getTransactions", { address: address.toString(), lt, hash: convHash, limit: 1 }, getTransactions);
            let ex = res.find((v) => v.transaction_id.lt === lt && v.transaction_id.hash === hash);
            if (ex) {
              return ex;
            } else {
              return null;
            }
          });
        }
        callGetMethod(address, method, params) {
          return __async(this, null, function* () {
            return yield this.doCall("runGetMethod", { address: address.toString(), method, stack: params }, callGetMethod);
          });
        }
        sendBoc(body) {
          return __async(this, null, function* () {
            yield this.doCall("sendBoc", { boc: body.toString("base64") }, bocResponse);
          });
        }
        estimateFee(address, args) {
          return __async(this, null, function* () {
            return yield this.doCall("estimateFee", {
              address: address.toFriendly(),
              body: (yield args.body.toBoc({ idx: false })).toString("base64"),
              "init_data": args.initData ? (yield args.initData.toBoc({ idx: false })).toString("base64") : "",
              "init_code": args.initCode ? (yield args.initCode.toBoc({ idx: false })).toString("base64") : "",
              ignore_chksig: args.ignoreSignature
            }, feeResponse);
          });
        }
        doCall(method, body, codec) {
          return __async(this, null, function* () {
            let headers = {
              "Content-Type": "application/json",
              "X-Ton-Client-Version": version
            };
            if (this.parameters.apiKey) {
              headers["X-API-Key"] = this.parameters.apiKey;
            }
            let res = yield axios_1.default.post(this.endpoint, JSON.stringify({
              id: "1",
              jsonrpc: "2.0",
              method,
              params: body
            }), {
              headers,
              timeout: this.parameters.timeout
            });
            if (res.status !== 200 || !res.data.ok) {
              throw Error("Received error: " + JSON.stringify(res.data));
            }
            let decoded = codec.decode(res.data.result);
            if ((0, Either_1.isRight)(decoded)) {
              return decoded.right;
            } else {
              throw Error("Malformed response: " + io_ts_reporters_1.default.report(decoded).join(", "));
            }
          });
        }
      };
      exports.HttpApi = HttpApi;
    }
  });

  // node_modules/ton/dist/messages/ExternalMessage.js
  var require_ExternalMessage = __commonJS({
    "node_modules/ton/dist/messages/ExternalMessage.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExternalMessage = void 0;
      var ExternalMessage = class {
        constructor(opts) {
          this.to = opts.to;
          this.body = opts.body;
          if (opts.from !== void 0 && opts.from !== null) {
            this.from = opts.from;
          } else {
            this.from = null;
          }
          if (opts.importFee !== void 0 && opts.importFee !== null) {
            this.importFee = opts.importFee;
          } else {
            this.importFee = 0;
          }
        }
        writeTo(cell) {
          cell.bits.writeUint(2, 2);
          cell.bits.writeAddress(this.from);
          cell.bits.writeAddress(this.to);
          cell.bits.writeCoins(this.importFee);
          this.body.writeTo(cell);
        }
      };
      exports.ExternalMessage = ExternalMessage;
    }
  });

  // node_modules/ton/dist/messages/CommonMessageInfo.js
  var require_CommonMessageInfo = __commonJS({
    "node_modules/ton/dist/messages/CommonMessageInfo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommonMessageInfo = void 0;
      var Cell_1 = require_Cell();
      var CommonMessageInfo = class {
        constructor(opts) {
          if (opts && opts.stateInit !== null && opts.stateInit !== void 0) {
            this.stateInit = opts.stateInit;
          } else {
            this.stateInit = null;
          }
          if (opts && opts.body !== null && opts.body !== void 0) {
            this.body = opts.body;
          } else {
            this.body = null;
          }
        }
        writeTo(cell) {
          if (this.stateInit) {
            cell.bits.writeBit(1);
            const stateInitCell = new Cell_1.Cell();
            this.stateInit.writeTo(stateInitCell);
            if (cell.bits.available - 1 >= stateInitCell.bits.cursor) {
              cell.bits.writeBit(0);
              cell.writeCell(stateInitCell);
            } else {
              cell.bits.writeBit(1);
              cell.refs.push(stateInitCell);
            }
          } else {
            cell.bits.writeBit(0);
          }
          if (this.body) {
            const bodyCell = new Cell_1.Cell();
            this.body.writeTo(bodyCell);
            if (cell.bits.available >= bodyCell.bits.cursor) {
              cell.bits.writeBit(0);
              cell.writeCell(bodyCell);
            } else {
              cell.bits.writeBit(1);
              cell.refs.push(bodyCell);
            }
          } else {
            cell.bits.writeBit(0);
          }
        }
      };
      exports.CommonMessageInfo = CommonMessageInfo;
    }
  });

  // node_modules/ton/dist/messages/StateInit.js
  var require_StateInit = __commonJS({
    "node_modules/ton/dist/messages/StateInit.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StateInit = void 0;
      var StateInit = class {
        constructor(opts) {
          if (opts.code !== null && opts.code !== void 0) {
            this.code = opts.code;
          } else {
            this.code = null;
          }
          if (opts.data !== null && opts.data !== void 0) {
            this.data = opts.data;
          } else {
            this.data = null;
          }
        }
        writeTo(cell) {
          cell.bits.writeBit(0);
          cell.bits.writeBit(0);
          cell.bits.writeBit(!!this.code);
          cell.bits.writeBit(!!this.data);
          cell.bits.writeBit(0);
          if (this.code) {
            cell.refs.push(this.code);
          }
          if (this.data) {
            cell.refs.push(this.data);
          }
        }
      };
      exports.StateInit = StateInit;
    }
  });

  // node_modules/ton/dist/contracts/sources/WalletV1R2Source.js
  var require_WalletV1R2Source = __commonJS({
    "node_modules/ton/dist/contracts/sources/WalletV1R2Source.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletV1R2Source = void 0;
      var __1 = require_dist2();
      var WalletV1R2Source = class {
        constructor(opts) {
          this.type = "org.ton.wallets.simple.r2";
          this.walletVersion = "v1";
          this.backup = () => {
            const store = new __1.ConfigStore();
            store.setInt("wc", this.workchain);
            store.setBuffer("pk", this.publicKey);
            return store.save();
          };
          this.describe = () => {
            return "Simple Wallet Contract (R2)";
          };
          this.publicKey = opts.publicKey;
          this.initialCode = opts.initialCode;
          this.initialData = opts.initialData;
          this.workchain = opts.workchain;
          Object.freeze(this);
        }
        static create(opts) {
          let publicKey = opts.publicKey;
          let workchain = opts.workchain;
          let initialCode = __1.Cell.fromBoc("B5EE9C724101010100530000A2FF0020DD2082014C97BA9730ED44D0D70B1FE0A4F260810200D71820D70B1FED44D0D31FD3FFD15112BAF2A122F901541044F910F2A2F80001D31F3120D74A96D307D402FB00DED1A4C8CB1FCBFFC9ED54D0E2786F")[0];
          let initialData = new __1.Cell();
          initialData.bits.writeUint(0, 32);
          initialData.bits.writeBuffer(publicKey);
          return new WalletV1R2Source({ publicKey, initialCode, initialData, workchain });
        }
        static restore(backup) {
          const store = new __1.ConfigStore(backup);
          return WalletV1R2Source.create({ publicKey: store.getBuffer("pk"), workchain: store.getInt("wc") });
        }
      };
      exports.WalletV1R2Source = WalletV1R2Source;
    }
  });

  // node_modules/ton/dist/contracts/sources/WalletV1R3Source.js
  var require_WalletV1R3Source = __commonJS({
    "node_modules/ton/dist/contracts/sources/WalletV1R3Source.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletV1R3Source = void 0;
      var __1 = require_dist2();
      var WalletV1R3Source = class {
        constructor(opts) {
          this.type = "org.ton.wallets.simple.r3";
          this.walletVersion = "v1";
          this.backup = () => {
            const store = new __1.ConfigStore();
            store.setInt("wc", this.workchain);
            store.setBuffer("pk", this.publicKey);
            return store.save();
          };
          this.describe = () => {
            return "Simple Wallet Contract (R3)";
          };
          this.publicKey = opts.publicKey;
          this.initialCode = opts.initialCode;
          this.initialData = opts.initialData;
          this.workchain = opts.workchain;
          Object.freeze(this);
        }
        static create(opts) {
          let publicKey = opts.publicKey;
          let workchain = opts.workchain;
          let initialCode = __1.Cell.fromBoc("B5EE9C7241010101005F0000BAFF0020DD2082014C97BA218201339CBAB19C71B0ED44D0D31FD70BFFE304E0A4F260810200D71820D70B1FED44D0D31FD3FFD15112BAF2A122F901541044F910F2A2F80001D31F3120D74A96D307D402FB00DED1A4C8CB1FCBFFC9ED54B5B86E42")[0];
          let initialData = new __1.Cell();
          initialData.bits.writeUint(0, 32);
          initialData.bits.writeBuffer(publicKey);
          return new WalletV1R3Source({ publicKey, initialCode, initialData, workchain });
        }
        static restore(backup) {
          const store = new __1.ConfigStore(backup);
          return WalletV1R3Source.create({ publicKey: store.getBuffer("pk"), workchain: store.getInt("wc") });
        }
      };
      exports.WalletV1R3Source = WalletV1R3Source;
    }
  });

  // node_modules/ton/dist/contracts/sources/WalletV2R1Source.js
  var require_WalletV2R1Source = __commonJS({
    "node_modules/ton/dist/contracts/sources/WalletV2R1Source.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletV2R1Source = void 0;
      var __1 = require_dist2();
      var WalletV2R1Source = class {
        constructor(opts) {
          this.type = "org.ton.wallets.v2";
          this.walletVersion = "v2";
          this.backup = () => {
            const store = new __1.ConfigStore();
            store.setInt("wc", this.workchain);
            store.setBuffer("pk", this.publicKey);
            return store.save();
          };
          this.describe = () => {
            return "Wallet V2 Contract";
          };
          this.publicKey = opts.publicKey;
          this.initialCode = opts.initialCode;
          this.initialData = opts.initialData;
          this.workchain = opts.workchain;
          Object.freeze(this);
        }
        static create(opts) {
          let publicKey = opts.publicKey;
          let workchain = opts.workchain;
          let initialCode = __1.Cell.fromBoc("B5EE9C724101010100570000AAFF0020DD2082014C97BA9730ED44D0D70B1FE0A4F2608308D71820D31FD31F01F823BBF263ED44D0D31FD3FFD15131BAF2A103F901541042F910F2A2F800029320D74A96D307D402FB00E8D1A4C8CB1FCBFFC9ED54A1370BB6")[0];
          let initialData = new __1.Cell();
          initialData.bits.writeUint(0, 32);
          initialData.bits.writeBuffer(publicKey);
          return new WalletV2R1Source({ publicKey, initialCode, initialData, workchain });
        }
        static restore(backup) {
          const store = new __1.ConfigStore(backup);
          return WalletV2R1Source.create({ publicKey: store.getBuffer("pk"), workchain: store.getInt("wc") });
        }
      };
      exports.WalletV2R1Source = WalletV2R1Source;
    }
  });

  // node_modules/ton/dist/contracts/sources/WalletV2R2Source.js
  var require_WalletV2R2Source = __commonJS({
    "node_modules/ton/dist/contracts/sources/WalletV2R2Source.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletV2R2Source = void 0;
      var __1 = require_dist2();
      var WalletV2R2Source = class {
        constructor(opts) {
          this.type = "org.ton.wallets.v2.r2";
          this.walletVersion = "v2";
          this.backup = () => {
            const store = new __1.ConfigStore();
            store.setInt("wc", this.workchain);
            store.setBuffer("pk", this.publicKey);
            return store.save();
          };
          this.describe = () => {
            return "Wallet V2 Contract (R2)";
          };
          this.publicKey = opts.publicKey;
          this.workchain = opts.workchain;
          this.initialCode = opts.initialCode;
          this.initialData = opts.initialData;
          Object.freeze(this);
        }
        static create(opts) {
          let publicKey = opts.publicKey;
          let workchain = opts.workchain;
          let initialCode = __1.Cell.fromBoc("B5EE9C724101010100630000C2FF0020DD2082014C97BA218201339CBAB19C71B0ED44D0D31FD70BFFE304E0A4F2608308D71820D31FD31F01F823BBF263ED44D0D31FD3FFD15131BAF2A103F901541042F910F2A2F800029320D74A96D307D402FB00E8D1A4C8CB1FCBFFC9ED54044CD7A1")[0];
          let initialData = new __1.Cell();
          initialData.bits.writeUint(0, 32);
          initialData.bits.writeBuffer(publicKey);
          return new WalletV2R2Source({ publicKey, initialCode, initialData, workchain });
        }
        static restore(backup) {
          const store = new __1.ConfigStore(backup);
          return WalletV2R2Source.create({ publicKey: store.getBuffer("pk"), workchain: store.getInt("wc") });
        }
      };
      exports.WalletV2R2Source = WalletV2R2Source;
    }
  });

  // node_modules/ton/dist/contracts/sources/WalletV3R1Source.js
  var require_WalletV3R1Source = __commonJS({
    "node_modules/ton/dist/contracts/sources/WalletV3R1Source.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletV3R1Source = void 0;
      var __1 = require_dist2();
      var WalletV3R1Source = class {
        constructor(opts) {
          this.type = "org.ton.wallets.v3";
          this.walletVersion = "v3";
          this.backup = () => {
            const store = new __1.ConfigStore();
            store.setInt("wc", this.workchain);
            store.setInt("walletId", this.walletId);
            store.setBuffer("pk", this.publicKey);
            return store.save();
          };
          this.describe = () => {
            return `Wallet V3 Contract. WalletID = ${this.walletId}`;
          };
          this.publicKey = opts.publicKey;
          this.workchain = opts.workchain;
          this.walletId = opts.walletId;
          this.initialCode = opts.initialCode;
          this.initialData = opts.initialData;
          Object.freeze(this);
        }
        static create(opts) {
          let publicKey = opts.publicKey;
          let workchain = opts.workchain;
          let walletId;
          if (opts.walletId !== null && opts.walletId !== void 0) {
            walletId = opts.walletId;
          } else {
            walletId = 698983191 + workchain;
          }
          let initialCode = __1.Cell.fromBoc("B5EE9C724101010100620000C0FF0020DD2082014C97BA9730ED44D0D70B1FE0A4F2608308D71820D31FD31FD31FF82313BBF263ED44D0D31FD31FD3FFD15132BAF2A15144BAF2A204F901541055F910F2A3F8009320D74A96D307D402FB00E8D101A4C8CB1FCB1FCBFFC9ED543FBE6EE0")[0];
          let initialData = new __1.Cell();
          initialData.bits.writeUint(0, 32);
          initialData.bits.writeUint(walletId, 32);
          initialData.bits.writeBuffer(publicKey);
          return new WalletV3R1Source({
            publicKey,
            workchain,
            walletId,
            initialCode,
            initialData
          });
        }
        static restore(backup) {
          const store = new __1.ConfigStore(backup);
          return WalletV3R1Source.create({ publicKey: store.getBuffer("pk"), workchain: store.getInt("wc"), walletId: store.getInt("walletId") });
        }
      };
      exports.WalletV3R1Source = WalletV3R1Source;
    }
  });

  // node_modules/ton/dist/contracts/sources/WalletV3R2Source.js
  var require_WalletV3R2Source = __commonJS({
    "node_modules/ton/dist/contracts/sources/WalletV3R2Source.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletV3R2Source = void 0;
      var __1 = require_dist2();
      var WalletV3R2Source = class {
        constructor(opts) {
          this.type = "org.ton.wallets.v3.r2";
          this.walletVersion = "v3";
          this.backup = () => {
            const store = new __1.ConfigStore();
            store.setInt("wc", this.workchain);
            store.setInt("walletId", this.walletId);
            store.setBuffer("pk", this.publicKey);
            return store.save();
          };
          this.describe = () => {
            return `Wallet V3 Contract (R2). WalletID = ${this.walletId}`;
          };
          this.publicKey = opts.publicKey;
          this.workchain = opts.workchain;
          this.walletId = opts.walletId;
          this.initialCode = opts.initialCode;
          this.initialData = opts.initialData;
          Object.freeze(this);
        }
        static create(opts) {
          let publicKey = opts.publicKey;
          let workchain = opts.workchain;
          let walletId;
          if (opts.walletId !== null && opts.walletId !== void 0) {
            walletId = opts.walletId;
          } else {
            walletId = 698983191 + workchain;
          }
          let initialCode = __1.Cell.fromBoc("B5EE9C724101010100710000DEFF0020DD2082014C97BA218201339CBAB19F71B0ED44D0D31FD31F31D70BFFE304E0A4F2608308D71820D31FD31FD31FF82313BBF263ED44D0D31FD31FD3FFD15132BAF2A15144BAF2A204F901541055F910F2A3F8009320D74A96D307D402FB00E8D101A4C8CB1FCB1FCBFFC9ED5410BD6DAD")[0];
          let initialData = new __1.Cell();
          initialData.bits.writeUint(0, 32);
          initialData.bits.writeUint(walletId, 32);
          initialData.bits.writeBuffer(publicKey);
          return new WalletV3R2Source({
            publicKey,
            workchain,
            walletId,
            initialCode,
            initialData
          });
        }
        static restore(backup) {
          const store = new __1.ConfigStore(backup);
          return WalletV3R2Source.create({ publicKey: store.getBuffer("pk"), workchain: store.getInt("wc"), walletId: store.getInt("walletId") });
        }
      };
      exports.WalletV3R2Source = WalletV3R2Source;
    }
  });

  // node_modules/ton/dist/contracts/sources/WalletV4Source.js
  var require_WalletV4Source = __commonJS({
    "node_modules/ton/dist/contracts/sources/WalletV4Source.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletV4Source = void 0;
      var __1 = require_dist2();
      var WalletV4Source = class {
        constructor(args) {
          this.type = "org.ton.wallets.v4";
          this.walletVersion = "v4";
          this.initialCode = args.initialCode;
          this.initialData = args.initialData;
          this.workchain = args.workchain;
          this.walletId = args.walletId;
          this.publicKey = args.publicKey;
        }
        static create(opts) {
          const walletId = opts.walletId ? opts.walletId : 698983191;
          let initialCode = __1.Cell.fromBoc(WalletV4Source.SOURCE)[0];
          let initialData = new __1.Cell();
          initialData.bits.writeUint(0, 32);
          initialData.bits.writeUint(walletId, 32);
          initialData.bits.writeBuffer(opts.publicKey);
          initialData.bits.writeBit(0);
          return new WalletV4Source({ initialCode, initialData, workchain: opts.workchain, walletId, publicKey: opts.publicKey });
        }
        static restore(backup) {
          const store = new __1.ConfigStore(backup);
          return WalletV4Source.create({
            workchain: store.getInt("wc"),
            publicKey: store.getBuffer("pk"),
            walletId: store.getInt("walletId")
          });
        }
        describe() {
          return "Wallet v4 #" + this.walletId;
        }
        backup() {
          const config = new __1.ConfigStore();
          config.setInt("wc", this.workchain);
          config.setBuffer("pk", this.publicKey);
          config.setInt("walletId", this.walletId);
          return config.save();
        }
      };
      exports.WalletV4Source = WalletV4Source;
      WalletV4Source.SOURCE = Buffer.from("te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA==", "base64");
    }
  });

  // node_modules/ton/dist/contracts/messages/WalletV1SigningMessage.js
  var require_WalletV1SigningMessage = __commonJS({
    "node_modules/ton/dist/contracts/messages/WalletV1SigningMessage.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletV1SigningMessage = void 0;
      var Cell_1 = require_Cell();
      var WalletV1SigningMessage = class {
        constructor(args) {
          this.order = args.order;
          this.sendMode = args.sendMode;
          if (args.seqno !== void 0 && args.seqno !== null) {
            this.seqno = args.seqno;
          } else {
            this.seqno = 0;
          }
        }
        writeTo(cell) {
          cell.bits.writeUint(this.seqno, 32);
          cell.bits.writeUint8(this.sendMode);
          let orderCell = new Cell_1.Cell();
          this.order.writeTo(orderCell);
          cell.refs.push(orderCell);
        }
      };
      exports.WalletV1SigningMessage = WalletV1SigningMessage;
    }
  });

  // node_modules/ton/dist/contracts/messages/WalletV2SigningMessage.js
  var require_WalletV2SigningMessage = __commonJS({
    "node_modules/ton/dist/contracts/messages/WalletV2SigningMessage.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletV2SigningMessage = void 0;
      var Cell_1 = require_Cell();
      var WalletV2SigningMessage = class {
        constructor(args) {
          this.order = args.order;
          this.sendMode = args.sendMode;
          if (args.timeout !== void 0 && args.timeout !== null) {
            this.timeout = args.timeout;
          } else {
            this.timeout = Math.floor(Date.now() / 1e3) + 60;
          }
          if (args.seqno !== void 0 && args.seqno !== null) {
            this.seqno = args.seqno;
          } else {
            this.seqno = 0;
          }
        }
        writeTo(cell) {
          cell.bits.writeUint(this.seqno, 32);
          if (this.seqno === 0) {
            for (let i = 0; i < 32; i++) {
              cell.bits.writeBit(1);
            }
          } else {
            cell.bits.writeUint(this.timeout, 32);
          }
          cell.bits.writeUint8(this.sendMode);
          let orderCell = new Cell_1.Cell();
          this.order.writeTo(orderCell);
          cell.refs.push(orderCell);
        }
      };
      exports.WalletV2SigningMessage = WalletV2SigningMessage;
    }
  });

  // node_modules/ton/dist/contracts/messages/WalletV3SigningMessage.js
  var require_WalletV3SigningMessage = __commonJS({
    "node_modules/ton/dist/contracts/messages/WalletV3SigningMessage.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletV3SigningMessage = void 0;
      var Cell_1 = require_Cell();
      var WalletV3SigningMessage = class {
        constructor(args) {
          this.order = args.order;
          this.sendMode = args.sendMode;
          if (args.timeout !== void 0 && args.timeout !== null) {
            this.timeout = args.timeout;
          } else {
            this.timeout = Math.floor(Date.now() / 1e3) + 60;
          }
          if (args.seqno !== void 0 && args.seqno !== null) {
            this.seqno = args.seqno;
          } else {
            this.seqno = 0;
          }
          if (args.walletId !== null && args.walletId !== void 0) {
            this.walletId = args.walletId;
          } else {
            this.walletId = 698983191;
          }
        }
        writeTo(cell) {
          cell.bits.writeUint(this.walletId, 32);
          if (this.seqno === 0) {
            for (let i = 0; i < 32; i++) {
              cell.bits.writeBit(1);
            }
          } else {
            cell.bits.writeUint(this.timeout, 32);
          }
          cell.bits.writeUint(this.seqno, 32);
          cell.bits.writeUint8(this.sendMode);
          let orderCell = new Cell_1.Cell();
          this.order.writeTo(orderCell);
          cell.refs.push(orderCell);
        }
      };
      exports.WalletV3SigningMessage = WalletV3SigningMessage;
    }
  });

  // node_modules/ton/dist/contracts/messages/WalletV4SigningMessage.js
  var require_WalletV4SigningMessage = __commonJS({
    "node_modules/ton/dist/contracts/messages/WalletV4SigningMessage.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletV4SigningMessage = void 0;
      var Cell_1 = require_Cell();
      var WalletV4SigningMessage = class {
        constructor(args) {
          this.order = args.order;
          this.sendMode = args.sendMode;
          if (args.timeout !== void 0 && args.timeout !== null) {
            this.timeout = args.timeout;
          } else {
            this.timeout = Math.floor(Date.now() / 1e3) + 60;
          }
          if (args.seqno !== void 0 && args.seqno !== null) {
            this.seqno = args.seqno;
          } else {
            this.seqno = 0;
          }
          if (args.walletId !== null && args.walletId !== void 0) {
            this.walletId = args.walletId;
          } else {
            this.walletId = 698983191;
          }
        }
        writeTo(cell) {
          cell.bits.writeUint(this.walletId, 32);
          if (this.seqno === 0) {
            for (let i = 0; i < 32; i++) {
              cell.bits.writeBit(1);
            }
          } else {
            cell.bits.writeUint(this.timeout, 32);
          }
          cell.bits.writeUint(this.seqno, 32);
          cell.bits.writeUint8(0);
          if (this.order) {
            cell.bits.writeUint8(this.sendMode);
            let orderCell = new Cell_1.Cell();
            this.order.writeTo(orderCell);
            cell.refs.push(orderCell);
          }
        }
      };
      exports.WalletV4SigningMessage = WalletV4SigningMessage;
    }
  });

  // node_modules/ton/dist/contracts/messages/createWalletTransfer.js
  var require_createWalletTransfer = __commonJS({
    "node_modules/ton/dist/contracts/messages/createWalletTransfer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createWalletTransferV4 = exports.createWalletTransferV3 = exports.createWalletTransferV2 = exports.createWalletTransferV1 = void 0;
      var ton_crypto_1 = require_dist();
      var __1 = require_dist2();
      var WalletV1SigningMessage_1 = require_WalletV1SigningMessage();
      var WalletV2SigningMessage_1 = require_WalletV2SigningMessage();
      var WalletV3SigningMessage_1 = require_WalletV3SigningMessage();
      var WalletV4SigningMessage_1 = require_WalletV4SigningMessage();
      function createWalletTransferV1(args) {
        let signingMessage = new WalletV1SigningMessage_1.WalletV1SigningMessage({
          seqno: args.seqno,
          sendMode: args.sendMode,
          order: args.order
        });
        const cell = new __1.Cell();
        signingMessage.writeTo(cell);
        let signature = (0, ton_crypto_1.sign)(cell.hash(), args.secretKey);
        const body = new __1.Cell();
        body.bits.writeBuffer(signature);
        signingMessage.writeTo(body);
        return body;
      }
      exports.createWalletTransferV1 = createWalletTransferV1;
      function createWalletTransferV2(args) {
        let signingMessage = new WalletV2SigningMessage_1.WalletV2SigningMessage({
          seqno: args.seqno,
          sendMode: args.sendMode,
          order: args.order,
          timeout: args.timeout
        });
        const cell = new __1.Cell();
        signingMessage.writeTo(cell);
        let signature = (0, ton_crypto_1.sign)(cell.hash(), args.secretKey);
        const body = new __1.Cell();
        body.bits.writeBuffer(signature);
        signingMessage.writeTo(body);
        return body;
      }
      exports.createWalletTransferV2 = createWalletTransferV2;
      function createWalletTransferV3(args) {
        let signingMessage = new WalletV3SigningMessage_1.WalletV3SigningMessage({
          timeout: args.timeout,
          walletId: args.walletId,
          seqno: args.seqno,
          sendMode: args.sendMode,
          order: args.order
        });
        const cell = new __1.Cell();
        signingMessage.writeTo(cell);
        let signature = (0, ton_crypto_1.sign)(cell.hash(), args.secretKey);
        const body = new __1.Cell();
        body.bits.writeBuffer(signature);
        signingMessage.writeTo(body);
        return body;
      }
      exports.createWalletTransferV3 = createWalletTransferV3;
      function createWalletTransferV4(args) {
        let signingMessage = new WalletV4SigningMessage_1.WalletV4SigningMessage({
          timeout: args.timeout,
          walletId: args.walletId,
          seqno: args.seqno,
          sendMode: args.sendMode,
          order: args.order
        });
        const cell = new __1.Cell();
        signingMessage.writeTo(cell);
        let signature;
        if (args.secretKey) {
          signature = (0, ton_crypto_1.sign)(cell.hash(), args.secretKey);
        } else {
          signature = Buffer.alloc(64);
        }
        const body = new __1.Cell();
        body.bits.writeBuffer(signature);
        signingMessage.writeTo(body);
        return body;
      }
      exports.createWalletTransferV4 = createWalletTransferV4;
    }
  });

  // node_modules/ton/dist/contracts/contractAddress.js
  var require_contractAddress = __commonJS({
    "node_modules/ton/dist/contracts/contractAddress.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.contractAddress = void 0;
      var __1 = require_dist2();
      function contractAddress(source) {
        let cell = new __1.Cell();
        let state = new __1.StateInit({ code: source.initialCode, data: source.initialData });
        state.writeTo(cell);
        let hash = cell.hash();
        return new __1.Address(source.workchain, hash);
      }
      exports.contractAddress = contractAddress;
    }
  });

  // node_modules/ton/dist/contracts/WalletContract.js
  var require_WalletContract = __commonJS({
    "node_modules/ton/dist/contracts/WalletContract.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletContract = void 0;
      var createWalletTransfer_1 = require_createWalletTransfer();
      var contractAddress_1 = require_contractAddress();
      var WalletContract = class {
        constructor(client, source, address) {
          this.client = client;
          this.address = address;
          this.source = source;
        }
        static create(client, source) {
          let address = (0, contractAddress_1.contractAddress)(source);
          return new WalletContract(client, source, address);
        }
        getSeqNo() {
          return __async(this, null, function* () {
            if (yield this.client.isContractDeployed(this.address)) {
              let res = yield this.client.callGetMethod(this.address, "seqno");
              return parseInt(res.stack[0][1], 16);
            } else {
              return 0;
            }
          });
        }
        createTransfer(args) {
          switch (this.source.walletVersion) {
            case "v1":
              return (0, createWalletTransfer_1.createWalletTransferV1)({ seqno: args.seqno, sendMode: args.sendMode, secretKey: args.secretKey, order: args.order });
            case "v2":
              return (0, createWalletTransfer_1.createWalletTransferV2)({ seqno: args.seqno, sendMode: args.sendMode, secretKey: args.secretKey, order: args.order, timeout: args.timeout });
            case "v3":
              return (0, createWalletTransfer_1.createWalletTransferV3)({ seqno: args.seqno, sendMode: args.sendMode, secretKey: args.secretKey, order: args.order, walletId: this.source.walletId, timeout: args.timeout });
            case "v4":
              return (0, createWalletTransfer_1.createWalletTransferV4)({ seqno: args.seqno, sendMode: args.sendMode, secretKey: args.secretKey, order: args.order, walletId: this.source.walletId, timeout: args.timeout });
            default:
              throw Error("Unknown contract type: " + this.source.type);
          }
        }
      };
      exports.WalletContract = WalletContract;
    }
  });

  // node_modules/ton/dist/messages/InternalMessage.js
  var require_InternalMessage = __commonJS({
    "node_modules/ton/dist/messages/InternalMessage.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InternalMessage = void 0;
      var bn_js_1 = __importDefault(require_bn());
      var InternalMessage = class {
        constructor(opts) {
          this.to = opts.to;
          this.value = new bn_js_1.default(opts.value);
          this.bounce = opts.bounce;
          this.body = opts.body;
          if (opts.from) {
            this.from = opts.from;
          } else {
            this.from = null;
          }
          if (opts.ihrDisabled !== null && opts.ihrDisabled !== void 0) {
            this.ihrDisabled = opts.ihrDisabled;
          } else {
            this.ihrDisabled = true;
          }
          if (opts.bounced !== null && opts.bounced !== void 0) {
            this.bounced = opts.bounced;
          } else {
            this.bounced = false;
          }
          if (opts.ihrFees !== null && opts.ihrFees !== void 0) {
            this.ihrFees = new bn_js_1.default(opts.ihrFees);
          } else {
            this.ihrFees = new bn_js_1.default(0);
          }
          if (opts.fwdFees !== null && opts.fwdFees !== void 0) {
            this.fwdFees = new bn_js_1.default(opts.fwdFees);
          } else {
            this.fwdFees = new bn_js_1.default(0);
          }
          if (opts.createdAt !== null && opts.createdAt !== void 0) {
            this.createdAt = new bn_js_1.default(opts.createdAt);
          } else {
            this.createdAt = new bn_js_1.default(0);
          }
          if (opts.createdLt !== null && opts.createdLt !== void 0) {
            this.createdLt = new bn_js_1.default(opts.createdLt);
          } else {
            this.createdLt = new bn_js_1.default(0);
          }
        }
        writeTo(cell) {
          cell.bits.writeBit(0);
          cell.bits.writeBit(this.ihrDisabled);
          cell.bits.writeBit(this.bounce);
          cell.bits.writeBit(this.bounced);
          cell.bits.writeAddress(this.from);
          cell.bits.writeAddress(this.to);
          cell.bits.writeCoins(this.value);
          cell.bits.writeBit(false);
          cell.bits.writeCoins(this.ihrFees);
          cell.bits.writeCoins(this.fwdFees);
          cell.bits.writeUint(this.createdLt, 64);
          cell.bits.writeUint(this.createdAt, 32);
          this.body.writeTo(cell);
        }
      };
      exports.InternalMessage = InternalMessage;
    }
  });

  // node_modules/ton/dist/client/SendMode.js
  var require_SendMode = __commonJS({
    "node_modules/ton/dist/client/SendMode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SendMode = void 0;
      var SendMode;
      (function(SendMode2) {
        SendMode2[SendMode2["CARRRY_ALL_REMAINING_BALANCE"] = 128] = "CARRRY_ALL_REMAINING_BALANCE";
        SendMode2[SendMode2["CARRRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRRY_ALL_REMAINING_INCOMING_VALUE";
        SendMode2[SendMode2["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
        SendMode2[SendMode2["PAY_GAS_SEPARATLY"] = 1] = "PAY_GAS_SEPARATLY";
        SendMode2[SendMode2["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
      })(SendMode = exports.SendMode || (exports.SendMode = {}));
    }
  });

  // node_modules/ton/dist/client/Wallet.js
  var require_Wallet = __commonJS({
    "node_modules/ton/dist/client/Wallet.js"(exports) {
      "use strict";
      var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _Wallet_client;
      var _Wallet_contract;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Wallet = exports.validateWalletType = exports.allTypes = void 0;
      var bn_js_1 = __importDefault(require_bn());
      var ton_crypto_1 = require_dist();
      var __1 = require_dist2();
      var WalletV1R2Source_1 = require_WalletV1R2Source();
      var WalletV1R3Source_1 = require_WalletV1R3Source();
      var WalletV2R1Source_1 = require_WalletV2R1Source();
      var WalletV2R2Source_1 = require_WalletV2R2Source();
      var WalletV3R1Source_1 = require_WalletV3R1Source();
      var WalletV3R2Source_1 = require_WalletV3R2Source();
      var WalletV4Source_1 = require_WalletV4Source();
      var WalletContract_1 = require_WalletContract();
      var CommonMessageInfo_1 = require_CommonMessageInfo();
      var InternalMessage_1 = require_InternalMessage();
      var SendMode_1 = require_SendMode();
      exports.allTypes = [
        "org.ton.wallets.simple.r2",
        "org.ton.wallets.simple.r3",
        "org.ton.wallets.v2",
        "org.ton.wallets.v2.r2",
        "org.ton.wallets.v4",
        "org.ton.wallets.v3.r2",
        "org.ton.wallets.v3"
      ];
      function validateWalletType(src) {
        if (src === "org.ton.wallets.simple" || src === "org.ton.wallets.simple.r2" || src === "org.ton.wallets.simple.r3" || src === "org.ton.wallets.v2" || src === "org.ton.wallets.v2.r2" || src === "org.ton.wallets.v3" || src === "org.ton.wallets.v3.r2" || src === "org.ton.wallets.v4") {
          return src;
        }
        return null;
      }
      exports.validateWalletType = validateWalletType;
      function createContract(client, type, publicKey, workchain) {
        if (type === "org.ton.wallets.simple") {
          throw Error("Unsupported wallet");
        } else if (type === "org.ton.wallets.simple.r2") {
          return WalletContract_1.WalletContract.create(client, WalletV1R2Source_1.WalletV1R2Source.create({ publicKey, workchain }));
        } else if (type === "org.ton.wallets.simple.r3") {
          return WalletContract_1.WalletContract.create(client, WalletV1R3Source_1.WalletV1R3Source.create({ publicKey, workchain }));
        } else if (type === "org.ton.wallets.v2") {
          return WalletContract_1.WalletContract.create(client, WalletV2R1Source_1.WalletV2R1Source.create({ publicKey, workchain }));
        } else if (type === "org.ton.wallets.v2.r2") {
          return WalletContract_1.WalletContract.create(client, WalletV2R2Source_1.WalletV2R2Source.create({ publicKey, workchain }));
        } else if (type === "org.ton.wallets.v3") {
          return WalletContract_1.WalletContract.create(client, WalletV3R1Source_1.WalletV3R1Source.create({ publicKey, workchain }));
        } else if (type === "org.ton.wallets.v3.r2") {
          return WalletContract_1.WalletContract.create(client, WalletV3R2Source_1.WalletV3R2Source.create({ publicKey, workchain }));
        } else if (type === "org.ton.wallets.v4") {
          return WalletContract_1.WalletContract.create(client, WalletV4Source_1.WalletV4Source.create({ publicKey, workchain }));
        } else {
          throw Error("Unknown wallet type: " + type);
        }
      }
      var Wallet = class {
        constructor(client, address) {
          _Wallet_client.set(this, void 0);
          _Wallet_contract.set(this, null);
          __classPrivateFieldSet(this, _Wallet_client, client, "f");
          this.address = address;
        }
        static open(client, address) {
          return new Wallet(client, address);
        }
        static openDefault(client, workchain, secretKey) {
          const publicKey = (0, ton_crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
          let c = createContract(client, "org.ton.wallets.v3", publicKey, workchain);
          let w = new Wallet(client, c.address);
          w.prepare(workchain, publicKey, "org.ton.wallets.v3");
          return w;
        }
        static openByType(client, workchain, secretKey, type) {
          const publicKey = (0, ton_crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
          let c = createContract(client, type, publicKey, workchain);
          let w = new Wallet(client, c.address);
          w.prepare(workchain, publicKey, type);
          return w;
        }
        static openFromSource(client, source) {
          let address = (0, __1.contractAddress)(source);
          let w = new Wallet(client, address);
          w.prepareFromSource(source);
          return w;
        }
        static findActiveBySecretKey(client, workchain, secretKey) {
          return __async(this, null, function* () {
            const publicKey = (0, ton_crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
            let types = [];
            for (let type of exports.allTypes) {
              let contra = createContract(client, type, publicKey, workchain);
              let deployed = yield client.isContractDeployed(contra.address);
              let balance = yield client.getBalance(contra.address);
              if (deployed || balance.gt(new bn_js_1.default(0))) {
                types.push({ address: contra.address, type, balance, deployed });
              }
            }
            return types;
          });
        }
        static findBestBySecretKey(client, workchain, secretKey) {
          return __async(this, null, function* () {
            const publicKey = (0, ton_crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
            let allActive = yield this.findActiveBySecretKey(client, workchain, secretKey);
            if (allActive.length === 0) {
              return this.openDefault(client, workchain, secretKey);
            }
            let maxBalance = allActive[0].balance;
            let bestContract = allActive[0].type;
            for (let i = 1; i < allActive.length; i++) {
              let ac = allActive[i];
              if (ac.balance.gte(maxBalance)) {
                maxBalance = ac.balance;
                bestContract = ac.type;
              }
            }
            if (maxBalance.gt(new bn_js_1.default(0))) {
              let c2 = createContract(client, bestContract, publicKey, workchain);
              ;
              let w2 = new Wallet(client, c2.address);
              w2.prepare(workchain, publicKey, bestContract);
              return w2;
            }
            let c = createContract(client, allActive[allActive.length - 1].type, publicKey, workchain);
            let w = new Wallet(client, c.address);
            w.prepare(workchain, publicKey, allActive[allActive.length - 1].type);
            return w;
          });
        }
        get prepared() {
          return !!__classPrivateFieldGet(this, _Wallet_contract, "f");
        }
        getSeqNo() {
          return __async(this, null, function* () {
            if (yield __classPrivateFieldGet(this, _Wallet_client, "f").isContractDeployed(this.address)) {
              let res = yield __classPrivateFieldGet(this, _Wallet_client, "f").callGetMethod(this.address, "seqno");
              return parseInt(res.stack[0][1], 16);
            } else {
              return 0;
            }
          });
        }
        prepare(workchain, publicKey, type = "org.ton.wallets.v3") {
          let contra = createContract(__classPrivateFieldGet(this, _Wallet_client, "f"), type, publicKey, workchain);
          if (!contra.address.equals(this.address)) {
            throw Error("Contract have different address");
          }
          __classPrivateFieldSet(this, _Wallet_contract, contra, "f");
        }
        prepareFromSource(source) {
          let contra = WalletContract_1.WalletContract.create(__classPrivateFieldGet(this, _Wallet_client, "f"), source);
          if (!contra.address.equals(this.address)) {
            throw Error("Contract have different address");
          }
          __classPrivateFieldSet(this, _Wallet_contract, contra, "f");
        }
        transfer(args) {
          return __async(this, null, function* () {
            const contract = __classPrivateFieldGet(this, _Wallet_contract, "f");
            if (!contract) {
              throw Error("Please, prepare wallet first");
            }
            let payload = null;
            if (args.payload) {
              if (typeof args.payload === "string") {
                payload = new __1.CommentMessage(args.payload);
              } else if (Buffer.isBuffer(args.payload)) {
                payload = new __1.BinaryMessage(args.payload);
              } else if (args.payload instanceof __1.Cell) {
                payload = new __1.CellMessage(args.payload);
              }
            }
            const transfer = yield contract.createTransfer({
              secretKey: args.secretKey,
              seqno: args.seqno,
              sendMode: args.sendMode || SendMode_1.SendMode.IGNORE_ERRORS + SendMode_1.SendMode.PAY_GAS_SEPARATLY,
              timeout: args.timeout,
              order: new InternalMessage_1.InternalMessage({
                to: args.to,
                value: args.value,
                bounce: args.bounce,
                body: new CommonMessageInfo_1.CommonMessageInfo({ body: payload })
              })
            });
            yield __classPrivateFieldGet(this, _Wallet_client, "f").sendExternalMessage(contract, transfer);
          });
        }
        transferSign(args) {
          const contract = __classPrivateFieldGet(this, _Wallet_contract, "f");
          if (!contract) {
            throw Error("Please, prepare wallet first");
          }
          let payload = null;
          if (args.payload) {
            if (typeof args.payload === "string") {
              payload = new __1.CommentMessage(args.payload);
            } else if (Buffer.isBuffer(args.payload)) {
              payload = new __1.BinaryMessage(args.payload);
            } else if (args.payload instanceof __1.Cell) {
              payload = new __1.CellMessage(args.payload);
            }
          }
          const transfer = contract.createTransfer({
            secretKey: args.secretKey,
            seqno: args.seqno,
            sendMode: args.sendMode || SendMode_1.SendMode.IGNORE_ERRORS + SendMode_1.SendMode.PAY_GAS_SEPARATLY,
            timeout: args.timeout,
            order: new InternalMessage_1.InternalMessage({
              to: args.to,
              value: args.value,
              bounce: args.bounce,
              body: new CommonMessageInfo_1.CommonMessageInfo({ body: payload })
            })
          });
          const message = new __1.ExternalMessage({
            to: contract.address,
            body: new CommonMessageInfo_1.CommonMessageInfo({
              stateInit: new __1.StateInit({ code: contract.source.initialCode, data: contract.source.initialData }),
              body: new __1.CellMessage(transfer)
            })
          });
          const res = new __1.Cell();
          message.writeTo(res);
          return res;
        }
        transferCommit(transfer) {
          return __async(this, null, function* () {
            yield __classPrivateFieldGet(this, _Wallet_client, "f").sendFile(transfer.toBoc({ idx: false }));
          });
        }
      };
      exports.Wallet = Wallet;
      _Wallet_client = /* @__PURE__ */ new WeakMap(), _Wallet_contract = /* @__PURE__ */ new WeakMap();
    }
  });

  // node_modules/ton/dist/boc/Builder.js
  var require_Builder = __commonJS({
    "node_modules/ton/dist/boc/Builder.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.beginCell = exports.Builder = void 0;
      var BitString_1 = require_BitString();
      var Cell_1 = require_Cell();
      var Builder = class {
        constructor() {
          this.bits = BitString_1.BitString.alloc(1023);
          this.refs = [];
          this.ended = false;
          this.storeRef = (src) => {
            if (this.ended) {
              throw Error("Already ended");
            }
            this.refs.push(src);
            return this;
          };
          this.storeBit = (value) => {
            if (this.ended) {
              throw Error("Already ended");
            }
            this.bits.writeBit(value);
            return this;
          };
          this.storeBitArray = (value) => {
            if (this.ended) {
              throw Error("Already ended");
            }
            this.bits.writeBitArray(value);
            return this;
          };
          this.storeUint = (value, bitLength) => {
            if (this.ended) {
              throw Error("Already ended");
            }
            this.bits.writeUint(value, bitLength);
            return this;
          };
          this.storeInt = (value, bitLength) => {
            if (this.ended) {
              throw Error("Already ended");
            }
            this.bits.writeInt(value, bitLength);
            return this;
          };
          this.storeUint8 = (value) => {
            if (this.ended) {
              throw Error("Already ended");
            }
            this.bits.writeUint8(value);
            return this;
          };
          this.storeVarUint = (value, bitLength) => {
            if (this.ended) {
              throw Error("Already ended");
            }
            this.bits.writeVarUInt(value, bitLength);
            return this;
          };
          this.storeBuffer = (buffer) => {
            if (this.ended) {
              throw Error("Already ended");
            }
            this.bits.writeBuffer(buffer);
            return this;
          };
          this.storeCoins = (amount) => {
            if (this.ended) {
              throw Error("Already ended");
            }
            this.bits.writeCoins(amount);
            return this;
          };
          this.storeAddress = (address) => {
            if (this.ended) {
              throw Error("Already ended");
            }
            this.bits.writeAddress(address);
            return this;
          };
          this.storeBitString = (value) => {
            if (this.ended) {
              throw Error("Already ended");
            }
            this.bits.writeBitString(value);
            return this;
          };
          this.storeDict = (src) => {
            if (this.ended) {
              throw Error("Already ended");
            }
            if (src) {
              this.bits.writeBit(true);
              this.refs.push(src);
            } else {
              this.bits.writeBit(false);
            }
            return this;
          };
          this.storeRefMaybe = (src) => {
            return this.storeDict(src);
          };
          this.storeCellCopy = (src) => {
            this.storeBitString(src.bits);
            for (let r of src.refs) {
              this.storeRef(r);
            }
            return this;
          };
        }
        endCell() {
          if (this.ended) {
            throw Error("Already ended");
          }
          this.ended = true;
          let res = new Cell_1.Cell("ordinary", this.bits);
          for (let r of this.refs) {
            res.refs.push(r);
          }
          return res;
        }
      };
      exports.Builder = Builder;
      function beginCell() {
        return new Builder();
      }
      exports.beginCell = beginCell;
    }
  });

  // node_modules/ton/dist/boc/dict/parseDict.js
  var require_parseDict = __commonJS({
    "node_modules/ton/dist/boc/dict/parseDict.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseDictRefs = exports.parseDictBitString = exports.parseDict = void 0;
      var bn_js_1 = require_bn();
      function doParse(prefix, slice, n, res, extractor) {
        let lb0 = slice.readBit() ? 1 : 0;
        let prefixLength = 0;
        let pp = prefix;
        if (lb0 === 0) {
          prefixLength = slice.readUnaryLength();
          for (let i = 0; i < prefixLength; i++) {
            pp += slice.readBit() ? "1" : "0";
          }
        } else {
          let lb1 = slice.readBit() ? 1 : 0;
          if (lb1 === 0) {
            prefixLength = slice.readUintNumber(Math.ceil(Math.log2(n + 1)));
            for (let i = 0; i < prefixLength; i++) {
              pp += slice.readBit() ? "1" : "0";
            }
          } else {
            let bit = slice.readBit() ? "1" : "0";
            prefixLength = slice.readUintNumber(Math.ceil(Math.log2(n + 1)));
            for (let i = 0; i < prefixLength; i++) {
              pp += bit;
            }
          }
        }
        if (n - prefixLength === 0) {
          res.set(new bn_js_1.BN(pp, 2).toString(10), extractor(slice));
        } else {
          let left = slice.readCell();
          let right = slice.readCell();
          if (!left.isExotic) {
            doParse(pp + "0", left.beginParse(), n - prefixLength - 1, res, extractor);
          }
          if (!right.isExotic) {
            doParse(pp + "1", right.beginParse(), n - prefixLength - 1, res, extractor);
          }
        }
      }
      function parseDict(slice, keySize, extractor) {
        let res = /* @__PURE__ */ new Map();
        doParse("", slice, keySize, res, extractor);
        return res;
      }
      exports.parseDict = parseDict;
      function parseDictBitString(slice, keySize) {
        let res = /* @__PURE__ */ new Map();
        doParse("", slice, keySize, res, (slice2) => slice2.readRemaining());
        return res;
      }
      exports.parseDictBitString = parseDictBitString;
      function parseDictRefs(slice, keySize) {
        let res = /* @__PURE__ */ new Map();
        doParse("", slice, keySize, res, (slice2) => slice2.readRef());
        return res;
      }
      exports.parseDictRefs = parseDictRefs;
    }
  });

  // node_modules/ton/dist/contracts/configs/configParsing.js
  var require_configParsing = __commonJS({
    "node_modules/ton/dist/contracts/configs/configParsing.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseFullConfig = exports.parseVotingSetup = exports.parseProposalSetup = exports.configParse29 = exports.configParse28 = exports.configParseMsgPrices = exports.configParseGasLimitsPrices = exports.configParseBridge = exports.configParseValidatorSet = exports.configParse12 = exports.configParse40 = exports.configParse8 = exports.configParse18 = exports.configParse17 = exports.configParse16 = exports.configParse15 = exports.configParseMasterAddressRequired = exports.parseBridge = exports.parseValidatorSet = exports.parseValidatorDescr = exports.configParseWorkchainDescriptor = exports.configParseMasterAddress = void 0;
      var bn_js_1 = __importDefault(require_bn());
      var __1 = require_dist2();
      var parseDict_1 = require_parseDict();
      function configParseMasterAddress(slice) {
        if (slice) {
          return new __1.Address(-1, slice.readBuffer(32));
        } else {
          return null;
        }
      }
      exports.configParseMasterAddress = configParseMasterAddress;
      function configParseWorkchainDescriptor(slice) {
        if (slice.readUint(8).toNumber() !== 166) {
          throw Error("Invalid config");
        }
        let enabledSince = slice.readUint(32).toNumber();
        let actialMinSplit = slice.readUint(8).toNumber();
        let min_split = slice.readUint(8).toNumber();
        let max_split = slice.readUint(8).toNumber();
        let basic = slice.readBit();
        let active = slice.readBit();
        let accept_msgs = slice.readBit();
        let flags = slice.readUint(13).toNumber();
        let zerostateRootHash = slice.readBuffer(32);
        let zerostateFileHash = slice.readBuffer(32);
        let version = slice.readUint(32).toNumber();
        if (slice.readBit()) {
          throw Error("Invalid config");
        }
        let vmVersion = slice.readUint(32).toNumber();
        let vmMode = slice.readUint(64);
        return {
          enabledSince,
          actialMinSplit,
          min_split,
          max_split,
          basic,
          active,
          accept_msgs,
          flags,
          zerostateRootHash,
          zerostateFileHash,
          version,
          format: {
            vmVersion,
            vmMode
          }
        };
      }
      exports.configParseWorkchainDescriptor = configParseWorkchainDescriptor;
      function readPublicKey(slice) {
        if (slice.readUint(32).toNumber() !== 2390828938) {
          throw Error("Invalid config");
        }
        return slice.readBuffer(32);
      }
      function parseValidatorDescr(slice) {
        let header = slice.readUint(8).toNumber();
        if (header === 83) {
          return {
            publicKey: readPublicKey(slice),
            weight: slice.readUint(64),
            adnlAddress: null
          };
        } else if (header === 115) {
          return {
            publicKey: readPublicKey(slice),
            weight: slice.readUint(64),
            adnlAddress: slice.readBuffer(32)
          };
        } else {
          throw Error("Invalid config");
        }
      }
      exports.parseValidatorDescr = parseValidatorDescr;
      function parseValidatorSet(slice) {
        let header = slice.readUint(8).toNumber();
        if (header === 17) {
          let timeSince = slice.readUint(32).toNumber();
          let timeUntil = slice.readUint(32).toNumber();
          let total = slice.readUint(16).toNumber();
          let main = slice.readUint(16).toNumber();
          let list = (0, parseDict_1.parseDict)(slice.readRef(), 16, parseValidatorDescr);
          return {
            timeSince,
            timeUntil,
            total,
            main,
            totalWeight: null,
            list
          };
        } else if (header === 18) {
          let timeSince = slice.readUint(32).toNumber();
          let timeUntil = slice.readUint(32).toNumber();
          let total = slice.readUint(16).toNumber();
          let main = slice.readUint(16).toNumber();
          let totalWeight = slice.readUint(64);
          let exists = slice.readBit();
          let list = exists ? (0, parseDict_1.parseDict)(slice.readRef(), 16, parseValidatorDescr) : null;
          return {
            timeSince,
            timeUntil,
            total,
            main,
            totalWeight,
            list
          };
        }
      }
      exports.parseValidatorSet = parseValidatorSet;
      function parseBridge(slice) {
        let bridgeAddress = slice.readBuffer(32);
        let oracleMultisigAddress = slice.readBuffer(32);
        let oracles = slice.readBit() ? (0, parseDict_1.parseDict)(slice.readRef(), 256, (slice2) => slice2.readBuffer(32)) : null;
        let externalChainAddress = slice.readBuffer(32);
        return {
          bridgeAddress,
          oracleMultisigAddress,
          oracles,
          externalChainAddress
        };
      }
      exports.parseBridge = parseBridge;
      function configParseMasterAddressRequired(slice) {
        if (!slice) {
          throw Error("Invalid config");
        }
        return configParseMasterAddress(slice);
      }
      exports.configParseMasterAddressRequired = configParseMasterAddressRequired;
      function configParse15(slice) {
        if (!slice) {
          throw Error("Invalid config");
        }
        let validatorsElectedFor = slice.readUintNumber(32);
        let electorsStartBefore = slice.readUintNumber(32);
        let electorsEndBefore = slice.readUintNumber(32);
        let stakeHeldFor = slice.readUintNumber(32);
        return {
          validatorsElectedFor,
          electorsStartBefore,
          electorsEndBefore,
          stakeHeldFor
        };
      }
      exports.configParse15 = configParse15;
      function configParse16(slice) {
        if (!slice) {
          throw Error("Invalid config");
        }
        let maxValidators = slice.readUintNumber(16);
        let maxMainValidators = slice.readUintNumber(16);
        let minValidators = slice.readUintNumber(16);
        return {
          maxValidators,
          maxMainValidators,
          minValidators
        };
      }
      exports.configParse16 = configParse16;
      function configParse17(slice) {
        if (!slice) {
          throw Error("Invalid config");
        }
        let minStake = slice.readCoins();
        let maxStake = slice.readCoins();
        let minTotalStake = slice.readCoins();
        let maxStakeFactor = slice.readUintNumber(32);
        return {
          minStake,
          maxStake,
          minTotalStake,
          maxStakeFactor
        };
      }
      exports.configParse17 = configParse17;
      function configParse18(slice) {
        if (!slice) {
          throw Error("Invalid config");
        }
        let result = [];
        (0, parseDict_1.parseDict)(slice, 32, (slice2) => {
          let header = slice2.readUintNumber(8);
          if (header !== 204) {
            throw Error("Invalid config");
          }
          let utime_since = slice2.readUint(32);
          let bit_price_ps = slice2.readUint(64);
          let cell_price_ps = slice2.readUint(64);
          let mc_bit_price_ps = slice2.readUint(64);
          let mc_cell_price_ps = slice2.readUint(64);
          return {
            utime_since,
            bit_price_ps,
            cell_price_ps,
            mc_bit_price_ps,
            mc_cell_price_ps
          };
        }).forEach((a) => {
          result.push(a);
        });
        return result;
      }
      exports.configParse18 = configParse18;
      function configParse8(slice) {
        if (!slice) {
          return {
            version: 0,
            capabilities: new bn_js_1.default(0)
          };
        }
        let version = slice.readUintNumber(32);
        let capabilities = slice.readUint(64);
        return {
          version,
          capabilities
        };
      }
      exports.configParse8 = configParse8;
      function configParse40(slice) {
        if (!slice) {
          return null;
        }
        let header = slice.readUintNumber(8);
        if (header !== 1) {
          throw Error("Invalid config");
        }
        let defaultFlatFine = slice.readCoins();
        let defaultProportionaFine = slice.readCoins();
        let severityFlatMult = slice.readUintNumber(16);
        let severityProportionalMult = slice.readUintNumber(16);
        let unfunishableInterval = slice.readUintNumber(16);
        let longInterval = slice.readUintNumber(16);
        let longFlatMult = slice.readUintNumber(16);
        let longProportionalMult = slice.readUintNumber(16);
        let mediumInterval = slice.readUintNumber(16);
        let mediumFlatMult = slice.readUintNumber(16);
        let mediumProportionalMult = slice.readUintNumber(16);
        return {
          defaultFlatFine,
          defaultProportionaFine,
          severityFlatMult,
          severityProportionalMult,
          unfunishableInterval,
          longInterval,
          longFlatMult,
          longProportionalMult,
          mediumInterval,
          mediumFlatMult,
          mediumProportionalMult
        };
      }
      exports.configParse40 = configParse40;
      function configParse12(slice) {
        if (!slice) {
          throw Error("Invalid config");
        }
        if (slice.readUint(1).toNumber()) {
          return (0, parseDict_1.parseDict)(slice.readRef(), 32, configParseWorkchainDescriptor);
        } else {
          throw Error("No workchains exist");
        }
      }
      exports.configParse12 = configParse12;
      function configParseValidatorSet(slice) {
        if (!slice) {
          return null;
        }
        return parseValidatorSet(slice);
      }
      exports.configParseValidatorSet = configParseValidatorSet;
      function configParseBridge(slice) {
        if (!slice) {
          return null;
        }
        return parseBridge(slice);
      }
      exports.configParseBridge = configParseBridge;
      function parseGasLimitsInternal(slice) {
        const tag = slice.readUintNumber(8);
        if (tag === 222) {
          const gasPrice = slice.readUint(64);
          const gasLimit = slice.readUint(64);
          const specialGasLimit = slice.readUint(64);
          const gasCredit = slice.readUint(64);
          const blockGasLimit = slice.readUint(64);
          const freezeDueLimit = slice.readUint(64);
          const deleteDueLimit = slice.readUint(64);
          return {
            gasPrice,
            gasLimit,
            specialGasLimit,
            gasCredit,
            blockGasLimit,
            freezeDueLimit,
            deleteDueLimit
          };
        } else if (tag === 221) {
          const gasPrice = slice.readUint(64);
          const gasLimit = slice.readUint(64);
          const gasCredit = slice.readUint(64);
          const blockGasLimit = slice.readUint(64);
          const freezeDueLimit = slice.readUint(64);
          const deleteDueLimit = slice.readUint(64);
          return {
            gasPrice,
            gasLimit,
            gasCredit,
            blockGasLimit,
            freezeDueLimit,
            deleteDueLimit
          };
        } else {
          throw Error("Invalid config");
        }
      }
      function configParseGasLimitsPrices(slice) {
        if (!slice) {
          throw Error("Invalid config");
        }
        const tag = slice.readUintNumber(8);
        if (tag === 209) {
          const flatLimit = slice.readUint(64);
          const flatGasPrice = slice.readUint(64);
          const other = parseGasLimitsInternal(slice);
          return {
            flatLimit,
            flatGasPrice,
            other
          };
        } else {
          throw Error("Invalid config");
        }
      }
      exports.configParseGasLimitsPrices = configParseGasLimitsPrices;
      function configParseMsgPrices(slice) {
        if (!slice) {
          throw new Error("Invalid config");
        }
        let magic = slice.readUintNumber(8);
        if (magic !== 234) {
          throw new Error("Invalid msg prices param");
        }
        return {
          lumpPrice: slice.readUint(64),
          bitPrice: slice.readUint(64),
          cellPrice: slice.readUint(64),
          ihrPriceFactor: slice.readUint(32),
          firstFrac: slice.readUint(16),
          nextFrac: slice.readUint(16)
        };
      }
      exports.configParseMsgPrices = configParseMsgPrices;
      function configParse28(slice) {
        if (!slice) {
          throw new Error("Invalid config");
        }
        let magic = slice.readUintNumber(8);
        if (magic === 193) {
          let masterCatchainLifetime = slice.readUintNumber(32);
          let shardCatchainLifetime = slice.readUintNumber(32);
          let shardValidatorsLifetime = slice.readUintNumber(32);
          let shardValidatorsCount = slice.readUintNumber(32);
          return {
            masterCatchainLifetime,
            shardCatchainLifetime,
            shardValidatorsLifetime,
            shardValidatorsCount
          };
        }
        if (magic === 194) {
          let flags = slice.readUintNumber(7);
          let suffleMasterValidators = slice.readBit();
          let masterCatchainLifetime = slice.readUintNumber(32);
          let shardCatchainLifetime = slice.readUintNumber(32);
          let shardValidatorsLifetime = slice.readUintNumber(32);
          let shardValidatorsCount = slice.readUintNumber(32);
          return {
            flags,
            suffleMasterValidators,
            masterCatchainLifetime,
            shardCatchainLifetime,
            shardValidatorsLifetime,
            shardValidatorsCount
          };
        }
        throw new Error("Invalid config");
      }
      exports.configParse28 = configParse28;
      function configParse29(slice) {
        if (!slice) {
          throw new Error("Invalid config");
        }
        let magic = slice.readUintNumber(8);
        if (magic === 214) {
          let roundCandidates = slice.readUintNumber(32);
          let nextCandidateDelay = slice.readUintNumber(32);
          let consensusTimeout = slice.readUintNumber(32);
          let fastAttempts = slice.readUintNumber(32);
          let attemptDuration = slice.readUintNumber(32);
          let catchainMaxDeps = slice.readUintNumber(32);
          let maxBlockBytes = slice.readUintNumber(32);
          let maxColaltedBytes = slice.readUintNumber(32);
          return {
            roundCandidates,
            nextCandidateDelay,
            consensusTimeout,
            fastAttempts,
            attemptDuration,
            catchainMaxDeps,
            maxBlockBytes,
            maxColaltedBytes
          };
        } else if (magic === 215) {
          let flags = slice.readUintNumber(7);
          let newCatchainIds = slice.readBit();
          let roundCandidates = slice.readUintNumber(8);
          let nextCandidateDelay = slice.readUintNumber(32);
          let consensusTimeout = slice.readUintNumber(32);
          let fastAttempts = slice.readUintNumber(32);
          let attemptDuration = slice.readUintNumber(32);
          let catchainMaxDeps = slice.readUintNumber(32);
          let maxBlockBytes = slice.readUintNumber(32);
          let maxColaltedBytes = slice.readUintNumber(32);
          return {
            flags,
            newCatchainIds,
            roundCandidates,
            nextCandidateDelay,
            consensusTimeout,
            fastAttempts,
            attemptDuration,
            catchainMaxDeps,
            maxBlockBytes,
            maxColaltedBytes
          };
        } else if (magic === 216) {
          let flags = slice.readUintNumber(7);
          let newCatchainIds = slice.readBit();
          let roundCandidates = slice.readUintNumber(8);
          let nextCandidateDelay = slice.readUintNumber(32);
          let consensusTimeout = slice.readUintNumber(32);
          let fastAttempts = slice.readUintNumber(32);
          let attemptDuration = slice.readUintNumber(32);
          let catchainMaxDeps = slice.readUintNumber(32);
          let maxBlockBytes = slice.readUintNumber(32);
          let maxColaltedBytes = slice.readUintNumber(32);
          let protoVersion = slice.readUintNumber(16);
          return {
            flags,
            newCatchainIds,
            roundCandidates,
            nextCandidateDelay,
            consensusTimeout,
            fastAttempts,
            attemptDuration,
            catchainMaxDeps,
            maxBlockBytes,
            maxColaltedBytes,
            protoVersion
          };
        } else if (magic === 217) {
          let flags = slice.readUintNumber(7);
          let newCatchainIds = slice.readBit();
          let roundCandidates = slice.readUintNumber(8);
          let nextCandidateDelay = slice.readUintNumber(32);
          let consensusTimeout = slice.readUintNumber(32);
          let fastAttempts = slice.readUintNumber(32);
          let attemptDuration = slice.readUintNumber(32);
          let catchainMaxDeps = slice.readUintNumber(32);
          let maxBlockBytes = slice.readUintNumber(32);
          let maxColaltedBytes = slice.readUintNumber(32);
          let protoVersion = slice.readUintNumber(16);
          let catchainMaxBlocksCoeff = slice.readUintNumber(32);
          return {
            flags,
            newCatchainIds,
            roundCandidates,
            nextCandidateDelay,
            consensusTimeout,
            fastAttempts,
            attemptDuration,
            catchainMaxDeps,
            maxBlockBytes,
            maxColaltedBytes,
            protoVersion,
            catchainMaxBlocksCoeff
          };
        }
        throw new Error("Invalid config");
      }
      exports.configParse29 = configParse29;
      function parseProposalSetup(slice) {
        let magic = slice.readUintNumber(8);
        if (magic !== 54) {
          throw new Error("Invalid config");
        }
        let minTotalRounds = slice.readUintNumber(8);
        let maxTotalRounds = slice.readUintNumber(8);
        let minWins = slice.readUintNumber(8);
        let maxLoses = slice.readUintNumber(8);
        let minStoreSec = slice.readUintNumber(32);
        let maxStoreSec = slice.readUintNumber(32);
        let bitPrice = slice.readUintNumber(32);
        let cellPrice = slice.readUintNumber(32);
        return { minTotalRounds, maxTotalRounds, minWins, maxLoses, minStoreSec, maxStoreSec, bitPrice, cellPrice };
      }
      exports.parseProposalSetup = parseProposalSetup;
      function parseVotingSetup(slice) {
        if (!slice) {
          throw new Error("Invalid config");
        }
        let magic = slice.readUintNumber(8);
        if (magic !== 145) {
          throw new Error("Invalid config");
        }
        let normalParams = parseProposalSetup(slice.readRef());
        let criticalParams = parseProposalSetup(slice.readRef());
        return { normalParams, criticalParams };
      }
      exports.parseVotingSetup = parseVotingSetup;
      function parseFullConfig(configs) {
        return {
          configAddress: configParseMasterAddressRequired(configs.get("0")),
          electorAddress: configParseMasterAddressRequired(configs.get("1")),
          minterAddress: configParseMasterAddress(configs.get("2")),
          feeCollectorAddress: configParseMasterAddress(configs.get("3")),
          dnsRootAddress: configParseMasterAddress(configs.get("4")),
          globalVersion: configParse8(configs.get("8")),
          workchains: configParse12(configs.get("12")),
          voting: parseVotingSetup(configs.get("11")),
          validators: __spreadValues(__spreadValues(__spreadValues({}, configParse15(configs.get("15"))), configParse16(configs.get("16"))), configParse17(configs.get("17"))),
          storagePrices: configParse18(configs.get("18")),
          gasPrices: {
            masterchain: configParseGasLimitsPrices(configs.get("20")),
            workchain: configParseGasLimitsPrices(configs.get("21"))
          },
          msgPrices: {
            masterchain: configParseMsgPrices(configs.get("24")),
            workchain: configParseMsgPrices(configs.get("25"))
          },
          validatorSets: {
            prevValidators: configParseValidatorSet(configs.get("32")),
            prevTempValidators: configParseValidatorSet(configs.get("33")),
            currentValidators: configParseValidatorSet(configs.get("34")),
            currentTempValidators: configParseValidatorSet(configs.get("35")),
            nextValidators: configParseValidatorSet(configs.get("36")),
            nextTempValidators: configParseValidatorSet(configs.get("37"))
          },
          validatorsPunish: configParse40(configs.get("40")),
          bridges: {
            ethereum: configParseBridge(configs.get("71")),
            binance: configParseBridge(configs.get("72")),
            polygon: configParseBridge(configs.get("73"))
          },
          catchain: configParse28(configs.get("28")),
          consensus: configParse29(configs.get("29"))
        };
      }
      exports.parseFullConfig = parseFullConfig;
    }
  });

  // node_modules/ton/dist/contracts/ConfigContract.js
  var require_ConfigContract = __commonJS({
    "node_modules/ton/dist/contracts/ConfigContract.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConfigContract = void 0;
      var __1 = require_dist2();
      var BitStringReader_1 = require_BitStringReader();
      var Builder_1 = require_Builder();
      var parseDict_1 = require_parseDict();
      var configParsing_1 = require_configParsing();
      var ConfigContract = class {
        constructor(client) {
          this.address = __1.Address.parseRaw("-1:5555555555555555555555555555555555555555555555555555555555555555");
          this.source = new __1.UnknownContractSource("org.ton.config", -1, "Config Contract");
          this.client = client;
        }
        getSeqNo() {
          return __async(this, null, function* () {
            let res = yield this.client.callGetMethod(this.address, "seqno");
            return parseInt(res.stack[0][1], 16);
          });
        }
        getPublicKey() {
          return __async(this, null, function* () {
            let data = (yield this.client.getContractState(this.address)).data;
            let cell = __1.Cell.fromBoc(data)[0];
            let reader = new BitStringReader_1.BitStringReader(cell.bits);
            reader.readUint(32);
            return reader.readUint(256);
          });
        }
        getConfigsRaw() {
          return __async(this, null, function* () {
            let data = (yield this.client.getContractState(this.address)).data;
            let slice = __1.Cell.fromBoc(data)[0].beginParse();
            let dict = slice.readRef();
            let res = (0, parseDict_1.parseDictRefs)(dict, 32);
            return res;
          });
        }
        getConfigs() {
          return __async(this, null, function* () {
            let configs = yield this.getConfigsRaw();
            return (0, configParsing_1.parseFullConfig)(configs);
          });
        }
        createProposal(args) {
          return __async(this, null, function* () {
            return (0, Builder_1.beginCell)().storeUint(1851150418, 32).storeUint(args.queryId, 64).storeUint(args.expiresAt, 32).storeRef((0, Builder_1.beginCell)().storeUint(243, 8).storeUint(args.paramId, 32).storeRefMaybe(args.paramValue).storeRefMaybe(args.ifHashEqual).endCell()).storeBit(args.critical).endCell();
          });
        }
      };
      exports.ConfigContract = ConfigContract;
    }
  });

  // node_modules/ton/dist/client/TonCache.js
  var require_TonCache = __commonJS({
    "node_modules/ton/dist/client/TonCache.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InMemoryCache = void 0;
      var InMemoryCache = class {
        constructor() {
          this.cache = /* @__PURE__ */ new Map();
          this.set = (namespace, key, value) => __async(this, null, function* () {
            if (value !== null) {
              this.cache.set(namespace + "$$" + key, value);
            } else {
              this.cache.delete(namespace + "$$" + key);
            }
          });
          this.get = (namespace, key) => __async(this, null, function* () {
            let res = this.cache.get(namespace + "$$" + key);
            if (res !== void 0) {
              return res;
            } else {
              return null;
            }
          });
        }
      };
      exports.InMemoryCache = InMemoryCache;
    }
  });

  // node_modules/ton/dist/client/TonClient.js
  var require_TonClient = __commonJS({
    "node_modules/ton/dist/client/TonClient.js"(exports) {
      "use strict";
      var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var _TonClient_api;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TonClient = void 0;
      var ton_crypto_1 = require_dist();
      var Address_1 = require_Address();
      var Cell_1 = require_Cell();
      var HttpApi_1 = require_HttpApi();
      var ExternalMessage_1 = require_ExternalMessage();
      var CommonMessageInfo_1 = require_CommonMessageInfo();
      var StateInit_1 = require_StateInit();
      var Wallet_1 = require_Wallet();
      var bn_js_1 = require_bn();
      var __1 = require_dist2();
      var ConfigContract_1 = require_ConfigContract();
      var TonCache_1 = require_TonCache();
      function convertMessage(t) {
        return {
          source: t.source !== "" ? Address_1.Address.parseFriendly(t.source).address : null,
          destination: t.destination !== "" ? Address_1.Address.parseFriendly(t.destination).address : null,
          forwardFee: new bn_js_1.BN(t.fwd_fee),
          ihrFee: new bn_js_1.BN(t.ihr_fee),
          value: new bn_js_1.BN(t.value),
          createdLt: t.created_lt,
          body: t.msg_data["@type"] === "msg.dataRaw" ? { type: "data", data: Buffer.from(t.msg_data.body, "base64") } : t.msg_data["@type"] === "msg.dataText" ? { type: "text", text: Buffer.from(t.msg_data.text, "base64").toString("utf-8") } : null
        };
      }
      function convertTransaction(r) {
        return {
          id: { lt: r.transaction_id.lt, hash: r.transaction_id.hash },
          time: r.utime,
          data: r.data,
          storageFee: new bn_js_1.BN(r.storage_fee),
          otherFee: new bn_js_1.BN(r.other_fee),
          fee: new bn_js_1.BN(r.fee),
          inMessage: r.in_msg ? convertMessage(r.in_msg) : null,
          outMessages: r.out_msgs.map(convertMessage)
        };
      }
      var TonClient2 = class {
        constructor(parameters) {
          _TonClient_api.set(this, void 0);
          this.services = {
            configs: new ConfigContract_1.ConfigContract(this)
          };
          this.parameters = {
            endpoint: parameters.endpoint,
            cache: parameters.cache ? parameters.cache : new TonCache_1.InMemoryCache()
          };
          __classPrivateFieldSet(this, _TonClient_api, new HttpApi_1.HttpApi(this.parameters.endpoint, this.parameters.cache, {
            timeout: parameters.timeout,
            apiKey: parameters.apiKey,
            adapter: parameters.httpAdapter
          }), "f");
        }
        getBalance(address) {
          return __async(this, null, function* () {
            return (yield this.getContractState(address)).balance;
          });
        }
        callGetMethod(_0, _1) {
          return __async(this, arguments, function* (address, name, params = []) {
            let res = yield __classPrivateFieldGet(this, _TonClient_api, "f").callGetMethod(address, name, params);
            if (res.exit_code !== 0) {
              throw Error("Unable to execute get method. Got exit_code: " + res.exit_code);
            }
            return { gas_used: res.gas_used, stack: res.stack };
          });
        }
        callGetMethodWithError(_0, _1) {
          return __async(this, arguments, function* (address, name, params = []) {
            let res = yield __classPrivateFieldGet(this, _TonClient_api, "f").callGetMethod(address, name, params);
            return { gas_used: res.gas_used, stack: res.stack, exit_code: res.exit_code };
          });
        }
        getTransactions(address, opts) {
          return __async(this, null, function* () {
            let tx = yield __classPrivateFieldGet(this, _TonClient_api, "f").getTransactions(address, opts);
            let res = [];
            for (let r of tx) {
              res.push(convertTransaction(r));
            }
            return res;
          });
        }
        getTransaction(address, lt, hash) {
          return __async(this, null, function* () {
            let res = yield __classPrivateFieldGet(this, _TonClient_api, "f").getTransaction(address, lt, hash);
            if (res) {
              return convertTransaction(res);
            } else {
              return null;
            }
          });
        }
        getMasterchainInfo() {
          return __async(this, null, function* () {
            let r = yield __classPrivateFieldGet(this, _TonClient_api, "f").getMasterchainInfo();
            return {
              workchain: r.init.workchain,
              shard: r.last.shard,
              initSeqno: r.init.seqno,
              latestSeqno: r.last.seqno
            };
          });
        }
        getWorkchainShards(seqno) {
          return __async(this, null, function* () {
            let r = yield __classPrivateFieldGet(this, _TonClient_api, "f").getShards(seqno);
            return r.map((m) => ({
              workchain: m.workchain,
              shard: m.shard,
              seqno: m.seqno
            }));
          });
        }
        getShardTransactions(workchain, seqno, shard) {
          return __async(this, null, function* () {
            let tx = yield __classPrivateFieldGet(this, _TonClient_api, "f").getBlockTransactions(workchain, seqno, shard);
            if (tx.incomplete) {
              throw Error("Unsupported");
            }
            return tx.transactions.map((v) => ({
              account: Address_1.Address.parseRaw(v.account),
              lt: v.lt,
              hash: v.hash
            }));
          });
        }
        sendMessage(src) {
          return __async(this, null, function* () {
            const cell = new Cell_1.Cell();
            src.writeTo(cell);
            const boc = yield cell.toBoc({ idx: false });
            yield __classPrivateFieldGet(this, _TonClient_api, "f").sendBoc(boc);
          });
        }
        sendFile(src) {
          return __async(this, null, function* () {
            yield __classPrivateFieldGet(this, _TonClient_api, "f").sendBoc(src);
          });
        }
        estimateExternalMessageFee(address, args) {
          return __async(this, null, function* () {
            return yield __classPrivateFieldGet(this, _TonClient_api, "f").estimateFee(address, { body: args.body, initCode: args.initCode, initData: args.initData, ignoreSignature: args.ignoreSignature });
          });
        }
        sendExternalMessage(contract, src) {
          return __async(this, null, function* () {
            if (yield this.isContractDeployed(contract.address)) {
              const message = new ExternalMessage_1.ExternalMessage({
                to: contract.address,
                body: new CommonMessageInfo_1.CommonMessageInfo({
                  body: new __1.CellMessage(src)
                })
              });
              yield this.sendMessage(message);
            } else {
              const message = new ExternalMessage_1.ExternalMessage({
                to: contract.address,
                body: new CommonMessageInfo_1.CommonMessageInfo({
                  stateInit: new StateInit_1.StateInit({ code: contract.source.initialCode, data: contract.source.initialData }),
                  body: new __1.CellMessage(src)
                })
              });
              yield this.sendMessage(message);
            }
          });
        }
        isContractDeployed(address) {
          return __async(this, null, function* () {
            return (yield this.getContractState(address)).state === "active";
          });
        }
        getContractState(address) {
          return __async(this, null, function* () {
            let info = yield __classPrivateFieldGet(this, _TonClient_api, "f").getAddressInformation(address);
            let balance = new bn_js_1.BN(info.balance);
            let state = info.state;
            return {
              balance,
              state,
              code: info.code !== "" ? Buffer.from(info.code, "base64") : null,
              data: info.data !== "" ? Buffer.from(info.data, "base64") : null,
              lastTransaction: info.last_transaction_id.lt !== "0" ? {
                lt: info.last_transaction_id.lt,
                hash: info.last_transaction_id.hash
              } : null,
              blockId: {
                workchain: info.block_id.workchain,
                shard: info.block_id.shard,
                seqno: info.block_id.seqno
              },
              timestampt: info.sync_utime
            };
          });
        }
        openWalletFromAddress(args) {
          return Wallet_1.Wallet.open(this, args.source);
        }
        findWalletFromSecretKey(args) {
          return Wallet_1.Wallet.findBestBySecretKey(this, args.workchain, args.secretKey);
        }
        openWalletDefaultFromSecretKey(args) {
          return Wallet_1.Wallet.openDefault(this, args.workchain, args.secretKey);
        }
        openWalletFromSecretKey(args) {
          return Wallet_1.Wallet.openByType(this, args.workchain, args.secretKey, args.type);
        }
        openWalletFromCustomContract(src) {
          return Wallet_1.Wallet.openFromSource(this, src);
        }
        createNewWallet(args) {
          return __async(this, null, function* () {
            let mnemonic = yield (0, ton_crypto_1.mnemonicNew)(24, args.password);
            let key = yield (0, ton_crypto_1.mnemonicToWalletKey)(mnemonic, args.password);
            let kind = args.type || "org.ton.wallets.v3";
            let wallet = Wallet_1.Wallet.openByType(this, args.workchain, key.secretKey, kind);
            return {
              mnemonic,
              key,
              wallet
            };
          });
        }
      };
      exports.TonClient = TonClient2;
      _TonClient_api = /* @__PURE__ */ new WeakMap();
    }
  });

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports) {
      "use strict";
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer2 = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 24);
        const hi = this[++offset] + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + last * __pow(2, 24);
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + this[++offset];
        const lo = this[++offset] * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * __pow(2, 8) + this[offset + 6] * __pow(2, 16) + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 24));
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > __pow(2, 32)) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > __pow(BigInt(2), BigInt(32)) || input < -__pow(BigInt(2), BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/ethjs-unit/node_modules/bn.js/lib/bn.js
  var require_bn2 = __commonJS({
    "node_modules/ethjs-unit/node_modules/bn.js/lib/bn.js"(exports, module) {
      (function(module2, exports2) {
        "use strict";
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number, base, endian) {
          if (BN2.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          Buffer2 = require_buffer2().Buffer;
        } catch (e) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN2.prototype._init = function init(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
          }
          if (base === 16) {
            this._parseHex(number, start);
          } else {
            this._parseBase(number, base, start);
          }
          if (number[0] === "-") {
            this.negative = 1;
          }
          this.strip();
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN2.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN2.prototype._initArray = function _initArray(number, base, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex(str, start, end) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r <<= 4;
            if (c >= 49 && c <= 54) {
              r |= c - 49 + 10;
            } else if (c >= 17 && c <= 22) {
              r |= c - 17 + 10;
            } else {
              r |= c & 15;
            }
          }
          return r;
        }
        BN2.prototype._parseHex = function _parseHex(number, start) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          for (i = number.length - 6, j = 0; i >= start; i -= 6) {
            w = parseHex(number, i, i + 6);
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] |= w >>> 26 - off & 4194303;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
          if (i + 6 !== start) {
            w = parseHex(number, start, i + 6);
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] |= w >>> 26 - off & 4194303;
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              r += c - 49 + 10;
            } else if (c >= 17) {
              r += c - 17 + 10;
            } else {
              r += c;
            }
          }
          return r;
        }
        BN2.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
        };
        BN2.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN2.prototype.clone = function clone() {
          var r = new BN2(null);
          this.copy(r);
          return r;
        };
        BN2.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN2.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN2.prototype.toBuffer = function toBuffer(endian, length) {
          assert(typeof Buffer2 !== "undefined");
          return this.toArrayLike(Buffer2, endian, length);
        };
        BN2.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert(byteLength <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i;
          var q = this.clone();
          if (!littleEndian) {
            for (i = 0; i < reqLength - byteLength; i++) {
              res[i] = 0;
            }
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i - 1] = b;
            }
          } else {
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i] = b;
            }
            for (; i < reqLength; i++) {
              res[i] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN2.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this.strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this.strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN2.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN2.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out.strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN2(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div2, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div2 = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div: div2,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div2 = res.div.neg();
            }
            return {
              div: div2,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div2(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN2.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return acc;
        };
        BN2.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          return this.strip();
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN2(1);
          var x2 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            r.strip();
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN2(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN2(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN2(1);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN2(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // node_modules/number-to-bn/node_modules/bn.js/lib/bn.js
  var require_bn3 = __commonJS({
    "node_modules/number-to-bn/node_modules/bn.js/lib/bn.js"(exports, module) {
      (function(module2, exports2) {
        "use strict";
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number, base, endian) {
          if (BN2.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          Buffer2 = require_buffer2().Buffer;
        } catch (e) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN2.prototype._init = function init(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
          }
          if (base === 16) {
            this._parseHex(number, start);
          } else {
            this._parseBase(number, base, start);
          }
          if (number[0] === "-") {
            this.negative = 1;
          }
          this.strip();
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN2.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN2.prototype._initArray = function _initArray(number, base, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex(str, start, end) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r <<= 4;
            if (c >= 49 && c <= 54) {
              r |= c - 49 + 10;
            } else if (c >= 17 && c <= 22) {
              r |= c - 17 + 10;
            } else {
              r |= c & 15;
            }
          }
          return r;
        }
        BN2.prototype._parseHex = function _parseHex(number, start) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          for (i = number.length - 6, j = 0; i >= start; i -= 6) {
            w = parseHex(number, i, i + 6);
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] |= w >>> 26 - off & 4194303;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
          if (i + 6 !== start) {
            w = parseHex(number, start, i + 6);
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] |= w >>> 26 - off & 4194303;
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              r += c - 49 + 10;
            } else if (c >= 17) {
              r += c - 17 + 10;
            } else {
              r += c;
            }
          }
          return r;
        }
        BN2.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
        };
        BN2.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN2.prototype.clone = function clone() {
          var r = new BN2(null);
          this.copy(r);
          return r;
        };
        BN2.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN2.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN2.prototype.toBuffer = function toBuffer(endian, length) {
          assert(typeof Buffer2 !== "undefined");
          return this.toArrayLike(Buffer2, endian, length);
        };
        BN2.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert(byteLength <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i;
          var q = this.clone();
          if (!littleEndian) {
            for (i = 0; i < reqLength - byteLength; i++) {
              res[i] = 0;
            }
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i - 1] = b;
            }
          } else {
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i] = b;
            }
            for (; i < reqLength; i++) {
              res[i] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN2.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this.strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this.strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN2.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN2.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out.strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN2(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div2, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div2 = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div: div2,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div2 = res.div.neg();
            }
            return {
              div: div2,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div2(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN2.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return acc;
        };
        BN2.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          return this.strip();
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN2(1);
          var x2 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            r.strip();
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN2(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN2(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN2(1);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN2(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // node_modules/is-hex-prefixed/src/index.js
  var require_src2 = __commonJS({
    "node_modules/is-hex-prefixed/src/index.js"(exports, module) {
      module.exports = function isHexPrefixed(str) {
        if (typeof str !== "string") {
          throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof str + ", while checking isHexPrefixed.");
        }
        return str.slice(0, 2) === "0x";
      };
    }
  });

  // node_modules/strip-hex-prefix/src/index.js
  var require_src3 = __commonJS({
    "node_modules/strip-hex-prefix/src/index.js"(exports, module) {
      var isHexPrefixed = require_src2();
      module.exports = function stripHexPrefix(str) {
        if (typeof str !== "string") {
          return str;
        }
        return isHexPrefixed(str) ? str.slice(2) : str;
      };
    }
  });

  // node_modules/number-to-bn/src/index.js
  var require_src4 = __commonJS({
    "node_modules/number-to-bn/src/index.js"(exports, module) {
      var BN2 = require_bn3();
      var stripHexPrefix = require_src3();
      module.exports = function numberToBN(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          var multiplier = new BN2(1);
          var formattedString = String(arg).toLowerCase().trim();
          var isHexPrefixed = formattedString.substr(0, 2) === "0x" || formattedString.substr(0, 3) === "-0x";
          var stringArg = stripHexPrefix(formattedString);
          if (stringArg.substr(0, 1) === "-") {
            stringArg = stripHexPrefix(stringArg.slice(1));
            multiplier = new BN2(-1, 10);
          }
          stringArg = stringArg === "" ? "0" : stringArg;
          if (!stringArg.match(/^-?[0-9]+$/) && stringArg.match(/^[0-9A-Fa-f]+$/) || stringArg.match(/^[a-fA-F]+$/) || isHexPrefixed === true && stringArg.match(/^[0-9A-Fa-f]+$/)) {
            return new BN2(stringArg, 16).mul(multiplier);
          }
          if ((stringArg.match(/^-?[0-9]+$/) || stringArg === "") && isHexPrefixed === false) {
            return new BN2(stringArg, 10).mul(multiplier);
          }
        } else if (typeof arg === "object" && arg.toString && (!arg.pop && !arg.push)) {
          if (arg.toString(10).match(/^-?[0-9]+$/) && (arg.mul || arg.dividedToIntegerBy)) {
            return new BN2(arg.toString(10), 10);
          }
        }
        throw new Error("[number-to-bn] while converting number " + JSON.stringify(arg) + " to BN.js instance, error: invalid number value. Value must be an integer, hex string, BN or BigNumber instance. Note, decimals are not supported.");
      };
    }
  });

  // node_modules/ethjs-unit/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/ethjs-unit/lib/index.js"(exports, module) {
      "use strict";
      var BN2 = require_bn2();
      var numberToBN = require_src4();
      var zero = new BN2(0);
      var negative1 = new BN2(-1);
      var unitMap = {
        "noether": "0",
        "wei": "1",
        "kwei": "1000",
        "Kwei": "1000",
        "babbage": "1000",
        "femtoether": "1000",
        "mwei": "1000000",
        "Mwei": "1000000",
        "lovelace": "1000000",
        "picoether": "1000000",
        "gwei": "1000000000",
        "Gwei": "1000000000",
        "shannon": "1000000000",
        "nanoether": "1000000000",
        "nano": "1000000000",
        "szabo": "1000000000000",
        "microether": "1000000000000",
        "micro": "1000000000000",
        "finney": "1000000000000000",
        "milliether": "1000000000000000",
        "milli": "1000000000000000",
        "ether": "1000000000000000000",
        "kether": "1000000000000000000000",
        "grand": "1000000000000000000000",
        "mether": "1000000000000000000000000",
        "gether": "1000000000000000000000000000",
        "tether": "1000000000000000000000000000000"
      };
      function getValueOfUnit(unitInput) {
        var unit = unitInput ? unitInput.toLowerCase() : "ether";
        var unitValue = unitMap[unit];
        if (typeof unitValue !== "string") {
          throw new Error("[ethjs-unit] the unit provided " + unitInput + " doesn't exists, please use the one of the following units " + JSON.stringify(unitMap, null, 2));
        }
        return new BN2(unitValue, 10);
      }
      function numberToString(arg) {
        if (typeof arg === "string") {
          if (!arg.match(/^-?[0-9.]+$/)) {
            throw new Error("while converting number to string, invalid number value '" + arg + "', should be a number matching (^-?[0-9.]+).");
          }
          return arg;
        } else if (typeof arg === "number") {
          return String(arg);
        } else if (typeof arg === "object" && arg.toString && (arg.toTwos || arg.dividedToIntegerBy)) {
          if (arg.toPrecision) {
            return String(arg.toPrecision());
          } else {
            return arg.toString(10);
          }
        }
        throw new Error("while converting number to string, invalid number value '" + arg + "' type " + typeof arg + ".");
      }
      function fromWei(weiInput, unit, optionsInput) {
        var wei = numberToBN(weiInput);
        var negative = wei.lt(zero);
        var base = getValueOfUnit(unit);
        var baseLength = unitMap[unit].length - 1 || 1;
        var options = optionsInput || {};
        if (negative) {
          wei = wei.mul(negative1);
        }
        var fraction = wei.mod(base).toString(10);
        while (fraction.length < baseLength) {
          fraction = "0" + fraction;
        }
        if (!options.pad) {
          fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
        }
        var whole = wei.div(base).toString(10);
        if (options.commify) {
          whole = whole.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }
        var value = "" + whole + (fraction == "0" ? "" : "." + fraction);
        if (negative) {
          value = "-" + value;
        }
        return value;
      }
      function toWei(etherInput, unit) {
        var ether = numberToString(etherInput);
        var base = getValueOfUnit(unit);
        var baseLength = unitMap[unit].length - 1 || 1;
        var negative = ether.substring(0, 1) === "-";
        if (negative) {
          ether = ether.substring(1);
        }
        if (ether === ".") {
          throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei, invalid value");
        }
        var comps = ether.split(".");
        if (comps.length > 2) {
          throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei,  too many decimal points");
        }
        var whole = comps[0], fraction = comps[1];
        if (!whole) {
          whole = "0";
        }
        if (!fraction) {
          fraction = "0";
        }
        if (fraction.length > baseLength) {
          throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei, too many decimal places");
        }
        while (fraction.length < baseLength) {
          fraction += "0";
        }
        whole = new BN2(whole);
        fraction = new BN2(fraction);
        var wei = whole.mul(base).add(fraction);
        if (negative) {
          wei = wei.mul(negative1);
        }
        return new BN2(wei.toString(10), 10);
      }
      module.exports = {
        unitMap,
        numberToString,
        getValueOfUnit,
        fromWei,
        toWei
      };
    }
  });

  // node_modules/ton/dist/utils/convert.js
  var require_convert = __commonJS({
    "node_modules/ton/dist/utils/convert.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromNano = exports.toNano = void 0;
      var ethUnit = require_lib2();
      function toNano(src) {
        return ethUnit.toWei(src, "gwei");
      }
      exports.toNano = toNano;
      function fromNano(src) {
        return ethUnit.fromWei(src, "gwei");
      }
      exports.fromNano = fromNano;
    }
  });

  // node_modules/ton/dist/keystore/KeyStore.js
  var require_KeyStore = __commonJS({
    "node_modules/ton/dist/keystore/KeyStore.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _KeyStore_salt;
      var _KeyStore_publicKey;
      var _KeyStore_records;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyStore = exports.createKeyStoreKey = void 0;
      var ton_crypto_1 = require_dist();
      var t = __importStar(require_lib());
      var Either_1 = require_Either();
      var __1 = require_dist2();
      var tweetnacl_1 = __importDefault(require_nacl_fast());
      var codec = t.type({
        version: t.number,
        salt: t.string,
        publicKey: t.string,
        records: t.array(t.type({
          name: t.string,
          address: t.string,
          kind: t.string,
          config: t.string,
          publicKey: t.string,
          secretKey: t.string,
          comment: t.string
        }))
      });
      function createKeyStoreKey(password, salt) {
        return __async(this, null, function* () {
          let secretKey = yield (0, ton_crypto_1.pbkdf2_sha512)(password, salt, 4e5, 32);
          let r = tweetnacl_1.default.box.keyPair.fromSecretKey(secretKey);
          return {
            secretKey: Buffer.from(r.secretKey),
            publicKey: Buffer.from(r.publicKey)
          };
        });
      }
      exports.createKeyStoreKey = createKeyStoreKey;
      var KeyStore = class {
        constructor(src) {
          _KeyStore_salt.set(this, void 0);
          _KeyStore_publicKey.set(this, void 0);
          _KeyStore_records.set(this, /* @__PURE__ */ new Map());
          this.checkPassword = (password) => __async(this, null, function* () {
            let key = yield createKeyStoreKey(password, Buffer.from(__classPrivateFieldGet(this, _KeyStore_salt, "f"), "hex"));
            if (!key.publicKey.equals(Buffer.from(__classPrivateFieldGet(this, _KeyStore_publicKey, "f"), "hex"))) {
              return false;
            } else {
              return true;
            }
          });
          this.hasKey = (name) => {
            return __classPrivateFieldGet(this, _KeyStore_records, "f").has(name);
          };
          this.getKey = (name) => {
            let ex = __classPrivateFieldGet(this, _KeyStore_records, "f").get(name);
            if (ex) {
              return {
                name: ex.name,
                address: ex.address,
                kind: ex.kind,
                config: ex.config,
                comment: ex.comment,
                publicKey: Buffer.from(ex.publicKey, "hex")
              };
            }
            return null;
          };
          this.getSecret = (name, password) => __async(this, null, function* () {
            if (!__classPrivateFieldGet(this, _KeyStore_records, "f").has(name)) {
              throw Error("Key with name " + name + " does not exist");
            }
            let record = __classPrivateFieldGet(this, _KeyStore_records, "f").get(name);
            let src2 = Buffer.from(record.secretKey, "hex");
            let nonce = src2.slice(0, 24);
            let publicKey = src2.slice(24, 24 + 32);
            let data = src2.slice(24 + 32);
            let key = yield createKeyStoreKey(password, Buffer.from(__classPrivateFieldGet(this, _KeyStore_salt, "f"), "hex"));
            if (!key.publicKey.equals(Buffer.from(__classPrivateFieldGet(this, _KeyStore_publicKey, "f"), "hex"))) {
              throw Error("Invalid password");
            }
            let decoded = tweetnacl_1.default.box.open(data, nonce, publicKey, key.secretKey);
            if (!decoded) {
              throw Error("Invalid password");
            }
            return Buffer.from(decoded);
          });
          this.addKey = (record, key) => __async(this, null, function* () {
            if (__classPrivateFieldGet(this, _KeyStore_records, "f").has(record.name)) {
              throw Error("Key with name " + record.name + " already exists");
            }
            let ephemeralKeySecret = yield (0, ton_crypto_1.getSecureRandomBytes)(32);
            let ephemeralKeyPublic = Buffer.from(tweetnacl_1.default.box.keyPair.fromSecretKey(ephemeralKeySecret).publicKey);
            let nonce = yield (0, ton_crypto_1.getSecureRandomBytes)(24);
            let encrypted = tweetnacl_1.default.box(key, nonce, Buffer.from(__classPrivateFieldGet(this, _KeyStore_publicKey, "f"), "hex"), ephemeralKeySecret);
            let data = Buffer.concat([nonce, ephemeralKeyPublic, encrypted]);
            let rec = {
              name: record.name,
              address: record.address,
              kind: record.kind,
              config: record.config,
              comment: record.comment,
              publicKey: record.publicKey.toString("hex"),
              secretKey: data.toString("hex")
            };
            Object.freeze(rec);
            __classPrivateFieldGet(this, _KeyStore_records, "f").set(record.name, rec);
          });
          this.removeKey = (name) => {
            if (!__classPrivateFieldGet(this, _KeyStore_records, "f").has(name)) {
              throw Error("Key with name " + name + " does not exist");
            }
            __classPrivateFieldGet(this, _KeyStore_records, "f").delete(name);
          };
          if (src.version !== 1) {
            throw Error("Unsupported keystore");
          }
          __classPrivateFieldSet(this, _KeyStore_salt, src.salt, "f");
          __classPrivateFieldSet(this, _KeyStore_publicKey, src.publicKey, "f");
          for (let r of src.records) {
            if (__classPrivateFieldGet(this, _KeyStore_records, "f").has(r.name)) {
              throw Error("Broken keystore");
            }
            const record = {
              name: r.name,
              address: __1.Address.parseRaw(r.address),
              kind: r.kind,
              config: r.config,
              comment: r.comment,
              publicKey: r.publicKey,
              secretKey: r.secretKey
            };
            Object.freeze(record);
            __classPrivateFieldGet(this, _KeyStore_records, "f").set(r.name, record);
          }
        }
        static createNew(password) {
          return __async(this, null, function* () {
            let salt = yield (0, ton_crypto_1.getSecureRandomBytes)(32);
            let key = yield createKeyStoreKey(password, salt);
            return new KeyStore({ version: 1, salt: salt.toString("hex"), publicKey: key.publicKey.toString("hex"), records: [] });
          });
        }
        static load(source) {
          return __async(this, null, function* () {
            if (source.length < 32) {
              throw Error("Broken keystore");
            }
            let hash = source.slice(0, 32);
            let data = source.slice(32);
            let hash2 = yield (0, ton_crypto_1.sha256)(data);
            if (!hash.equals(hash2)) {
              throw Error("Broken keystore");
            }
            let parsed = JSON.parse(data.toString("utf-8"));
            let decoded = codec.decode(parsed);
            if ((0, Either_1.isLeft)(decoded)) {
              throw Error("Broken keystore");
            }
            return new KeyStore(decoded.right);
          });
        }
        get allKeys() {
          let res = [];
          for (let k of __classPrivateFieldGet(this, _KeyStore_records, "f").keys()) {
            let r = __classPrivateFieldGet(this, _KeyStore_records, "f").get(k);
            res.push({
              name: r.name,
              address: r.address,
              kind: r.kind,
              config: r.config,
              comment: r.comment,
              publicKey: Buffer.from(r.publicKey, "hex")
            });
          }
          return res;
        }
        save() {
          return __async(this, null, function* () {
            let store = {
              version: 1,
              salt: __classPrivateFieldGet(this, _KeyStore_salt, "f"),
              publicKey: __classPrivateFieldGet(this, _KeyStore_publicKey, "f"),
              records: Array.from(__classPrivateFieldGet(this, _KeyStore_records, "f").entries()).map((v) => ({
                name: v[1].name,
                address: v[1].address.toString(),
                kind: v[1].kind,
                config: v[1].config,
                comment: v[1].comment,
                publicKey: v[1].publicKey,
                secretKey: v[1].secretKey
              }))
            };
            let data = Buffer.from(JSON.stringify(store), "utf-8");
            let hash = yield (0, ton_crypto_1.sha256)(data);
            return Buffer.concat([hash, data]);
          });
        }
      };
      exports.KeyStore = KeyStore;
      _KeyStore_salt = /* @__PURE__ */ new WeakMap(), _KeyStore_publicKey = /* @__PURE__ */ new WeakMap(), _KeyStore_records = /* @__PURE__ */ new WeakMap();
    }
  });

  // node_modules/ton/dist/boc/Slice.js
  var require_Slice = __commonJS({
    "node_modules/ton/dist/boc/Slice.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Slice = void 0;
      var __1 = require_dist2();
      var Slice = class {
        constructor(sourceBits, sourceRefs) {
          this.refs = [];
          this.skip = (bits) => {
            this.bits.skip(bits);
          };
          this.readUint = (bits) => {
            return this.bits.readUint(bits);
          };
          this.readUintNumber = (bits) => {
            return this.bits.readUintNumber(bits);
          };
          this.readInt = (bits) => {
            return this.bits.readInt(bits);
          };
          this.readIntNumber = (bits) => {
            return this.bits.readIntNumber(bits);
          };
          this.readBuffer = (size) => {
            return this.bits.readBuffer(size);
          };
          this.readBit = () => {
            return this.bits.readBit();
          };
          this.readCoins = () => {
            return this.bits.readCoins();
          };
          this.readVarUInt = (headerBits) => {
            return this.bits.readVarUInt(headerBits);
          };
          this.readVarUIntNumber = (headerBits) => {
            return this.bits.readVarUIntNumber(headerBits);
          };
          this.readRemaining = () => {
            return this.bits.readRemaining();
          };
          this.readRemainingBytes = () => {
            if (this.bits.remaining % 8 !== 0) {
              throw Error("Number remaining of bits is not multiply of 8");
            }
            return this.bits.readBuffer(this.bits.remaining / 8);
          };
          this.readAddress = () => {
            return this.bits.readAddress();
          };
          this.readAddressInternal = () => {
            return this.bits.readAddressInternal();
          };
          this.readAddressExternal = () => {
            return this.bits.readAddressExternal();
          };
          this.readUnaryLength = () => {
            return this.bits.readUnaryLength();
          };
          this.readBitString = (n) => {
            return this.bits.readBitString(n);
          };
          this.readOptDict = (keySize, extractor) => {
            if (this.readBit()) {
              return this.readDict(keySize, extractor);
            } else {
              return null;
            }
          };
          this.readDict = (keySize, extractor) => {
            let first = this.refs.shift();
            if (first) {
              return (0, __1.parseDict)(first.beginParse(), keySize, extractor);
            } else {
              throw Error("No ref");
            }
          };
          this.readRef = () => {
            let first = this.refs.shift();
            if (first) {
              return Slice.fromCell(first);
            } else {
              throw Error("No ref");
            }
          };
          this.readCell = () => {
            let first = this.refs.shift();
            if (first) {
              return first;
            } else {
              throw Error("No ref");
            }
          };
          this.preloadCell = () => {
            let first = this.refs[0];
            if (first) {
              return first;
            } else {
              throw Error("No ref");
            }
          };
          this.clone = () => {
            const cloned = this.sourceBits.clone();
            const reader = new __1.BitStringReader(cloned);
            reader.skip(this.bits.currentOffset);
            const remaining = reader.readRemaining();
            const remainingRefs = [...this.refs];
            return new Slice(remaining, remainingRefs);
          };
          this.toCell = () => {
            const cloned = this.sourceBits.clone();
            const reader = new __1.BitStringReader(cloned);
            reader.skip(this.bits.currentOffset);
            const remaining = reader.readRemaining();
            let cell = new __1.Cell("ordinary", remaining);
            for (let r of this.refs) {
              cell.refs.push(r);
            }
            return cell;
          };
          this.sourceBits = sourceBits.clone();
          this.refs = [...sourceRefs];
          this.bits = new __1.BitStringReader(this.sourceBits);
        }
        static fromCell(cell) {
          if (cell.isExotic) {
            throw Error("Unable to create slice from exotic");
          }
          return new Slice(cell.bits, cell.refs);
        }
        get remaining() {
          return this.bits.remaining;
        }
        get remainingRefs() {
          return this.refs.length;
        }
      };
      exports.Slice = Slice;
    }
  });

  // node_modules/ton/dist/utils/base32.js
  var require_base32 = __commonJS({
    "node_modules/ton/dist/utils/base32.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.base32Decode = exports.base32Encode = void 0;
      var alphabet = "abcdefghijklmnopqrstuvwxyz234567";
      function base32Encode(buffer) {
        const length = buffer.byteLength;
        let bits = 0;
        let value = 0;
        let output = "";
        for (let i = 0; i < length; i++) {
          value = value << 8 | buffer[i];
          bits += 8;
          while (bits >= 5) {
            output += alphabet[value >>> bits - 5 & 31];
            bits -= 5;
          }
        }
        if (bits > 0) {
          output += alphabet[value << 5 - bits & 31];
        }
        return output;
      }
      exports.base32Encode = base32Encode;
      function readChar(alphabet2, char) {
        const idx = alphabet2.indexOf(char);
        if (idx === -1) {
          throw new Error("Invalid character found: " + char);
        }
        return idx;
      }
      function base32Decode(input) {
        let cleanedInput;
        cleanedInput = input.toLowerCase();
        const { length } = cleanedInput;
        let bits = 0;
        let value = 0;
        let index = 0;
        const output = Buffer.alloc(length * 5 / 8 | 0);
        for (let i = 0; i < length; i++) {
          value = value << 5 | readChar(alphabet, cleanedInput[i]);
          bits += 5;
          if (bits >= 8) {
            output[index++] = value >>> bits - 8 & 255;
            bits -= 8;
          }
        }
        return output;
      }
      exports.base32Decode = base32Decode;
    }
  });

  // node_modules/ton/dist/address/ADNLAddress.js
  var require_ADNLAddress = __commonJS({
    "node_modules/ton/dist/address/ADNLAddress.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ADNLAddress = void 0;
      var symbol_inspect_1 = __importDefault(require_symbol());
      var base32_1 = require_base32();
      var crc16_1 = require_crc16();
      var ADNLAddress = class {
        constructor(address) {
          this.toString = () => {
            return this.toFriendly();
          };
          this.toRaw = () => {
            return this.address.toString("hex").toUpperCase();
          };
          this.toFriendly = () => {
            let data = Buffer.concat([Buffer.from([45]), this.address]);
            let hash = (0, crc16_1.crc16)(data);
            data = Buffer.concat([data, hash]);
            return (0, base32_1.base32Encode)(data).slice(1);
          };
          this[_a] = () => this.toFriendly();
          if (address.length !== 32) {
            throw Error("Invalid address");
          }
          this.address = address;
        }
        static parseFriendly(src) {
          if (src.length !== 55) {
            throw Error("Invalid address");
          }
          src = "f" + src;
          let decoded = (0, base32_1.base32Decode)(src);
          if (decoded[0] !== 45) {
            throw Error("Invalid address");
          }
          let gotHash = decoded.slice(33);
          let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));
          if (!hash.equals(gotHash)) {
            throw Error("Invalid address");
          }
          return new ADNLAddress(decoded.slice(1, 33));
        }
        static parseRaw(src) {
          const data = Buffer.from(src, "base64");
          return new ADNLAddress(data);
        }
        equals(b) {
          return this.address.equals(b.address);
        }
      };
      exports.ADNLAddress = ADNLAddress;
      _a = symbol_inspect_1.default;
    }
  });

  // node_modules/ton/dist/keystore/ADNLKey.js
  var require_ADNLKey = __commonJS({
    "node_modules/ton/dist/keystore/ADNLKey.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ADNLKey = void 0;
      var ton_crypto_1 = require_dist();
      var ADNLAddress_1 = require_ADNLAddress();
      var KEY_PREFIX = Buffer.from("17236849", "hex");
      var ADNLKey = class {
        constructor(address, keyPair) {
          this.address = address;
          this.keyPair = keyPair;
        }
        static fromKey(src) {
          return __async(this, null, function* () {
            if (src.length !== 36) {
              throw Error("Invalid key");
            }
            if (!src.slice(0, 4).equals(KEY_PREFIX)) {
              throw Error("Invalid key");
            }
            const keySeed = src.slice(4);
            const keyPair = (0, ton_crypto_1.keyPairFromSeed)(keySeed);
            const address = yield (0, ton_crypto_1.sha256)(Buffer.concat([Buffer.from([198, 180, 19, 72]), keyPair.publicKey]));
            return new ADNLKey(new ADNLAddress_1.ADNLAddress(address), keyPair);
          });
        }
      };
      exports.ADNLKey = ADNLKey;
    }
  });

  // node_modules/ton/dist/boc/dict/utils/findCommonPrefix.js
  var require_findCommonPrefix = __commonJS({
    "node_modules/ton/dist/boc/dict/utils/findCommonPrefix.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.findCommonPrefix = void 0;
      function findCommonPrefix(src) {
        if (src.length === 0) {
          return "";
        }
        if (src.length === 1) {
          return src[0];
        }
        const sorted = [...src].sort();
        let size = 0;
        for (let i = 0; i < sorted[0].length; i++) {
          if (sorted[0][i] !== sorted[sorted.length - 1][i]) {
            break;
          }
          size++;
        }
        return src[0].slice(0, size);
      }
      exports.findCommonPrefix = findCommonPrefix;
    }
  });

  // node_modules/ton/dist/boc/dict/serializeDict.js
  var require_serializeDict = __commonJS({
    "node_modules/ton/dist/boc/dict/serializeDict.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.serializeDict = exports.detectLabelType = exports.writeLabelSame = exports.writeLabelLong = exports.writeLabelShort = exports.buildTree = void 0;
      var bn_js_1 = require_bn();
      var Cell_1 = require_Cell();
      var findCommonPrefix_1 = require_findCommonPrefix();
      function pad(src, size) {
        while (src.length < size) {
          src = "0" + src;
        }
        return src;
      }
      function removePrefixMap(src, length) {
        if (length === 0) {
          return src;
        } else {
          let res = /* @__PURE__ */ new Map();
          for (let k of src.keys()) {
            let d = src.get(k);
            res.set(k.slice(length), d);
          }
          return res;
        }
      }
      function forkMap(src) {
        if (src.size === 0) {
          throw Error("Internal inconsistency");
        }
        let left = /* @__PURE__ */ new Map();
        let right = /* @__PURE__ */ new Map();
        for (let k of src.keys()) {
          let d = src.get(k);
          if (k.startsWith("0")) {
            left.set(k.substr(1), d);
          } else {
            right.set(k.substr(1), d);
          }
        }
        if (left.size === 0) {
          throw Error("Internal inconsistency. Left emtpy.");
        }
        if (right.size === 0) {
          throw Error("Internal inconsistency. Right emtpy.");
        }
        return { left, right };
      }
      function buildNode(src) {
        if (src.size === 0) {
          throw Error("Internal inconsistency");
        }
        if (src.size === 1) {
          return { type: "leaf", value: Array.from(src.values())[0] };
        }
        let { left, right } = forkMap(src);
        return {
          type: "fork",
          left: buildEdge(left),
          right: buildEdge(right)
        };
      }
      function buildEdge(src) {
        if (src.size === 0) {
          throw Error("Internal inconsistency");
        }
        const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src.keys()));
        return { label, node: buildNode(removePrefixMap(src, label.length)) };
      }
      function buildTree(src, keyLength) {
        let converted = /* @__PURE__ */ new Map();
        for (let k of Array.from(src.keys())) {
          const padded = pad(new bn_js_1.BN(k).toString(2), keyLength);
          converted.set(padded, src.get(k));
        }
        return buildEdge(converted);
      }
      exports.buildTree = buildTree;
      function writeLabelShort(src, to) {
        to.writeBit(0);
        for (let i = 0; i < src.length; i++) {
          to.writeBit(1);
        }
        to.writeBit(0);
        for (let i = 0; i < src.length; i++) {
          to.writeBit(src[i] === "1");
        }
        return to;
      }
      exports.writeLabelShort = writeLabelShort;
      function labelShortLength(src) {
        return 1 + src.length + 1 + src.length;
      }
      function writeLabelLong(src, keyLength, to) {
        to.writeBit(1);
        to.writeBit(0);
        let length = Math.ceil(Math.log2(keyLength + 1));
        to.writeUint(src.length, length);
        for (let i = 0; i < src.length; i++) {
          to.writeBit(src[i] === "1");
        }
        return to;
      }
      exports.writeLabelLong = writeLabelLong;
      function labelLongLength(src, keyLength) {
        return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src.length;
      }
      function writeLabelSame(value, length, keyLength, to) {
        to.writeBit(1);
        to.writeBit(1);
        to.writeBit(value);
        let lenLen = Math.ceil(Math.log2(keyLength + 1));
        to.writeUint(length, lenLen);
      }
      exports.writeLabelSame = writeLabelSame;
      function labelSameLength(keyLength) {
        return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));
      }
      function isSame(src) {
        if (src.length === 0 || src.length === 1) {
          return true;
        }
        for (let i = 1; i < src.length; i++) {
          if (src[i] !== src[0]) {
            return false;
          }
        }
        return true;
      }
      function detectLabelType(src, keyLength) {
        let kind = "short";
        let kindLength = labelShortLength(src);
        let longLength = labelLongLength(src, keyLength);
        if (longLength < kindLength) {
          kindLength = longLength;
          kind = "long";
        }
        if (isSame(src)) {
          let sameLength = labelSameLength(keyLength);
          if (sameLength < kindLength) {
            kindLength = sameLength;
            kind = "same";
          }
        }
        return kind;
      }
      exports.detectLabelType = detectLabelType;
      function writeLabel(src, keyLength, to) {
        let type = detectLabelType(src, keyLength);
        if (type === "short") {
          writeLabelShort(src, to);
        }
        if (type === "long") {
          writeLabelLong(src, keyLength, to);
        }
        if (type === "same") {
          writeLabelSame(src[0] === "1", src.length, keyLength, to);
        }
      }
      function writeNode(src, keyLength, serializer, to) {
        if (src.type === "leaf") {
          serializer(src.value, to);
        }
        if (src.type === "fork") {
          const leftCell = new Cell_1.Cell();
          const rightCell = new Cell_1.Cell();
          writeEdge(src.left, keyLength - 1, serializer, leftCell);
          writeEdge(src.right, keyLength - 1, serializer, rightCell);
          to.refs.push(leftCell);
          to.refs.push(rightCell);
        }
      }
      function writeEdge(src, keyLength, serializer, to) {
        writeLabel(src.label, keyLength, to.bits);
        writeNode(src.node, keyLength - src.label.length, serializer, to);
      }
      function serializeDict(src, keyLength, serializer) {
        const tree = buildTree(src, keyLength);
        const dest = new Cell_1.Cell();
        writeEdge(tree, keyLength, serializer, dest);
        return dest;
      }
      exports.serializeDict = serializeDict;
    }
  });

  // node_modules/ton/dist/boc/DictBuilder.js
  var require_DictBuilder = __commonJS({
    "node_modules/ton/dist/boc/DictBuilder.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.beginDict = exports.DictBuilder = void 0;
      var bn_js_1 = __importDefault(require_bn());
      var Builder_1 = require_Builder();
      var serializeDict_1 = require_serializeDict();
      var DictBuilder = class {
        constructor(keySize) {
          this.items = /* @__PURE__ */ new Map();
          this.ended = false;
          this.storeCell = (index, value) => {
            if (this.ended) {
              throw Error("Already ended");
            }
            let key;
            if (typeof index === "number") {
              key = index.toString(10);
            } else if (bn_js_1.default.isBN(index)) {
              key = index.toString(10);
            } else if (Buffer.isBuffer(index)) {
              key = new bn_js_1.default(index.toString("hex"), "hex").toString(10);
            } else {
              throw Error("Invalid index type");
            }
            if (this.items.has(key)) {
              throw Error("Item " + index + " already exist");
            }
            this.items.set(key, value);
          };
          this.storeRef = (index, value) => {
            if (this.ended) {
              throw Error("Already ended");
            }
            this.storeCell(index, (0, Builder_1.beginCell)().storeRef(value).endCell());
          };
          this.endDict = () => {
            if (this.ended) {
              throw Error("Already ended");
            }
            this.ended = true;
            if (this.items.size === 0) {
              return null;
            }
            return (0, serializeDict_1.serializeDict)(this.items, this.keySize, (src, dst) => dst.writeCell(src));
          };
          this.endCell = () => {
            if (this.ended) {
              throw Error("Already ended");
            }
            if (this.items.size === 0) {
              throw Error("Dict is empty");
            }
            return this.endDict();
          };
          this.keySize = keySize;
        }
      };
      exports.DictBuilder = DictBuilder;
      function beginDict(keyLength) {
        return new DictBuilder(keyLength);
      }
      exports.beginDict = beginDict;
    }
  });

  // node_modules/ton/dist/utils/bnToAddress.js
  var require_bnToAddress = __commonJS({
    "node_modules/ton/dist/utils/bnToAddress.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bnToAddress = void 0;
      var Address_1 = require_Address();
      function bnToAddress(chain, bn) {
        let r = bn.toString("hex");
        while (r.length < 64) {
          r = "0" + r;
        }
        return new Address_1.Address(chain, Buffer.from(r, "hex"));
      }
      exports.bnToAddress = bnToAddress;
    }
  });

  // node_modules/ton/dist/boc/TupleSlice.js
  var require_TupleSlice = __commonJS({
    "node_modules/ton/dist/boc/TupleSlice.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TupleSlice = void 0;
      var bn_js_1 = require_bn();
      var bnToAddress_1 = require_bnToAddress();
      var Cell_1 = require_Cell();
      var TupleSlice = class {
        constructor(items) {
          this.items = [...items];
        }
        get remaining() {
          return this.items.length;
        }
        readNumber() {
          if (this.items[0][0] !== "num") {
            throw Error("Not a number");
          }
          let res = parseInt(this.items[0][1]);
          this.items.splice(0, 1);
          return res;
        }
        readBoolean() {
          if (this.items[0][0] !== "num") {
            throw Error("Not a number");
          }
          let res = parseInt(this.items[0][1]);
          this.items.splice(0, 1);
          return res === 0 ? false : true;
        }
        readBigNumber() {
          if (this.items[0][0] !== "num") {
            throw Error("Not a number");
          }
          let res = new bn_js_1.BN(this.items[0][1].slice(2), "hex");
          this.items.splice(0, 1);
          return res;
        }
        readCell() {
          if (this.items[0][0] !== "cell") {
            throw Error("Not a cell");
          }
          let res = Cell_1.Cell.fromBoc(Buffer.from(this.items[0][1].bytes, "base64"))[0];
          this.items.splice(0, 1);
          return res;
        }
        readNumericAddress(chain) {
          if (this.items[0][0] !== "num") {
            throw Error("Not a number");
          }
          let bn = this.readBigNumber();
          return (0, bnToAddress_1.bnToAddress)(chain, bn);
        }
      };
      exports.TupleSlice = TupleSlice;
    }
  });

  // node_modules/ton/dist/boc/TupleSlice4.js
  var require_TupleSlice4 = __commonJS({
    "node_modules/ton/dist/boc/TupleSlice4.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TupleSlice4 = void 0;
      var TupleSlice4 = class {
        constructor(items) {
          this.items = [...items];
        }
        get remaining() {
          return this.items.length;
        }
        pop() {
          if (this.items.length === 0) {
            throw Error("EOF");
          }
          let res = this.items[0];
          this.items.splice(0, 1);
          return res;
        }
        readBigNumber() {
          let popped = this.pop();
          if (popped.type !== "int") {
            throw Error("Not a number");
          }
          return popped.value;
        }
        readNumber() {
          return this.readBigNumber().toNumber();
        }
        readBoolean() {
          let res = this.readNumber();
          return res === 0 ? false : true;
        }
        readAddress() {
          return this.readCell().beginParse().readAddress();
        }
        readCell() {
          let popped = this.pop();
          if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
            throw Error("Not a cell");
          }
          return popped.cell;
        }
        readTuple() {
          let popped = this.pop();
          if (popped.type !== "tuple") {
            throw Error("Not a number");
          }
          return new TupleSlice4(popped.items);
        }
      };
      exports.TupleSlice4 = TupleSlice4;
    }
  });

  // node_modules/ton/dist/introspection/getSupportedInterfaces.js
  var require_getSupportedInterfaces = __commonJS({
    "node_modules/ton/dist/introspection/getSupportedInterfaces.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getSupportedInterfaces = exports.getSupportedInterfacesRaw = exports.resolveKnownInterface = void 0;
      var TupleSlice_1 = require_TupleSlice();
      var known = {
        ["123515602279859691144772641439386770278"]: "org.ton.introspection.v0",
        ["256184278959413194623484780286929323492"]: "com.tonwhales.nominators:v0",
        ["242422353946785872806511191513850808027"]: "org.ton.jetton.master.v1",
        ["311736387032003861293477945447179662681"]: "org.ton.jetton.wallet.v1"
      };
      function resolveKnownInterface(src) {
        let kn = known[src];
        if (kn) {
          return kn;
        } else {
          return null;
        }
      }
      exports.resolveKnownInterface = resolveKnownInterface;
      function getSupportedInterfacesRaw(src, client) {
        return __async(this, null, function* () {
          let res = yield client.callGetMethodWithError(src, "supported_interfaces");
          if (res.exit_code !== 0 && res.exit_code !== 1) {
            return [];
          }
          try {
            let slice = new TupleSlice_1.TupleSlice(res.stack);
            let firstNumber = slice.readBigNumber().toString();
            if (firstNumber !== "123515602279859691144772641439386770278") {
              return [];
            }
            let interfaces = [];
            while (slice.remaining > 0) {
              interfaces.push(slice.readBigNumber().toString());
            }
            return interfaces;
          } catch (e) {
            console.warn(e);
            return [];
          }
        });
      }
      exports.getSupportedInterfacesRaw = getSupportedInterfacesRaw;
      function getSupportedInterfaces(src, client) {
        return __async(this, null, function* () {
          let supprotedRaw = yield getSupportedInterfacesRaw(src, client);
          return supprotedRaw.map((v) => {
            let k = resolveKnownInterface(v);
            if (k) {
              return { type: "known", name: k };
            } else {
              return { type: "unknown", value: v };
            }
          });
        });
      }
      exports.getSupportedInterfaces = getSupportedInterfaces;
    }
  });

  // node_modules/ton/dist/utils/crc32.js
  var require_crc32 = __commonJS({
    "node_modules/ton/dist/utils/crc32.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crc32str = exports.crc32 = void 0;
      var POLYNOMIAL = -306674912;
      var crc32_table = void 0;
      function calcTable() {
        crc32_table = new Int32Array(256);
        for (let i = 0; i < 256; i++) {
          let r = i;
          for (let bit = 8; bit > 0; --bit)
            r = r & 1 ? r >>> 1 ^ POLYNOMIAL : r >>> 1;
          crc32_table[i] = r;
        }
      }
      function crc32(bytes) {
        let crc = 4294967295;
        if (crc32_table === void 0) {
          calcTable();
        }
        for (let i = 0; i < bytes.length; ++i)
          crc = crc32_table[(crc ^ bytes[i]) & 255] ^ crc >>> 8;
        return (crc ^ -1) >>> 0;
      }
      exports.crc32 = crc32;
      function crc32str(src) {
        return crc32(Buffer.from(src));
      }
      exports.crc32str = crc32str;
    }
  });

  // node_modules/ton/dist/introspection/parseSupportedMessage.js
  var require_parseSupportedMessage = __commonJS({
    "node_modules/ton/dist/introspection/parseSupportedMessage.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseSupportedMessage = void 0;
      var crc32_1 = require_crc32();
      function parseNominatorsMessage(op, sc) {
        if (op === (0, crc32_1.crc32str)("op::stake_deposit")) {
          let queryId = sc.readUint(64);
          let gasLimit = sc.readCoins().toNumber();
          return {
            type: "deposit",
            data: {
              "query_id": queryId,
              "gas_limit": gasLimit
            }
          };
        }
        if (op === (0, crc32_1.crc32str)("op::stake_deposit::response")) {
          return {
            type: "deposit::ok",
            data: {}
          };
        }
        if (op === (0, crc32_1.crc32str)("op::stake_withdraw")) {
          let queryId = sc.readUint(64);
          let gasLimit = sc.readCoins().toNumber();
          const stake = sc.readCoins();
          return {
            type: "withdraw",
            data: {
              "stake": stake,
              "query_id": queryId,
              "gas_limit": gasLimit
            }
          };
        }
        if (op === (0, crc32_1.crc32str)("op::stake_withdraw::delayed")) {
          return {
            type: "withdraw::delayed",
            data: {}
          };
        }
        if (op === (0, crc32_1.crc32str)("op::stake_withdraw::response")) {
          return {
            type: "withdraw::ok",
            data: {}
          };
        }
        if (op === (0, crc32_1.crc32str)("op::upgrade")) {
          let queryId = sc.readUint(64);
          let gasLimit = sc.readCoins().toNumber();
          const code = sc.readCell();
          return {
            type: "upgrade",
            data: {
              "code": code,
              "query_id": queryId,
              "gas_limit": gasLimit
            }
          };
        }
        if (op === (0, crc32_1.crc32str)("op::upgrade::response")) {
          return {
            type: "upgrade::ok",
            data: {}
          };
        }
        if (op === (0, crc32_1.crc32str)("op::upgrade")) {
          let queryId = sc.readUint(64);
          let gasLimit = sc.readCoins().toNumber();
          const code = sc.readCell();
          return {
            type: "upgrade",
            data: {
              "code": code,
              "query_id": queryId,
              "gas_limit": gasLimit
            }
          };
        }
        if (op === (0, crc32_1.crc32str)("op::upgrade::ok")) {
          return {
            type: "upgrade::ok",
            data: {}
          };
        }
        if (op === (0, crc32_1.crc32str)("op::update")) {
          let queryId = sc.readUint(64);
          let gasLimit = sc.readCoins().toNumber();
          const params = sc.readCell();
          return {
            type: "update",
            data: {
              "code": params,
              "query_id": queryId,
              "gas_limit": gasLimit
            }
          };
        }
        if (op === (0, crc32_1.crc32str)("op::update::ok")) {
          return {
            type: "update::ok",
            data: {}
          };
        }
        return null;
      }
      function parseJettonWallet(op, sc) {
        if (op === 3576854235) {
          let queryId = sc.readUint(64);
          return {
            type: "jetton::excesses",
            data: {
              "query_id": queryId
            }
          };
        }
        if (op === 260734629) {
          let queryId = sc.readUint(64);
          let amount = sc.readCoins();
          let destination = sc.readAddress();
          let responseDestination = sc.readAddress();
          let customPayload = sc.readBit() ? sc.readCell() : null;
          let forwardTonAmount = sc.readCoins();
          let forwardPayload = sc.readBit() ? sc.readCell() : sc.toCell();
          return {
            type: "jetton::transfer",
            data: {
              "query_id": queryId,
              "amount": amount,
              "destination": destination,
              "response_destination": responseDestination,
              "custom_payload": customPayload,
              "forward_ton": forwardTonAmount,
              "payload": forwardPayload
            }
          };
        }
        if (op === 1935855772) {
          let queryId = sc.readUint(64);
          let amount = sc.readCoins();
          let sender = sc.readAddress();
          let forwardPayload = sc.readBit() ? sc.readCell() : sc.toCell();
          return {
            type: "jetton::transfer_notification",
            data: {
              "query_id": queryId,
              "amount": amount,
              "sender": sender,
              "payload": forwardPayload
            }
          };
        }
        return null;
      }
      function parseJettonMaster(op, sc) {
        return null;
      }
      function parseSupportedMessage(knownInteface, message) {
        try {
          let sc = message.beginParse();
          if (sc.remaining < 32) {
            return null;
          }
          let op = sc.readUintNumber(32);
          if (op === 0) {
            return null;
          }
          if (knownInteface === "com.tonwhales.nominators:v0") {
            return parseNominatorsMessage(op, sc);
          }
          if (knownInteface === "org.ton.jetton.wallet.v1") {
            return parseJettonWallet(op, sc);
          }
          if (knownInteface === "org.ton.jetton.master.v1") {
            return parseJettonMaster(op, sc);
          }
        } catch (e) {
          console.warn(e);
        }
        return null;
      }
      exports.parseSupportedMessage = parseSupportedMessage;
    }
  });

  // node_modules/ton/dist/messages/CellMessage.js
  var require_CellMessage = __commonJS({
    "node_modules/ton/dist/messages/CellMessage.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CellMessage = void 0;
      var CellMessage = class {
        constructor(cell) {
          this.cell = cell;
        }
        writeTo(cell) {
          cell.writeCell(this.cell);
        }
      };
      exports.CellMessage = CellMessage;
    }
  });

  // node_modules/ton/dist/messages/EmptyMessage.js
  var require_EmptyMessage = __commonJS({
    "node_modules/ton/dist/messages/EmptyMessage.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EmptyMessage = void 0;
      var EmptyMessage = class {
        writeTo(cell) {
        }
      };
      exports.EmptyMessage = EmptyMessage;
    }
  });

  // node_modules/ton/dist/messages/CommentMessage.js
  var require_CommentMessage = __commonJS({
    "node_modules/ton/dist/messages/CommentMessage.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommentMessage = void 0;
      var Cell_1 = require_Cell();
      var CommentMessage = class {
        constructor(comment) {
          this.comment = comment;
        }
        writeTo(cell) {
          if (this.comment.length > 0) {
            cell.bits.writeUint(0, 32);
            let bytes = Buffer.from(this.comment);
            let dest = cell;
            while (bytes.length > 0) {
              let avaliable = Math.floor(dest.bits.available / 8);
              if (bytes.length <= avaliable) {
                dest.bits.writeBuffer(bytes);
                break;
              }
              dest.bits.writeBuffer(bytes.slice(0, avaliable));
              bytes = bytes.slice(avaliable, bytes.length);
              let nc = new Cell_1.Cell();
              dest.refs.push(nc);
              dest = nc;
            }
          }
        }
      };
      exports.CommentMessage = CommentMessage;
    }
  });

  // node_modules/ton/dist/messages/BinaryMessage.js
  var require_BinaryMessage = __commonJS({
    "node_modules/ton/dist/messages/BinaryMessage.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BinaryMessage = void 0;
      var BinaryMessage = class {
        constructor(payload) {
          this.payload = payload;
        }
        writeTo(cell) {
          cell.bits.writeBuffer(this.payload);
        }
      };
      exports.BinaryMessage = BinaryMessage;
    }
  });

  // node_modules/ton/dist/contracts/sources/UnknownContractSource.js
  var require_UnknownContractSource = __commonJS({
    "node_modules/ton/dist/contracts/sources/UnknownContractSource.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UnknownContractSource = void 0;
      var UnknownContractSource = class {
        constructor(type, workchain, description) {
          this.backup = () => {
            throw Error("Unknown");
          };
          this.describe = () => {
            return this.description;
          };
          this.type = type;
          this.workchain = workchain;
          this.description = description;
        }
        get initialCode() {
          throw Error("Unknown");
        }
        get initialData() {
          throw Error("Unknown");
        }
      };
      exports.UnknownContractSource = UnknownContractSource;
    }
  });

  // node_modules/ton/dist/contracts/sources/WalletV1R1Source.js
  var require_WalletV1R1Source = __commonJS({
    "node_modules/ton/dist/contracts/sources/WalletV1R1Source.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletV1R1Source = void 0;
      var __1 = require_dist2();
      var WalletV1R1Source = class {
        constructor(opts) {
          this.type = "org.ton.wallets.simple";
          this.walletVersion = "v1";
          this.backup = () => {
            const store = new __1.ConfigStore();
            store.setInt("wc", this.workchain);
            store.setBuffer("pk", this.publicKey);
            return store.save();
          };
          this.describe = () => {
            return "Simple Wallet Contract";
          };
          this.publicKey = opts.publicKey;
          this.initialCode = opts.initialCode;
          this.initialData = opts.initialData;
          this.workchain = opts.workchain;
          Object.freeze(this);
        }
        static create(opts) {
          let publicKey = opts.publicKey;
          let workchain = opts.workchain;
          let initialCode = __1.Cell.fromBoc("B5EE9C72410101010044000084FF0020DDA4F260810200D71820D70B1FED44D0D31FD3FFD15112BAF2A122F901541044F910F2A2F80001D31F3120D74A96D307D402FB00DED1A4C8CB1FCBFFC9ED5441FDF089")[0];
          let initialData = new __1.Cell();
          initialData.bits.writeUint(0, 32);
          initialData.bits.writeBuffer(publicKey);
          return new WalletV1R1Source({ publicKey, initialCode, initialData, workchain });
        }
        static restore(backup) {
          const store = new __1.ConfigStore(backup);
          return WalletV1R1Source.create({ publicKey: store.getBuffer("pk"), workchain: store.getInt("wc") });
        }
      };
      exports.WalletV1R1Source = WalletV1R1Source;
    }
  });

  // node_modules/ton/dist/utils/ConfigStore.js
  var require_ConfigStore = __commonJS({
    "node_modules/ton/dist/utils/ConfigStore.js"(exports) {
      "use strict";
      var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var _ConfigStore_map;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConfigStore = void 0;
      var __1 = require_dist2();
      var ConfigStore = class {
        constructor(source) {
          _ConfigStore_map.set(this, /* @__PURE__ */ new Map());
          this.getString = (key) => {
            let ex = __classPrivateFieldGet(this, _ConfigStore_map, "f").get(key);
            if (!ex) {
              throw Error("Unable to find key " + key);
            }
            return ex;
          };
          this.getBuffer = (key) => {
            return Buffer.from(this.getString(key), "hex");
          };
          this.getAddress = (key) => {
            return __1.Address.parseFriendly(this.getString(key)).address;
          };
          this.getInt = (key) => {
            return parseInt(this.getString(key));
          };
          this.setBuffer = (key, value) => {
            this.setString(key, value.toString("hex"));
          };
          this.setAddress = (key, address) => {
            this.setString(key, address.toFriendly());
          };
          if (source) {
            let parts = source.split(",");
            for (let p of parts) {
              let pp = p.split("=");
              if (pp.length !== 2) {
                throw Error("Mailformed input");
              }
              if (__classPrivateFieldGet(this, _ConfigStore_map, "f").has(pp[0])) {
                throw Error("Mailformed input");
              }
              __classPrivateFieldGet(this, _ConfigStore_map, "f").set(pp[0], pp[1]);
            }
          }
        }
        setString(key, value) {
          if (key.indexOf("=") >= 0 || key.indexOf(",") >= 0) {
            throw Error("Mailformed input");
          }
          if (value.indexOf("=") >= 0 || value.indexOf(",") >= 0) {
            throw Error("Mailformed input");
          }
          __classPrivateFieldGet(this, _ConfigStore_map, "f").set(key, value);
        }
        setInt(key, value) {
          this.setString(key, value.toString(10));
        }
        save() {
          let res = "";
          for (let e of __classPrivateFieldGet(this, _ConfigStore_map, "f")) {
            if (res !== "") {
              res += ",";
            }
            res += e[0] + "=" + e[1];
          }
          return res;
        }
      };
      exports.ConfigStore = ConfigStore;
      _ConfigStore_map = /* @__PURE__ */ new WeakMap();
    }
  });

  // node_modules/ton/dist/client/safeSign.js
  var require_safeSign = __commonJS({
    "node_modules/ton/dist/client/safeSign.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.safeSignVerify = exports.safeSign = void 0;
      var ton_crypto_1 = require_dist();
      var MIN_SEED_LENGTH = 8;
      var MAX_SEED_LENGTH = 64;
      function createSafeSignHash(cell, seed) {
        let seedData = Buffer.from(seed);
        if (seedData.length > MAX_SEED_LENGTH) {
          throw Error("Seed can	 be longer than 64 bytes");
        }
        if (seedData.length < MIN_SEED_LENGTH) {
          throw Error("Seed must be at least 8 bytes");
        }
        return (0, ton_crypto_1.sha256_sync)(Buffer.concat([Buffer.from([255, 255]), seedData, cell.hash()]));
      }
      function safeSign(cell, secretKey, seed = "ton-safe-sign-magic") {
        return (0, ton_crypto_1.sign)(createSafeSignHash(cell, seed), secretKey);
      }
      exports.safeSign = safeSign;
      function safeSignVerify(cell, signature, publicKey, seed = "ton-safe-sign-magic") {
        return (0, ton_crypto_1.signVerify)(createSafeSignHash(cell, seed), signature, publicKey);
      }
      exports.safeSignVerify = safeSignVerify;
    }
  });

  // node_modules/ton/dist/block/parse.js
  var require_parse = __commonJS({
    "node_modules/ton/dist/block/parse.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseShardStateUnsplit = exports.parseMasterchainStateExtra = exports.parseShardAccounts = exports.parseDepthBalanceInfo = exports.parseShardAccount = exports.parseShardIdent = exports.parseAccount = exports.parseAccountStorage = exports.parseAccountState = exports.parseStorageInfo = exports.parseStorageUsed = exports.parseTransaction = exports.parseTransactionDescription = exports.parseBouncePhase = exports.parseActionPhase = exports.parseComputePhase = exports.parseCreditPhase = exports.parseStoragePhase = exports.parseStorageUsedShort = exports.parseAccountChange = exports.parseHashUpdate = exports.parseMessageRelaxed = exports.parseMessage = exports.parseStateInit = exports.parseRawTickTock = exports.parseCommonMsgInfoRelaxed = exports.parseCommonMsgInfo = exports.parseCurrencyCollection = exports.parseAccountStatus = void 0;
      var __1 = require_dist2();
      var parseDict_1 = require_parseDict();
      function parseAccountStatus(slice) {
        const status = slice.readUintNumber(2);
        if (status === 0) {
          return "uninitialized";
        }
        if (status === 1) {
          return "frozen";
        }
        if (status === 2) {
          return "active";
        }
        if (status === 3) {
          return "non-existing";
        }
        throw Error("Invalid data");
      }
      exports.parseAccountStatus = parseAccountStatus;
      function parseCurrencyCollection(slice) {
        const coins = slice.readCoins();
        let extraCurrencies = null;
        if (slice.readBit()) {
          let dc = slice.readCell();
          if (!dc.isExotic) {
            let pd = (0, parseDict_1.parseDict)(dc.beginParse(), 32, (s) => s.readVarUIntNumber(5));
            extraCurrencies = /* @__PURE__ */ new Map();
            for (let e of pd) {
              extraCurrencies.set(parseInt(e[0], 10), e[1]);
            }
          }
        }
        return { extraCurrencies, coins };
      }
      exports.parseCurrencyCollection = parseCurrencyCollection;
      function parseCommonMsgInfo(slice) {
        if (!slice.readBit()) {
          let ihrDisabled = slice.readBit();
          let bounce = slice.readBit();
          let bounced = slice.readBit();
          let src = slice.readAddressInternal();
          let dest = slice.readAddressInternal();
          let value = parseCurrencyCollection(slice);
          let ihrFee = slice.readCoins();
          let fwdFee = slice.readCoins();
          let createdLt = slice.readUint(64);
          let createdAt = slice.readUintNumber(32);
          return {
            type: "internal",
            ihrDisabled,
            bounce,
            bounced,
            src,
            dest,
            value,
            ihrFee,
            fwdFee,
            createdLt,
            createdAt
          };
        } else if (slice.readBit()) {
          let src = slice.readAddressInternal();
          let dest = slice.readAddressExternal();
          let createdLt = slice.readUint(64);
          let createdAt = slice.readUintNumber(32);
          return {
            type: "external-out",
            src,
            dest,
            createdLt,
            createdAt
          };
        } else {
          let src = slice.readAddressExternal();
          let dest = slice.readAddressInternal();
          let importFee = slice.readCoins();
          return {
            type: "external-in",
            src,
            dest,
            importFee
          };
        }
      }
      exports.parseCommonMsgInfo = parseCommonMsgInfo;
      function parseCommonMsgInfoRelaxed(slice) {
        if (!slice.readBit()) {
          let ihrDisabled = slice.readBit();
          let bounce = slice.readBit();
          let bounced = slice.readBit();
          let src = slice.readAddress();
          let dest = slice.readAddressInternal();
          let value = parseCurrencyCollection(slice);
          let ihrFee = slice.readCoins();
          let fwdFee = slice.readCoins();
          let createdLt = slice.readUint(64);
          let createdAt = slice.readUintNumber(32);
          return {
            type: "internal",
            ihrDisabled,
            bounce,
            bounced,
            src,
            dest,
            value,
            ihrFee,
            fwdFee,
            createdLt,
            createdAt
          };
        } else if (slice.readBit()) {
          let src = slice.readAddress();
          let dest = slice.readAddressExternal();
          let createdLt = slice.readUint(64);
          let createdAt = slice.readUintNumber(32);
          return {
            type: "external-out",
            src,
            dest,
            createdLt,
            createdAt
          };
        }
        throw new Error("Invalid message info");
      }
      exports.parseCommonMsgInfoRelaxed = parseCommonMsgInfoRelaxed;
      function parseRawTickTock(slice) {
        return {
          tick: slice.readBit(),
          tock: slice.readBit()
        };
      }
      exports.parseRawTickTock = parseRawTickTock;
      function parseStateInit(slice) {
        let raw = slice.toCell();
        let splitDepth = null;
        if (slice.readBit()) {
          splitDepth = slice.readUintNumber(5);
        }
        const special = slice.readBit() ? parseRawTickTock(slice) : null;
        const hasCode = slice.readBit();
        const code = hasCode ? slice.readCell() : null;
        const hasData = slice.readBit();
        const data = hasData ? slice.readCell() : null;
        if (slice.readBit()) {
          slice.readCell();
        }
        return { splitDepth, data, code, special, raw };
      }
      exports.parseStateInit = parseStateInit;
      function parseMessage(slice) {
        const raw = slice.toCell();
        const info = parseCommonMsgInfo(slice);
        const hasInit = slice.readBit();
        let init = null;
        if (hasInit) {
          if (!slice.readBit()) {
            init = parseStateInit(slice);
          } else {
            init = parseStateInit(slice.readRef());
          }
        }
        const body = slice.readBit() ? slice.readRef().toCell() : slice.toCell();
        return {
          info,
          init,
          body,
          raw
        };
      }
      exports.parseMessage = parseMessage;
      function parseMessageRelaxed(slice) {
        const raw = slice.toCell();
        const info = parseCommonMsgInfoRelaxed(slice);
        const hasInit = slice.readBit();
        let init = null;
        if (hasInit) {
          if (!slice.readBit()) {
            init = parseStateInit(slice);
          } else {
            init = parseStateInit(slice.readRef());
          }
        }
        const body = slice.readBit() ? slice.readRef().toCell() : slice.toCell();
        return {
          info,
          init,
          body,
          raw
        };
      }
      exports.parseMessageRelaxed = parseMessageRelaxed;
      function parseHashUpdate(slice) {
        if (slice.readUintNumber(8) !== 114) {
          throw Error("Invalid data");
        }
        const oldHash = slice.readBuffer(32);
        const newHash = slice.readBuffer(32);
        return { oldHash, newHash };
      }
      exports.parseHashUpdate = parseHashUpdate;
      function parseAccountChange(slice) {
        if (!slice.readBit()) {
          return "unchanged";
        }
        if (slice.readBit()) {
          return "frozen";
        } else {
          return "deleted";
        }
      }
      exports.parseAccountChange = parseAccountChange;
      function parseStorageUsedShort(slice) {
        return {
          cells: slice.readVarUIntNumber(3),
          bits: slice.readVarUIntNumber(3)
        };
      }
      exports.parseStorageUsedShort = parseStorageUsedShort;
      function parseStoragePhase(slice) {
        const storageFeesCollected = slice.readCoins();
        let storageFeesDue = null;
        if (slice.readBit()) {
          storageFeesDue = slice.readCoins();
        }
        const statusChange = parseAccountChange(slice);
        return {
          storageFeesCollected,
          storageFeesDue,
          statusChange
        };
      }
      exports.parseStoragePhase = parseStoragePhase;
      function parseCreditPhase(slice) {
        let dueFeesColelcted = slice.readBit() ? slice.readCoins() : null;
        const credit = parseCurrencyCollection(slice);
        return {
          dueFeesColelcted,
          credit
        };
      }
      exports.parseCreditPhase = parseCreditPhase;
      function parseComputePhase(slice) {
        if (!slice.readBit()) {
          const skipReason = slice.readUintNumber(2);
          if (skipReason === 0) {
            return {
              type: "skipped",
              reason: "no-state"
            };
          }
          if (skipReason === 1) {
            return {
              type: "skipped",
              reason: "bad-state"
            };
          }
          if (skipReason === 2) {
            return {
              type: "skipped",
              reason: "no-gas"
            };
          }
        }
        const success = slice.readBit();
        const messageStateUsed = slice.readBit();
        const accountActivated = slice.readBit();
        let gasFees = slice.readCoins();
        const vmState = slice.readRef();
        let gasUsed = vmState.readVarUInt(3);
        let gasLimit = vmState.readVarUInt(3);
        let gasCredit = vmState.readBit() ? vmState.readVarUInt(2) : null;
        let mode = vmState.readUintNumber(8);
        let exitCode = vmState.readUintNumber(32);
        let exitArg = vmState.readBit() ? vmState.readUintNumber(32) : null;
        let vmSteps = vmState.readUintNumber(32);
        let vmInitStateHash = vmState.readBuffer(32);
        let vmFinalStateHash = vmState.readBuffer(32);
        return {
          type: "computed",
          success,
          messageStateUsed,
          accountActivated,
          gasFees,
          gasUsed,
          gasLimit,
          gasCredit,
          mode,
          exitCode,
          exitArg,
          vmSteps,
          vmInitStateHash,
          vmFinalStateHash
        };
      }
      exports.parseComputePhase = parseComputePhase;
      function parseActionPhase(slice) {
        const success = slice.readBit();
        const valid = slice.readBit();
        const noFunds = slice.readBit();
        const statusChange = parseAccountChange(slice);
        const totalFwdFees = slice.readBit() ? slice.readCoins() : null;
        const totalActionFees = slice.readBit() ? slice.readCoins() : null;
        const resultCode = slice.readUintNumber(32);
        const resultArg = slice.readBit() ? slice.readUintNumber(32) : null;
        const totalActions = slice.readUintNumber(16);
        const specialActions = slice.readUintNumber(16);
        const skippedActions = slice.readUintNumber(16);
        const messagesCreated = slice.readUintNumber(16);
        const actionListHash = slice.readBuffer(32);
        const totalMessageSizes = parseStorageUsedShort(slice);
        return {
          success,
          valid,
          noFunds,
          statusChange,
          totalFwdFees,
          totalActionFees,
          resultCode,
          resultArg,
          totalActions,
          specialActions,
          skippedActions,
          messagesCreated,
          actionListHash,
          totalMessageSizes
        };
      }
      exports.parseActionPhase = parseActionPhase;
      function parseBouncePhase(slice) {
        if (slice.readBit()) {
          const msgSize = parseStorageUsedShort(slice);
          const msgFees = slice.readCoins();
          const fwdFees = slice.readCoins();
          return {
            type: "ok",
            msgSize,
            msgFees,
            fwdFees
          };
        }
        if (slice.readBit()) {
          const msgSize = parseStorageUsedShort(slice);
          const fwdFees = slice.readCoins();
          return {
            type: "no-funds",
            msgSize,
            fwdFees
          };
        }
        return {
          type: "negative-funds"
        };
      }
      exports.parseBouncePhase = parseBouncePhase;
      function parseTransactionDescription(slice) {
        const type = slice.readUintNumber(4);
        if (type === 0) {
          const creditFirst = slice.readBit();
          let storagePhase = null;
          let creditPhase = null;
          if (slice.readBit()) {
            storagePhase = parseStoragePhase(slice);
          }
          if (slice.readBit()) {
            creditPhase = parseCreditPhase(slice);
          }
          let computePhase = parseComputePhase(slice);
          let actionPhase = null;
          if (slice.readBit()) {
            actionPhase = parseActionPhase(slice.readRef());
          }
          let aborted = slice.readBit();
          let bouncePhase = null;
          if (slice.readBit()) {
            bouncePhase = parseBouncePhase(slice);
          }
          const destroyed = slice.readBit();
          return {
            type: "generic",
            creditFirst,
            storagePhase,
            creditPhase,
            computePhase,
            actionPhase,
            bouncePhase,
            aborted,
            destroyed
          };
        }
        if (type === 1) {
          let storagePhase = parseStoragePhase(slice);
          return {
            type: "storage",
            storagePhase
          };
        }
        if (type === 2 || type === 3) {
          const isTock = type === 3;
          let storagePhase = parseStoragePhase(slice);
          let computePhase = parseComputePhase(slice);
          let actionPhase = null;
          if (slice.readBit()) {
            actionPhase = parseActionPhase(slice.readRef());
          }
          const aborted = slice.readBit();
          const destroyed = slice.readBit();
          return {
            type: "tick-tock",
            isTock,
            storagePhase,
            computePhase,
            actionPhase,
            aborted,
            destroyed
          };
        }
        throw Error("Unsupported transaction type");
      }
      exports.parseTransactionDescription = parseTransactionDescription;
      function parseTransaction(workchain, slice) {
        if (slice.readUintNumber(4) !== 7) {
          throw Error("Invalid data");
        }
        const addressHash = slice.readBuffer(32);
        const address = new __1.Address(workchain, addressHash);
        const lt = slice.readUint(64);
        const prevTransHash = slice.readBuffer(32);
        const prevTransLt = slice.readUint(64);
        const time = slice.readUintNumber(32);
        const outMessagesCount = slice.readUintNumber(15);
        const oldStatus = parseAccountStatus(slice);
        const newStatus = parseAccountStatus(slice);
        const messages = slice.readRef();
        let hasInMessage = messages.readBit();
        let hasOutMessages = messages.readBit();
        let inMessage = null;
        if (hasInMessage) {
          inMessage = parseMessage(messages.readRef());
        }
        let outMessages = [];
        if (hasOutMessages) {
          let dict = messages.readDict(15, (slice2) => parseMessage(slice2.readRef()));
          for (let msg of Array.from(dict.values())) {
            outMessages.push(msg);
          }
        }
        let fees = parseCurrencyCollection(slice);
        let update = parseHashUpdate(slice.readRef());
        let description = parseTransactionDescription(slice.readRef());
        return {
          address,
          lt,
          time,
          outMessagesCount,
          oldStatus,
          newStatus,
          fees,
          update,
          description,
          inMessage,
          outMessages,
          prevTransaction: {
            hash: prevTransHash,
            lt: prevTransLt
          }
        };
      }
      exports.parseTransaction = parseTransaction;
      function parseStorageUsed(cs) {
        return {
          cells: cs.readVarUIntNumber(3),
          bits: cs.readVarUIntNumber(3),
          publicCells: cs.readVarUIntNumber(3)
        };
      }
      exports.parseStorageUsed = parseStorageUsed;
      function parseStorageInfo(cs) {
        return {
          used: parseStorageUsed(cs),
          lastPaid: cs.readUintNumber(32),
          duePayment: cs.readBit() ? cs.readCoins() : null
        };
      }
      exports.parseStorageInfo = parseStorageInfo;
      function parseAccountState(cs) {
        if (cs.readBit()) {
          return { type: "active", state: parseStateInit(cs) };
        } else if (cs.readBit()) {
          return { type: "frozen", stateHash: cs.readBuffer(32) };
        } else {
          return { type: "uninit" };
        }
      }
      exports.parseAccountState = parseAccountState;
      function parseAccountStorage(cs) {
        return { lastTransLt: cs.readUint(64), balance: parseCurrencyCollection(cs), state: parseAccountState(cs) };
      }
      exports.parseAccountStorage = parseAccountStorage;
      function parseAccount(cs) {
        if (cs.readBit()) {
          return {
            address: cs.readAddressInternal(),
            storageStat: parseStorageInfo(cs),
            storage: parseAccountStorage(cs)
          };
        } else {
          return null;
        }
      }
      exports.parseAccount = parseAccount;
      function parseShardIdent(cs) {
        if (cs.readUintNumber(2) !== 0) {
          throw Error("Invalid data");
        }
        let shardPrefixBits = cs.readUintNumber(6);
        let workchainId = cs.readIntNumber(32);
        let shardPrefix = cs.readUint(64);
        return {
          shardPrefixBits,
          workchainId,
          shardPrefix
        };
      }
      exports.parseShardIdent = parseShardIdent;
      function parseShardAccount(cs) {
        let accountCell = cs.readCell();
        let address = null;
        if (!accountCell.isExotic) {
          address = accountCell.beginParse().readAddress();
        }
        return {
          address,
          lastTransHash: cs.readBuffer(32),
          lastTransLt: cs.readUint(64)
        };
      }
      exports.parseShardAccount = parseShardAccount;
      function parseDepthBalanceInfo(cs) {
        return {
          splitDepth: cs.readUintNumber(5),
          balance: parseCurrencyCollection(cs)
        };
      }
      exports.parseDepthBalanceInfo = parseDepthBalanceInfo;
      function parseShardAccounts(cs) {
        if (!cs.readBit()) {
          return /* @__PURE__ */ new Map();
        }
        return (0, parseDict_1.parseDict)(cs.readRef(), 256, (cs2) => {
          let depthBalanceInfo = parseDepthBalanceInfo(cs2);
          let shardAccount = parseShardAccount(cs2);
          return {
            depthBalanceInfo,
            shardAccount
          };
        });
      }
      exports.parseShardAccounts = parseShardAccounts;
      function parseMasterchainStateExtra(cs) {
        if (cs.readUintNumber(16) !== 52262) {
          throw Error("Invalid data");
        }
        if (cs.readBit()) {
          cs.readCell();
        }
        let configAddress = new __1.Address(-1, cs.readBuffer(32));
        let config = cs.readCell();
        const globalBalance = parseCurrencyCollection(cs);
        return {
          config,
          configAddress,
          globalBalance
        };
      }
      exports.parseMasterchainStateExtra = parseMasterchainStateExtra;
      function parseShardStateUnsplit(cs) {
        if (cs.readUintNumber(32) !== 2418257890) {
          throw Error("Invalid data");
        }
        let globalId = cs.readIntNumber(32);
        let shardId = parseShardIdent(cs);
        let seqno = cs.readUintNumber(32);
        let vertSeqNo = cs.readUintNumber(32);
        let genUtime = cs.readUintNumber(32);
        let genLt = cs.readUint(64);
        let minRefSeqno = cs.readUintNumber(32);
        cs.readCell();
        let beforeSplit = cs.readBit();
        let accounts;
        let accountsCell = cs.readCell();
        if (accountsCell.isExotic) {
          accounts = /* @__PURE__ */ new Map();
        } else {
          accounts = parseShardAccounts(accountsCell.beginParse());
        }
        cs.readCell();
        let mcStateExtra = cs.readBit();
        let extras = null;
        if (mcStateExtra) {
          let cell = cs.readCell();
          if (!cell.isExotic) {
            extras = parseMasterchainStateExtra(cell.beginParse());
          }
        }
        ;
        return {
          globalId,
          shardId,
          seqno,
          vertSeqNo,
          genUtime,
          genLt,
          minRefSeqno,
          beforeSplit,
          accounts,
          extras
        };
      }
      exports.parseShardStateUnsplit = parseShardStateUnsplit;
    }
  });

  // node_modules/ton/dist/block/stack.js
  var require_stack = __commonJS({
    "node_modules/ton/dist/block/stack.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseStack = exports.serializeStack = void 0;
      var bn_js_1 = __importDefault(require_bn());
      var Builder_1 = require_Builder();
      var Cell_1 = require_Cell();
      var INT64_MIN = new bn_js_1.default("-9223372036854775808");
      var INT64_MAX = new bn_js_1.default("9223372036854775807");
      function serializeStackItem(src, builder) {
        if (src.type === "null") {
          builder.storeUint8(0);
        } else if (src.type === "int") {
          if (src.value.lte(INT64_MAX) && src.value.gte(INT64_MIN)) {
            builder.storeUint8(1);
            builder.storeInt(src.value, 64);
          } else {
            builder.storeUint(256, 15);
            builder.storeInt(src.value, 257);
          }
        } else if (src.type === "nan") {
          builder.storeInt(767, 16);
        } else if (src.type === "cell") {
          builder.storeUint8(3);
          builder.storeRef(src.cell);
        } else if (src.type === "slice") {
          builder.storeUint8(4);
          builder.storeUint(0, 10);
          builder.storeUint(src.cell.bits.cursor, 10);
          builder.storeUint(0, 3);
          builder.storeUint(src.cell.refs.length, 3);
          builder.storeRef(src.cell);
        } else if (src.type === "builder") {
          builder.storeUint8(5);
          builder.storeRef(src.cell);
        } else if (src.type === "tuple") {
          let head = null;
          let tail = null;
          for (let i = 0; i < src.items.length; i++) {
            let s = head;
            head = tail;
            tail = s;
            if (i > 1) {
              head = (0, Builder_1.beginCell)().storeRef(tail).storeRef(head).endCell();
            }
            let bc = (0, Builder_1.beginCell)();
            serializeStackItem(src.items[i], bc);
            tail = bc.endCell();
          }
          builder.storeUint8(7);
          builder.storeUint(src.items.length, 16);
          if (head) {
            builder.storeRef(head);
          }
          if (tail) {
            builder.storeRef(tail);
          }
        } else {
          throw Error("Invalid value");
        }
      }
      function parseStackItem(cs) {
        let kind = cs.readUintNumber(8);
        if (kind === 0) {
          return { type: "null" };
        } else if (kind === 1) {
          return { type: "int", value: cs.readInt(64) };
        } else if (kind === 2) {
          if (cs.readUintNumber(7) === 0) {
            return { type: "int", value: cs.readInt(257) };
          } else {
            cs.readBit();
            return { type: "nan" };
          }
        } else if (kind === 3) {
          return { type: "cell", cell: cs.readCell() };
        } else if (kind === 4) {
          let startBits = cs.readUintNumber(10);
          let endBits = cs.readUintNumber(10);
          let startRefs = cs.readUintNumber(3);
          let endRefs = cs.readUintNumber(3);
          let rs = cs.readCell().beginParse();
          rs.skip(startBits);
          let dt = rs.readBitString(endBits - startBits);
          let cell = new Cell_1.Cell("ordinary", dt);
          if (startRefs < endRefs) {
            for (let i = 0; i < startRefs; i++) {
              cs.readCell();
            }
            for (let i = 0; i < endRefs - startRefs; i++) {
              cell.refs.push(cs.readCell());
            }
          }
          return { type: "slice", cell };
        } else if (kind === 5) {
          return { type: "builder", cell: cs.readCell() };
        } else if (kind === 7) {
          let length = cs.readUintNumber(16);
          let items = [];
          if (length > 1) {
            let head = cs.readRef();
            let tail = cs.readRef();
            items.unshift(parseStackItem(tail));
            for (let i = 0; i < length - 2; i++) {
              let ohead = head;
              head = ohead.readRef();
              tail = ohead.readRef();
              items.unshift(parseStackItem(tail));
            }
            items.unshift(parseStackItem(head));
          } else if (length === 1) {
            items.push(parseStackItem(cs.readRef()));
          }
          return { type: "tuple", items };
        } else {
          throw Error("Unsupported stack item");
        }
      }
      function serializeStackTail(src, builder) {
        if (src.length > 0) {
          let tail = (0, Builder_1.beginCell)();
          serializeStackTail(src.slice(0, src.length - 1), tail);
          builder.storeRef(tail.endCell());
          serializeStackItem(src[src.length - 1], builder);
        }
      }
      function serializeStack(src) {
        let builder = (0, Builder_1.beginCell)();
        builder.storeUint(src.length, 24);
        let r = [...src];
        serializeStackTail(r, builder);
        return builder.endCell();
      }
      exports.serializeStack = serializeStack;
      function parseStack(src) {
        let res = [];
        let cs = src.beginParse();
        let size = cs.readUintNumber(24);
        for (let i = 0; i < size; i++) {
          let next = cs.readRef();
          res.unshift(parseStackItem(cs));
          cs = next;
        }
        return res;
      }
      exports.parseStack = parseStack;
    }
  });

  // node_modules/ton/dist/utils/toUrlSafe.js
  var require_toUrlSafe = __commonJS({
    "node_modules/ton/dist/utils/toUrlSafe.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toUrlSafe = void 0;
      function toUrlSafe(src) {
        while (src.indexOf("/") >= 0) {
          src = src.replace("/", "_");
        }
        while (src.indexOf("+") >= 0) {
          src = src.replace("+", "-");
        }
        while (src.indexOf("=") >= 0) {
          src = src.replace("=", "");
        }
        return src;
      }
      exports.toUrlSafe = toUrlSafe;
    }
  });

  // node_modules/ton/dist/client/TonClient4.js
  var require_TonClient4 = __commonJS({
    "node_modules/ton/dist/client/TonClient4.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _TonClient4_endpoint;
      var _TonClient4_timeout;
      var _TonClient4_adapter;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TonClient4 = void 0;
      var axios_1 = __importDefault(require_axios2());
      var t = __importStar(require_lib());
      var stack_1 = require_stack();
      var Cell_1 = require_Cell();
      var toUrlSafe_1 = require_toUrlSafe();
      var TonClient4 = class {
        constructor(args) {
          _TonClient4_endpoint.set(this, void 0);
          _TonClient4_timeout.set(this, void 0);
          _TonClient4_adapter.set(this, void 0);
          __classPrivateFieldSet(this, _TonClient4_endpoint, args.endpoint, "f");
          __classPrivateFieldSet(this, _TonClient4_timeout, args.timeout || 5e3, "f");
          __classPrivateFieldSet(this, _TonClient4_adapter, args.httpAdapter, "f");
        }
        getLastBlock() {
          return __async(this, null, function* () {
            let res = yield axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/latest", { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
            if (!lastBlockCodec.is(res.data)) {
              throw Error("Mailformed response");
            }
            return res.data;
          });
        }
        getBlock(seqno) {
          return __async(this, null, function* () {
            let res = yield axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
            if (!blockCodec.is(res.data)) {
              throw Error("Mailformed response");
            }
            if (!res.data.exist) {
              throw Error("Block is out of scope");
            }
            return res.data.block;
          });
        }
        getBlockByUtime(ts) {
          return __async(this, null, function* () {
            let res = yield axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/utime/" + ts, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
            if (!blockCodec.is(res.data)) {
              throw Error("Mailformed response");
            }
            if (!res.data.exist) {
              throw Error("Block is out of scope");
            }
            return res.data.block;
          });
        }
        getAccount(seqno, address) {
          return __async(this, null, function* () {
            let res = yield axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toFriendly({ urlSafe: true }), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
            if (!accountCodec.is(res.data)) {
              throw Error("Mailformed response");
            }
            return res.data;
          });
        }
        getAccountLite(seqno, address) {
          return __async(this, null, function* () {
            let res = yield axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toFriendly({ urlSafe: true }) + "/lite", { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
            if (!accountLiteCodec.is(res.data)) {
              throw Error("Mailformed response");
            }
            return res.data;
          });
        }
        isAccountChanged(seqno, address, lt) {
          return __async(this, null, function* () {
            let res = yield axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toFriendly({ urlSafe: true }) + "/changed/" + lt.toString(10), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
            if (!changedCodec.is(res.data)) {
              throw Error("Mailformed response");
            }
            return res.data;
          });
        }
        getAccountTransactions(address, lt, hash) {
          return __async(this, null, function* () {
            let res = yield axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/account/" + address.toFriendly({ urlSafe: true }) + "/tx/" + lt.toString(10) + "/" + (0, toUrlSafe_1.toUrlSafe)(hash.toString("base64")), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
            if (!transactionsCodec.is(res.data)) {
              throw Error("Mailformed response");
            }
            let data = res.data;
            let tx = [];
            let cells = Cell_1.Cell.fromBoc(Buffer.from(data.boc, "base64"));
            for (let i = 0; i < data.blocks.length; i++) {
              tx.push({
                block: data.blocks[i],
                tx: cells[i]
              });
            }
            return tx;
          });
        }
        getConfig(seqno, ids) {
          return __async(this, null, function* () {
            let tail = "";
            if (ids && ids.length > 0) {
              tail = "/" + [...ids].sort().join(",");
            }
            let res = yield axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/config" + tail, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
            if (!configCodec.is(res.data)) {
              throw Error("Mailformed response");
            }
            return res.data;
          });
        }
        runMethod(seqno, address, name, args) {
          return __async(this, null, function* () {
            let tail = args && args.length > 0 ? "/" + (0, toUrlSafe_1.toUrlSafe)((0, stack_1.serializeStack)(args).toBoc({ idx: false, crc32: false }).toString("base64")) : "";
            let url = __classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toFriendly({ urlSafe: true }) + "/run/" + name + tail;
            let res = yield axios_1.default.get(url, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
            if (!runMethodCodec.is(res.data)) {
              throw Error("Mailformed response");
            }
            return {
              exitCode: res.data.exitCode,
              result: res.data.resultRaw ? (0, stack_1.parseStack)(Cell_1.Cell.fromBoc(Buffer.from(res.data.resultRaw, "base64"))[0]) : [],
              resultRaw: res.data.resultRaw,
              block: res.data.block,
              shardBlock: res.data.shardBlock
            };
          });
        }
        sendMessage(message) {
          return __async(this, null, function* () {
            let res = yield axios_1.default.post(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/send", { boc: message.toString("base64") }, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
            if (!sendCodec.is(res.data)) {
              throw Error("Mailformed response");
            }
            return { status: res.data.status };
          });
        }
      };
      exports.TonClient4 = TonClient4;
      _TonClient4_endpoint = /* @__PURE__ */ new WeakMap(), _TonClient4_timeout = /* @__PURE__ */ new WeakMap(), _TonClient4_adapter = /* @__PURE__ */ new WeakMap();
      var lastBlockCodec = t.type({
        last: t.type({
          seqno: t.number,
          shard: t.string,
          workchain: t.number,
          fileHash: t.string,
          rootHash: t.string
        }),
        init: t.type({
          fileHash: t.string,
          rootHash: t.string
        }),
        stateRootHash: t.string,
        now: t.number
      });
      var blockCodec = t.union([t.type({
        exist: t.literal(false)
      }), t.type({
        exist: t.literal(true),
        block: t.type({
          shards: t.array(t.type({
            workchain: t.number,
            seqno: t.number,
            shard: t.string,
            rootHash: t.string,
            fileHash: t.string,
            transactions: t.array(t.type({
              account: t.string,
              hash: t.string,
              lt: t.string
            }))
          }))
        })
      })]);
      var storageStatCodec = t.type({
        lastPaid: t.number,
        duePayment: t.union([t.null, t.string]),
        used: t.type({
          bits: t.number,
          cells: t.number,
          publicCells: t.number
        })
      });
      var accountCodec = t.type({
        account: t.type({
          state: t.union([
            t.type({ type: t.literal("uninit") }),
            t.type({ type: t.literal("active"), code: t.union([t.string, t.null]), data: t.union([t.string, t.null]) }),
            t.type({ type: t.literal("frozen"), stateHash: t.string })
          ]),
          balance: t.type({
            coins: t.string
          }),
          last: t.union([
            t.null,
            t.type({
              lt: t.string,
              hash: t.string
            })
          ]),
          storageStat: t.union([t.null, storageStatCodec])
        }),
        block: t.type({
          workchain: t.number,
          seqno: t.number,
          shard: t.string,
          rootHash: t.string,
          fileHash: t.string
        })
      });
      var accountLiteCodec = t.type({
        account: t.type({
          state: t.union([
            t.type({ type: t.literal("uninit") }),
            t.type({ type: t.literal("active"), codeHash: t.string, dataHash: t.string }),
            t.type({ type: t.literal("frozen"), stateHash: t.string })
          ]),
          balance: t.type({
            coins: t.string
          }),
          last: t.union([
            t.null,
            t.type({
              lt: t.string,
              hash: t.string
            })
          ]),
          storageStat: t.union([t.null, storageStatCodec])
        })
      });
      var changedCodec = t.type({
        changed: t.boolean,
        block: t.type({
          workchain: t.number,
          seqno: t.number,
          shard: t.string,
          rootHash: t.string,
          fileHash: t.string
        })
      });
      var runMethodCodec = t.type({
        exitCode: t.number,
        resultRaw: t.union([t.string, t.null]),
        block: t.type({
          workchain: t.number,
          seqno: t.number,
          shard: t.string,
          rootHash: t.string,
          fileHash: t.string
        }),
        shardBlock: t.type({
          workchain: t.number,
          seqno: t.number,
          shard: t.string,
          rootHash: t.string,
          fileHash: t.string
        })
      });
      var configCodec = t.type({
        config: t.type({
          cell: t.string,
          address: t.string,
          globalBalance: t.type({
            coins: t.string
          })
        })
      });
      var sendCodec = t.type({
        status: t.number
      });
      var transactionsCodec = t.type({
        blocks: t.array(t.type({
          workchain: t.number,
          seqno: t.number,
          shard: t.string,
          rootHash: t.string,
          fileHash: t.string
        })),
        boc: t.string
      });
    }
  });

  // node_modules/ton/dist/block/fees.js
  var require_fees = __commonJS({
    "node_modules/ton/dist/block/fees.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.computeMessageForwardFees = exports.computeExternalMessageFees = exports.computeGasPrices = exports.computeFwdFees = exports.computeStorageFees = void 0;
      var bn_js_1 = __importDefault(require_bn());
      var parse_1 = require_parse();
      function computeStorageFees(data) {
        const { lastPaid, now, storagePrices, storageStat, special, masterchain } = data;
        if (now <= lastPaid || storagePrices.length === 0 || now < storagePrices[0].utime_since.toNumber() || special) {
          return new bn_js_1.default(0);
        }
        let upto = Math.max(lastPaid, storagePrices[0].utime_since.toNumber());
        let total = new bn_js_1.default(0);
        for (let i = 0; i < storagePrices.length && upto < now; i++) {
          let valid_until = i < storagePrices.length - 1 ? Math.min(now, storagePrices[i + 1].utime_since.toNumber()) : now;
          let payment = new bn_js_1.default(0);
          if (upto < valid_until) {
            let delta = valid_until - upto;
            payment = payment.add(new bn_js_1.default(storageStat.cells).mul(masterchain ? storagePrices[i].mc_cell_price_ps : storagePrices[i].cell_price_ps));
            payment = payment.add(new bn_js_1.default(storageStat.bits).mul(masterchain ? storagePrices[i].mc_bit_price_ps : storagePrices[i].bit_price_ps));
            payment = payment.mul(new bn_js_1.default(delta));
          }
          upto = valid_until;
          total = total.add(payment);
        }
        return shr16ceil(total);
      }
      exports.computeStorageFees = computeStorageFees;
      function computeFwdFees(msgPrices, cells, bits) {
        return msgPrices.lumpPrice.add(shr16ceil(msgPrices.bitPrice.mul(bits).add(msgPrices.cellPrice.mul(cells))));
      }
      exports.computeFwdFees = computeFwdFees;
      function computeGasPrices(gasUsed, prices) {
        if (gasUsed.lte(prices.flatLimit)) {
          return prices.flatPrice;
        } else {
          return prices.flatPrice.add(prices.price.mul(gasUsed.sub(prices.flatLimit)).shrn(16));
        }
      }
      exports.computeGasPrices = computeGasPrices;
      function computeExternalMessageFees(msgPrices, cell) {
        let storageStats = collectCellStats(cell);
        storageStats.bits -= cell.bits.cursor;
        storageStats.cells -= 1;
        return computeFwdFees(msgPrices, new bn_js_1.default(storageStats.cells), new bn_js_1.default(storageStats.bits));
      }
      exports.computeExternalMessageFees = computeExternalMessageFees;
      function computeMessageForwardFees(msgPrices, cell) {
        let msg = (0, parse_1.parseMessageRelaxed)(cell.beginParse());
        let storageStats = { bits: 0, cells: 0 };
        if (msg.init) {
          let c = collectCellStats(msg.init.raw);
          c.bits -= msg.init.raw.bits.cursor;
          c.cells -= 1;
          storageStats.bits += c.bits;
          storageStats.cells += c.cells;
        }
        let bc = collectCellStats(msg.body);
        bc.bits -= msg.body.bits.cursor;
        bc.cells -= 1;
        storageStats.bits += bc.bits;
        storageStats.cells += bc.cells;
        let fees = computeFwdFees(msgPrices, new bn_js_1.default(storageStats.cells), new bn_js_1.default(storageStats.bits));
        let res = fees.mul(msgPrices.firstFrac).shrn(16);
        let remaining = fees.sub(res);
        return { fees: res, remaining };
      }
      exports.computeMessageForwardFees = computeMessageForwardFees;
      function collectCellStats(cell) {
        let bits = cell.bits.cursor;
        let cells = 1;
        for (let ref of cell.refs) {
          let r = collectCellStats(ref);
          cells += r.cells;
          bits += r.bits;
        }
        return { bits, cells };
      }
      function shr16ceil(src) {
        let rem = src.mod(new bn_js_1.default(65536));
        let res = src.shrn(16);
        if (!rem.eqn(0)) {
          res = res.addn(1);
        }
        return res;
      }
    }
  });

  // node_modules/ton/dist/traits/trait_address.js
  var require_trait_address = __commonJS({
    "node_modules/ton/dist/traits/trait_address.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.address = void 0;
      var TupleSlice4_1 = require_TupleSlice4();
      function address(client) {
        return (seqno, address2, name) => __async(this, null, function* () {
          let executed = yield client.runMethod(seqno, address2, name);
          if (executed.exitCode !== 0 && executed.exitCode !== 1) {
            throw Error("Exit code: " + executed.exitCode);
          }
          let parsed = new TupleSlice4_1.TupleSlice4(executed.result);
          return parsed.readAddress();
        });
      }
      exports.address = address;
    }
  });

  // node_modules/ton/dist/traits/trait_amount.js
  var require_trait_amount = __commonJS({
    "node_modules/ton/dist/traits/trait_amount.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.amount = void 0;
      var TupleSlice4_1 = require_TupleSlice4();
      function amount(client) {
        return (seqno, address, name) => __async(this, null, function* () {
          let executed = yield client.runMethod(seqno, address, name);
          if (executed.exitCode !== 0 && executed.exitCode !== 1) {
            throw Error("Exit code: " + executed.exitCode);
          }
          let parsed = new TupleSlice4_1.TupleSlice4(executed.result);
          return parsed.readBigNumber();
        });
      }
      exports.amount = amount;
    }
  });

  // node_modules/ton/dist/traits/trait_seqno.js
  var require_trait_seqno = __commonJS({
    "node_modules/ton/dist/traits/trait_seqno.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.seqno = void 0;
      var TupleSlice4_1 = require_TupleSlice4();
      function seqno(client) {
        return (seqno2, address, name = "seqno") => __async(this, null, function* () {
          let executed = yield client.runMethod(seqno2, address, name);
          if (executed.exitCode !== 0 && executed.exitCode !== 1) {
            throw Error("Exit code: " + executed.exitCode);
          }
          let parsed = new TupleSlice4_1.TupleSlice4(executed.result);
          return parsed.readNumber();
        });
      }
      exports.seqno = seqno;
    }
  });

  // node_modules/ton/dist/traits/index.js
  var require_traits = __commonJS({
    "node_modules/ton/dist/traits/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Traits = void 0;
      var trait_address_1 = require_trait_address();
      var trait_amount_1 = require_trait_amount();
      var trait_seqno_1 = require_trait_seqno();
      exports.Traits = {
        withClient: (src) => {
          return {
            seqno: (0, trait_seqno_1.seqno)(src),
            amount: (0, trait_amount_1.amount)(src),
            address: (0, trait_address_1.address)(src)
          };
        }
      };
    }
  });

  // node_modules/ton/dist/index.js
  var require_dist2 = __commonJS({
    "node_modules/ton/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletV3R2Source = exports.WalletV3R1Source = exports.WalletV2R2Source = exports.WalletV2R1Source = exports.WalletV1R3Source = exports.WalletV1R2Source = exports.WalletV1R1Source = exports.UnknownContractSource = exports.contractAddress = exports.createWalletTransferV3 = exports.createWalletTransferV2 = exports.createWalletTransferV1 = exports.WalletContract = exports.BinaryMessage = exports.CommentMessage = exports.CommonMessageInfo = exports.StateInit = exports.EmptyMessage = exports.ExternalMessage = exports.InternalMessage = exports.CellMessage = exports.parseSupportedMessage = exports.getSupportedInterfacesRaw = exports.resolveKnownInterface = exports.getSupportedInterfaces = exports.TupleSlice4 = exports.TupleSlice = exports.bnToAddress = exports.beginDict = exports.DictBuilder = exports.beginCell = exports.Builder = exports.ADNLKey = exports.ADNLAddress = exports.Slice = exports.HttpApi = exports.InMemoryCache = exports.SendMode = exports.KeyStore = exports.fromNano = exports.toNano = exports.AddressExternal = exports.Address = exports.AllWalletContractTypes = exports.validateWalletType = exports.Wallet = exports.TonClient = exports.Cell = exports.BitStringReader = exports.BitString = void 0;
      exports.configParse15 = exports.configParseMasterAddressRequired = exports.parseBridge = exports.parseValidatorSet = exports.parseValidatorDescr = exports.configParseWorkchainDescriptor = exports.configParseMasterAddress = exports.computeMessageForwardFees = exports.computeExternalMessageFees = exports.computeGasPrices = exports.computeFwdFees = exports.computeStorageFees = exports.TonClient4 = exports.parseStack = exports.serializeStack = exports.parseMasterchainStateExtra = exports.parseShardStateUnsplit = exports.parseShardAccounts = exports.parseDepthBalanceInfo = exports.parseShardAccount = exports.parseShardIdent = exports.parseAccount = exports.parseAccountStorage = exports.parseAccountState = exports.parseStorageInfo = exports.parseStorageUsed = exports.parseRawTickTock = exports.parseTransactionDescription = exports.parseBouncePhase = exports.parseActionPhase = exports.parseComputePhase = exports.parseCreditPhase = exports.parseStoragePhase = exports.parseStorageUsedShort = exports.parseAccountChange = exports.parseHashUpdate = exports.parseMessageRelaxed = exports.parseMessage = exports.parseStateInit = exports.parseCommonMsgInfo = exports.parseCurrencyCollection = exports.parseAccountStatus = exports.parseTransaction = exports.safeSignVerify = exports.safeSign = exports.serializeDict = exports.parseDictRefs = exports.parseDictBitString = exports.parseDict = exports.ConfigStore = void 0;
      exports.Traits = exports.configParse29 = exports.configParse28 = exports.parseFullConfig = exports.configParseMsgPrices = exports.configParseGasLimitsPrices = exports.configParseBridge = exports.configParseValidatorSet = exports.configParse12 = exports.configParse40 = exports.configParse8 = exports.configParse18 = exports.configParse17 = exports.configParse16 = void 0;
      var BitString_1 = require_BitString();
      Object.defineProperty(exports, "BitString", { enumerable: true, get: function() {
        return BitString_1.BitString;
      } });
      var BitStringReader_1 = require_BitStringReader();
      Object.defineProperty(exports, "BitStringReader", { enumerable: true, get: function() {
        return BitStringReader_1.BitStringReader;
      } });
      var Cell_1 = require_Cell();
      Object.defineProperty(exports, "Cell", { enumerable: true, get: function() {
        return Cell_1.Cell;
      } });
      var TonClient_1 = require_TonClient();
      Object.defineProperty(exports, "TonClient", { enumerable: true, get: function() {
        return TonClient_1.TonClient;
      } });
      var Wallet_1 = require_Wallet();
      Object.defineProperty(exports, "Wallet", { enumerable: true, get: function() {
        return Wallet_1.Wallet;
      } });
      Object.defineProperty(exports, "validateWalletType", { enumerable: true, get: function() {
        return Wallet_1.validateWalletType;
      } });
      Object.defineProperty(exports, "AllWalletContractTypes", { enumerable: true, get: function() {
        return Wallet_1.allTypes;
      } });
      var Address_1 = require_Address();
      Object.defineProperty(exports, "Address", { enumerable: true, get: function() {
        return Address_1.Address;
      } });
      var AddressExternal_1 = require_AddressExternal();
      Object.defineProperty(exports, "AddressExternal", { enumerable: true, get: function() {
        return AddressExternal_1.AddressExternal;
      } });
      var convert_1 = require_convert();
      Object.defineProperty(exports, "toNano", { enumerable: true, get: function() {
        return convert_1.toNano;
      } });
      Object.defineProperty(exports, "fromNano", { enumerable: true, get: function() {
        return convert_1.fromNano;
      } });
      var KeyStore_1 = require_KeyStore();
      Object.defineProperty(exports, "KeyStore", { enumerable: true, get: function() {
        return KeyStore_1.KeyStore;
      } });
      var SendMode_1 = require_SendMode();
      Object.defineProperty(exports, "SendMode", { enumerable: true, get: function() {
        return SendMode_1.SendMode;
      } });
      var TonCache_1 = require_TonCache();
      Object.defineProperty(exports, "InMemoryCache", { enumerable: true, get: function() {
        return TonCache_1.InMemoryCache;
      } });
      var HttpApi_1 = require_HttpApi();
      Object.defineProperty(exports, "HttpApi", { enumerable: true, get: function() {
        return HttpApi_1.HttpApi;
      } });
      var Slice_1 = require_Slice();
      Object.defineProperty(exports, "Slice", { enumerable: true, get: function() {
        return Slice_1.Slice;
      } });
      var ADNLAddress_1 = require_ADNLAddress();
      Object.defineProperty(exports, "ADNLAddress", { enumerable: true, get: function() {
        return ADNLAddress_1.ADNLAddress;
      } });
      var ADNLKey_1 = require_ADNLKey();
      Object.defineProperty(exports, "ADNLKey", { enumerable: true, get: function() {
        return ADNLKey_1.ADNLKey;
      } });
      var Builder_1 = require_Builder();
      Object.defineProperty(exports, "Builder", { enumerable: true, get: function() {
        return Builder_1.Builder;
      } });
      Object.defineProperty(exports, "beginCell", { enumerable: true, get: function() {
        return Builder_1.beginCell;
      } });
      var DictBuilder_1 = require_DictBuilder();
      Object.defineProperty(exports, "DictBuilder", { enumerable: true, get: function() {
        return DictBuilder_1.DictBuilder;
      } });
      Object.defineProperty(exports, "beginDict", { enumerable: true, get: function() {
        return DictBuilder_1.beginDict;
      } });
      var bnToAddress_1 = require_bnToAddress();
      Object.defineProperty(exports, "bnToAddress", { enumerable: true, get: function() {
        return bnToAddress_1.bnToAddress;
      } });
      var TupleSlice_1 = require_TupleSlice();
      Object.defineProperty(exports, "TupleSlice", { enumerable: true, get: function() {
        return TupleSlice_1.TupleSlice;
      } });
      var TupleSlice4_1 = require_TupleSlice4();
      Object.defineProperty(exports, "TupleSlice4", { enumerable: true, get: function() {
        return TupleSlice4_1.TupleSlice4;
      } });
      var getSupportedInterfaces_1 = require_getSupportedInterfaces();
      Object.defineProperty(exports, "getSupportedInterfaces", { enumerable: true, get: function() {
        return getSupportedInterfaces_1.getSupportedInterfaces;
      } });
      Object.defineProperty(exports, "resolveKnownInterface", { enumerable: true, get: function() {
        return getSupportedInterfaces_1.resolveKnownInterface;
      } });
      Object.defineProperty(exports, "getSupportedInterfacesRaw", { enumerable: true, get: function() {
        return getSupportedInterfaces_1.getSupportedInterfacesRaw;
      } });
      var parseSupportedMessage_1 = require_parseSupportedMessage();
      Object.defineProperty(exports, "parseSupportedMessage", { enumerable: true, get: function() {
        return parseSupportedMessage_1.parseSupportedMessage;
      } });
      var CellMessage_1 = require_CellMessage();
      Object.defineProperty(exports, "CellMessage", { enumerable: true, get: function() {
        return CellMessage_1.CellMessage;
      } });
      var InternalMessage_1 = require_InternalMessage();
      Object.defineProperty(exports, "InternalMessage", { enumerable: true, get: function() {
        return InternalMessage_1.InternalMessage;
      } });
      var ExternalMessage_1 = require_ExternalMessage();
      Object.defineProperty(exports, "ExternalMessage", { enumerable: true, get: function() {
        return ExternalMessage_1.ExternalMessage;
      } });
      var EmptyMessage_1 = require_EmptyMessage();
      Object.defineProperty(exports, "EmptyMessage", { enumerable: true, get: function() {
        return EmptyMessage_1.EmptyMessage;
      } });
      var StateInit_1 = require_StateInit();
      Object.defineProperty(exports, "StateInit", { enumerable: true, get: function() {
        return StateInit_1.StateInit;
      } });
      var CommonMessageInfo_1 = require_CommonMessageInfo();
      Object.defineProperty(exports, "CommonMessageInfo", { enumerable: true, get: function() {
        return CommonMessageInfo_1.CommonMessageInfo;
      } });
      var CommentMessage_1 = require_CommentMessage();
      Object.defineProperty(exports, "CommentMessage", { enumerable: true, get: function() {
        return CommentMessage_1.CommentMessage;
      } });
      var BinaryMessage_1 = require_BinaryMessage();
      Object.defineProperty(exports, "BinaryMessage", { enumerable: true, get: function() {
        return BinaryMessage_1.BinaryMessage;
      } });
      var WalletContract_1 = require_WalletContract();
      Object.defineProperty(exports, "WalletContract", { enumerable: true, get: function() {
        return WalletContract_1.WalletContract;
      } });
      var createWalletTransfer_1 = require_createWalletTransfer();
      Object.defineProperty(exports, "createWalletTransferV1", { enumerable: true, get: function() {
        return createWalletTransfer_1.createWalletTransferV1;
      } });
      Object.defineProperty(exports, "createWalletTransferV2", { enumerable: true, get: function() {
        return createWalletTransfer_1.createWalletTransferV2;
      } });
      Object.defineProperty(exports, "createWalletTransferV3", { enumerable: true, get: function() {
        return createWalletTransfer_1.createWalletTransferV3;
      } });
      var contractAddress_1 = require_contractAddress();
      Object.defineProperty(exports, "contractAddress", { enumerable: true, get: function() {
        return contractAddress_1.contractAddress;
      } });
      var UnknownContractSource_1 = require_UnknownContractSource();
      Object.defineProperty(exports, "UnknownContractSource", { enumerable: true, get: function() {
        return UnknownContractSource_1.UnknownContractSource;
      } });
      var WalletV1R1Source_1 = require_WalletV1R1Source();
      Object.defineProperty(exports, "WalletV1R1Source", { enumerable: true, get: function() {
        return WalletV1R1Source_1.WalletV1R1Source;
      } });
      var WalletV1R2Source_1 = require_WalletV1R2Source();
      Object.defineProperty(exports, "WalletV1R2Source", { enumerable: true, get: function() {
        return WalletV1R2Source_1.WalletV1R2Source;
      } });
      var WalletV1R3Source_1 = require_WalletV1R3Source();
      Object.defineProperty(exports, "WalletV1R3Source", { enumerable: true, get: function() {
        return WalletV1R3Source_1.WalletV1R3Source;
      } });
      var WalletV2R1Source_1 = require_WalletV2R1Source();
      Object.defineProperty(exports, "WalletV2R1Source", { enumerable: true, get: function() {
        return WalletV2R1Source_1.WalletV2R1Source;
      } });
      var WalletV2R2Source_1 = require_WalletV2R2Source();
      Object.defineProperty(exports, "WalletV2R2Source", { enumerable: true, get: function() {
        return WalletV2R2Source_1.WalletV2R2Source;
      } });
      var WalletV3R1Source_1 = require_WalletV3R1Source();
      Object.defineProperty(exports, "WalletV3R1Source", { enumerable: true, get: function() {
        return WalletV3R1Source_1.WalletV3R1Source;
      } });
      var WalletV3R2Source_1 = require_WalletV3R2Source();
      Object.defineProperty(exports, "WalletV3R2Source", { enumerable: true, get: function() {
        return WalletV3R2Source_1.WalletV3R2Source;
      } });
      var ConfigStore_1 = require_ConfigStore();
      Object.defineProperty(exports, "ConfigStore", { enumerable: true, get: function() {
        return ConfigStore_1.ConfigStore;
      } });
      var parseDict_1 = require_parseDict();
      Object.defineProperty(exports, "parseDict", { enumerable: true, get: function() {
        return parseDict_1.parseDict;
      } });
      Object.defineProperty(exports, "parseDictBitString", { enumerable: true, get: function() {
        return parseDict_1.parseDictBitString;
      } });
      Object.defineProperty(exports, "parseDictRefs", { enumerable: true, get: function() {
        return parseDict_1.parseDictRefs;
      } });
      var serializeDict_1 = require_serializeDict();
      Object.defineProperty(exports, "serializeDict", { enumerable: true, get: function() {
        return serializeDict_1.serializeDict;
      } });
      var safeSign_1 = require_safeSign();
      Object.defineProperty(exports, "safeSign", { enumerable: true, get: function() {
        return safeSign_1.safeSign;
      } });
      Object.defineProperty(exports, "safeSignVerify", { enumerable: true, get: function() {
        return safeSign_1.safeSignVerify;
      } });
      var parse_1 = require_parse();
      Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
        return parse_1.parseTransaction;
      } });
      Object.defineProperty(exports, "parseAccountStatus", { enumerable: true, get: function() {
        return parse_1.parseAccountStatus;
      } });
      Object.defineProperty(exports, "parseCurrencyCollection", { enumerable: true, get: function() {
        return parse_1.parseCurrencyCollection;
      } });
      Object.defineProperty(exports, "parseCommonMsgInfo", { enumerable: true, get: function() {
        return parse_1.parseCommonMsgInfo;
      } });
      Object.defineProperty(exports, "parseStateInit", { enumerable: true, get: function() {
        return parse_1.parseStateInit;
      } });
      Object.defineProperty(exports, "parseMessage", { enumerable: true, get: function() {
        return parse_1.parseMessage;
      } });
      Object.defineProperty(exports, "parseMessageRelaxed", { enumerable: true, get: function() {
        return parse_1.parseMessageRelaxed;
      } });
      Object.defineProperty(exports, "parseHashUpdate", { enumerable: true, get: function() {
        return parse_1.parseHashUpdate;
      } });
      Object.defineProperty(exports, "parseAccountChange", { enumerable: true, get: function() {
        return parse_1.parseAccountChange;
      } });
      Object.defineProperty(exports, "parseStorageUsedShort", { enumerable: true, get: function() {
        return parse_1.parseStorageUsedShort;
      } });
      Object.defineProperty(exports, "parseStoragePhase", { enumerable: true, get: function() {
        return parse_1.parseStoragePhase;
      } });
      Object.defineProperty(exports, "parseCreditPhase", { enumerable: true, get: function() {
        return parse_1.parseCreditPhase;
      } });
      Object.defineProperty(exports, "parseComputePhase", { enumerable: true, get: function() {
        return parse_1.parseComputePhase;
      } });
      Object.defineProperty(exports, "parseActionPhase", { enumerable: true, get: function() {
        return parse_1.parseActionPhase;
      } });
      Object.defineProperty(exports, "parseBouncePhase", { enumerable: true, get: function() {
        return parse_1.parseBouncePhase;
      } });
      Object.defineProperty(exports, "parseTransactionDescription", { enumerable: true, get: function() {
        return parse_1.parseTransactionDescription;
      } });
      Object.defineProperty(exports, "parseRawTickTock", { enumerable: true, get: function() {
        return parse_1.parseRawTickTock;
      } });
      Object.defineProperty(exports, "parseStorageUsed", { enumerable: true, get: function() {
        return parse_1.parseStorageUsed;
      } });
      Object.defineProperty(exports, "parseStorageInfo", { enumerable: true, get: function() {
        return parse_1.parseStorageInfo;
      } });
      Object.defineProperty(exports, "parseAccountState", { enumerable: true, get: function() {
        return parse_1.parseAccountState;
      } });
      Object.defineProperty(exports, "parseAccountStorage", { enumerable: true, get: function() {
        return parse_1.parseAccountStorage;
      } });
      Object.defineProperty(exports, "parseAccount", { enumerable: true, get: function() {
        return parse_1.parseAccount;
      } });
      Object.defineProperty(exports, "parseShardIdent", { enumerable: true, get: function() {
        return parse_1.parseShardIdent;
      } });
      Object.defineProperty(exports, "parseShardAccount", { enumerable: true, get: function() {
        return parse_1.parseShardAccount;
      } });
      Object.defineProperty(exports, "parseDepthBalanceInfo", { enumerable: true, get: function() {
        return parse_1.parseDepthBalanceInfo;
      } });
      Object.defineProperty(exports, "parseShardAccounts", { enumerable: true, get: function() {
        return parse_1.parseShardAccounts;
      } });
      Object.defineProperty(exports, "parseShardStateUnsplit", { enumerable: true, get: function() {
        return parse_1.parseShardStateUnsplit;
      } });
      Object.defineProperty(exports, "parseMasterchainStateExtra", { enumerable: true, get: function() {
        return parse_1.parseMasterchainStateExtra;
      } });
      var stack_1 = require_stack();
      Object.defineProperty(exports, "serializeStack", { enumerable: true, get: function() {
        return stack_1.serializeStack;
      } });
      Object.defineProperty(exports, "parseStack", { enumerable: true, get: function() {
        return stack_1.parseStack;
      } });
      var TonClient4_1 = require_TonClient4();
      Object.defineProperty(exports, "TonClient4", { enumerable: true, get: function() {
        return TonClient4_1.TonClient4;
      } });
      var fees_1 = require_fees();
      Object.defineProperty(exports, "computeStorageFees", { enumerable: true, get: function() {
        return fees_1.computeStorageFees;
      } });
      Object.defineProperty(exports, "computeFwdFees", { enumerable: true, get: function() {
        return fees_1.computeFwdFees;
      } });
      Object.defineProperty(exports, "computeGasPrices", { enumerable: true, get: function() {
        return fees_1.computeGasPrices;
      } });
      Object.defineProperty(exports, "computeExternalMessageFees", { enumerable: true, get: function() {
        return fees_1.computeExternalMessageFees;
      } });
      Object.defineProperty(exports, "computeMessageForwardFees", { enumerable: true, get: function() {
        return fees_1.computeMessageForwardFees;
      } });
      var configParsing_1 = require_configParsing();
      Object.defineProperty(exports, "configParseMasterAddress", { enumerable: true, get: function() {
        return configParsing_1.configParseMasterAddress;
      } });
      Object.defineProperty(exports, "configParseWorkchainDescriptor", { enumerable: true, get: function() {
        return configParsing_1.configParseWorkchainDescriptor;
      } });
      Object.defineProperty(exports, "parseValidatorDescr", { enumerable: true, get: function() {
        return configParsing_1.parseValidatorDescr;
      } });
      Object.defineProperty(exports, "parseValidatorSet", { enumerable: true, get: function() {
        return configParsing_1.parseValidatorSet;
      } });
      Object.defineProperty(exports, "parseBridge", { enumerable: true, get: function() {
        return configParsing_1.parseBridge;
      } });
      Object.defineProperty(exports, "configParseMasterAddressRequired", { enumerable: true, get: function() {
        return configParsing_1.configParseMasterAddressRequired;
      } });
      Object.defineProperty(exports, "configParse15", { enumerable: true, get: function() {
        return configParsing_1.configParse15;
      } });
      Object.defineProperty(exports, "configParse16", { enumerable: true, get: function() {
        return configParsing_1.configParse16;
      } });
      Object.defineProperty(exports, "configParse17", { enumerable: true, get: function() {
        return configParsing_1.configParse17;
      } });
      Object.defineProperty(exports, "configParse18", { enumerable: true, get: function() {
        return configParsing_1.configParse18;
      } });
      Object.defineProperty(exports, "configParse8", { enumerable: true, get: function() {
        return configParsing_1.configParse8;
      } });
      Object.defineProperty(exports, "configParse40", { enumerable: true, get: function() {
        return configParsing_1.configParse40;
      } });
      Object.defineProperty(exports, "configParse12", { enumerable: true, get: function() {
        return configParsing_1.configParse12;
      } });
      Object.defineProperty(exports, "configParseValidatorSet", { enumerable: true, get: function() {
        return configParsing_1.configParseValidatorSet;
      } });
      Object.defineProperty(exports, "configParseBridge", { enumerable: true, get: function() {
        return configParsing_1.configParseBridge;
      } });
      Object.defineProperty(exports, "configParseGasLimitsPrices", { enumerable: true, get: function() {
        return configParsing_1.configParseGasLimitsPrices;
      } });
      Object.defineProperty(exports, "configParseMsgPrices", { enumerable: true, get: function() {
        return configParsing_1.configParseMsgPrices;
      } });
      Object.defineProperty(exports, "parseFullConfig", { enumerable: true, get: function() {
        return configParsing_1.parseFullConfig;
      } });
      Object.defineProperty(exports, "configParse28", { enumerable: true, get: function() {
        return configParsing_1.configParse28;
      } });
      Object.defineProperty(exports, "configParse29", { enumerable: true, get: function() {
        return configParsing_1.configParse29;
      } });
      var index_1 = require_traits();
      Object.defineProperty(exports, "Traits", { enumerable: true, get: function() {
        return index_1.Traits;
      } });
    }
  });

  // node_modules/bn.js/lib/bn.js
  var require_bn4 = __commonJS({
    "node_modules/bn.js/lib/bn.js"(exports, module) {
      (function(module2, exports2) {
        "use strict";
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number, base, endian) {
          if (BN2.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = require_buffer().Buffer;
          }
        } catch (e) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN2.prototype._init = function init(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN2.prototype._initArray = function _initArray(number, base, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string, index) {
          var c = string.charCodeAt(index);
          if (c >= 48 && c <= 57) {
            return c - 48;
          } else if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            assert(false, "Invalid character in " + string);
          }
        }
        function parseHexByte(string, lowerBound, index) {
          var r = parseHex4Bits(string, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string, index - 1) << 4;
          }
          return r;
        }
        BN2.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var b = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              b = c - 49 + 10;
            } else if (c >= 17) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            assert(c >= 0 && b < mul, "Invalid character");
            r += b;
          }
          return r;
        }
        BN2.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN2.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words;
          dest.length = src.length;
          dest.negative = src.negative;
          dest.red = src.red;
        }
        BN2.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN2.prototype.clone = function clone() {
          var r = new BN2(null);
          this.copy(r);
          return r;
        };
        BN2.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
          } catch (e) {
            BN2.prototype.inspect = inspect;
          }
        } else {
          BN2.prototype.inspect = inspect;
        }
        function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modrn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16, 2);
        };
        if (Buffer2) {
          BN2.prototype.toBuffer = function toBuffer(endian, length) {
            return this.toArrayLike(Buffer2, endian, length);
          };
        }
        BN2.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType, size) {
          if (ArrayType.allocUnsafe) {
            return ArrayType.allocUnsafe(size);
          }
          return new ArrayType(size);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          this._strip();
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert(byteLength <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength);
          return res;
        };
        BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
          var position = 0;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
          var position = res.length - 1;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 1;
          }
          return w;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN2.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this._strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this._strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN2.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN2.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out._strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN2(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this._strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this._strip();
          assert(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div2, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div2 = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div: div2,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div2 = res.div.neg();
            }
            return {
              div: div2,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div2(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN2.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN2.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN2.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN2(1);
          var x2 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          move(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN2(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN2(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN2(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // node_modules/whatwg-fetch/dist/fetch.umd.js
  var require_fetch_umd = __commonJS({
    "node_modules/whatwg-fetch/dist/fetch.umd.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.WHATWGFetch = {});
      })(exports, function(exports2) {
        "use strict";
        var global2 = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global2 !== "undefined" && global2;
        var support = {
          searchParams: "URLSearchParams" in global2,
          iterable: "Symbol" in global2 && "iterator" in Symbol,
          blob: "FileReader" in global2 && "Blob" in global2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in global2,
          arrayBuffer: "ArrayBuffer" in global2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                var isConsumed = consumed(this);
                if (isConsumed) {
                  return isConsumed;
                }
                if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                  return Promise.resolve(
                    this._bodyArrayBuffer.buffer.slice(
                      this._bodyArrayBuffer.byteOffset,
                      this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                    )
                  );
                } else {
                  return Promise.resolve(this._bodyArrayBuffer);
                }
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = global2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && global2.location.href ? global2.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers)) {
              Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
              });
            } else {
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!global2.fetch) {
          global2.fetch = fetch2;
          global2.Headers = Headers;
          global2.Request = Request;
          global2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/isomorphic-fetch/fetch-npm-browserify.js
  var require_fetch_npm_browserify = __commonJS({
    "node_modules/isomorphic-fetch/fetch-npm-browserify.js"(exports, module) {
      require_fetch_umd();
      module.exports = self.fetch.bind(self);
    }
  });

  // node_modules/@orbs-network/ton-access/lib/nodes.js
  var require_nodes = __commonJS({
    "node_modules/@orbs-network/ton-access/lib/nodes.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Nodes = void 0;
      require_fetch_npm_browserify();
      var Nodes = class {
        constructor() {
          this.nodeIndex = -1;
          this.committee = /* @__PURE__ */ new Set();
          this.topology = [];
        }
        init(nodesUrl) {
          return __awaiter(this, void 0, void 0, function* () {
            this.nodeIndex = -1;
            this.committee.clear();
            this.topology = [];
            let topology = [];
            try {
              const response = yield fetch(nodesUrl);
              const data = yield response.json();
              topology = data;
            } catch (e) {
              throw new Error(`exception in fetch(${nodesUrl}): ${e}`);
            }
            for (const node of topology) {
              if (node.Healthy === "1") {
                this.topology.push(node);
              }
            }
            if (this.topology.length === 0)
              throw new Error(`no healthy nodes retrieved`);
          });
        }
        getNextNode(committeeOnly = true) {
          while (true) {
            this.nodeIndex++;
            if (this.nodeIndex >= this.topology.length)
              this.nodeIndex = 0;
            return this.topology[this.nodeIndex];
          }
        }
        getRandomNode(committeeOnly = true) {
          const index = Math.floor(Math.random() * this.topology.length);
          return this.topology[index];
        }
      };
      exports.Nodes = Nodes;
    }
  });

  // node_modules/@orbs-network/ton-access/lib/index.js
  var require_lib3 = __commonJS({
    "node_modules/@orbs-network/ton-access/lib/index.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getHttpV4Endpoint = exports.getHttpV4Endpoints = exports.getHttpEndpoint = exports.getHttpEndpoints = exports.Access = void 0;
      var nodes_1 = require_nodes();
      var Access = class {
        constructor() {
          this.host = "ton.access.orbs.network";
          this.urlVersion = 1;
          this.nodes = new nodes_1.Nodes();
        }
        init() {
          return __awaiter(this, void 0, void 0, function* () {
            yield this.nodes.init(`https://${this.host}/nodes`);
          });
        }
        buildUrls(network, edgeProtocol, suffix) {
          if (!suffix)
            suffix = "";
          if (suffix.length)
            suffix = suffix.replace(/^\/+/, "");
          const res = [];
          const len = this.nodes.topology.length;
          for (let i = 0; i < len; ++i) {
            const node = this.nodes.getNextNode();
            const url = `https://${this.host}/${node.Name}/${this.urlVersion}/${network}/${edgeProtocol}/${suffix}`;
            res.push(url);
          }
          return res;
        }
      };
      exports.Access = Access;
      function getEndpoints(network, edgeProtocol, suffix) {
        return __awaiter(this, void 0, void 0, function* () {
          const access = new Access();
          yield access.init();
          const res = access.buildUrls(network, edgeProtocol, suffix);
          return res;
        });
      }
      function getHttpEndpoints(config) {
        return __awaiter(this, void 0, void 0, function* () {
          const network = (config === null || config === void 0 ? void 0 : config.network) ? config.network : "mainnet";
          let suffix = "jsonRPC";
          if ((config === null || config === void 0 ? void 0 : config.protocol) === "rest") {
            suffix = "";
          }
          return yield getEndpoints(network, "toncenter-api-v2", suffix);
        });
      }
      exports.getHttpEndpoints = getHttpEndpoints;
      function getHttpEndpoint2(config) {
        return __awaiter(this, void 0, void 0, function* () {
          const endpoints = yield getHttpEndpoints(config);
          const index = Math.floor(Math.random() * endpoints.length);
          return endpoints[index];
        });
      }
      exports.getHttpEndpoint = getHttpEndpoint2;
      function getHttpV4Endpoints(config) {
        return __awaiter(this, void 0, void 0, function* () {
          const network = (config === null || config === void 0 ? void 0 : config.network) ? config.network : "mainnet";
          if ((config === null || config === void 0 ? void 0 : config.protocol) === "json-rpc") {
            throw Error("config.protocol json-rpc is not supported for getTonApiV4Endpoints");
          }
          const suffix = "";
          return yield getEndpoints(network, "ton-api-v4", suffix);
        });
      }
      exports.getHttpV4Endpoints = getHttpV4Endpoints;
      function getHttpV4Endpoint(config) {
        return __awaiter(this, void 0, void 0, function* () {
          const endpoints = yield getHttpV4Endpoints(config);
          const index = Math.floor(Math.random() * endpoints.length);
          return endpoints[index];
        });
      }
      exports.getHttpV4Endpoint = getHttpV4Endpoint;
    }
  });

  // node_modules/@aws-crypto/sha256-js/node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "node_modules/@aws-crypto/sha256-js/node_modules/tslib/tslib.js"(exports, module) {
      var __extends;
      var __assign;
      var __rest;
      var __decorate;
      var __param;
      var __metadata;
      var __awaiter;
      var __generator;
      var __exportStar;
      var __values;
      var __read;
      var __spread;
      var __spreadArrays;
      var __await;
      var __asyncGenerator;
      var __asyncDelegator;
      var __asyncValues;
      var __makeTemplateObject;
      var __importStar;
      var __importDefault;
      var __classPrivateFieldGet;
      var __classPrivateFieldSet;
      var __createBinding;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        __extends = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __createBinding = function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __exportStar = function(m, exports2) {
          for (var p in m)
            if (p !== "default" && !exports2.hasOwnProperty(p))
              exports2[p] = m[p];
        };
        __values = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
          return ar;
        };
        __spreadArrays = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await = function(v) {
          return this instanceof __await ? (this.v = v, this) : new __await(v);
        };
        __asyncGenerator = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (Object.hasOwnProperty.call(mod, k))
                result[k] = mod[k];
          }
          result["default"] = mod;
          return result;
        };
        __importDefault = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends);
        exporter("__assign", __assign);
        exporter("__rest", __rest);
        exporter("__decorate", __decorate);
        exporter("__param", __param);
        exporter("__metadata", __metadata);
        exporter("__awaiter", __awaiter);
        exporter("__generator", __generator);
        exporter("__exportStar", __exportStar);
        exporter("__createBinding", __createBinding);
        exporter("__values", __values);
        exporter("__read", __read);
        exporter("__spread", __spread);
        exporter("__spreadArrays", __spreadArrays);
        exporter("__await", __await);
        exporter("__asyncGenerator", __asyncGenerator);
        exporter("__asyncDelegator", __asyncDelegator);
        exporter("__asyncValues", __asyncValues);
        exporter("__makeTemplateObject", __makeTemplateObject);
        exporter("__importStar", __importStar);
        exporter("__importDefault", __importDefault);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet);
      });
    }
  });

  // node_modules/@aws-crypto/sha256-js/build/constants.js
  var require_constants = __commonJS({
    "node_modules/@aws-crypto/sha256-js/build/constants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MAX_HASHABLE_LENGTH = exports.INIT = exports.KEY = exports.DIGEST_LENGTH = exports.BLOCK_SIZE = void 0;
      exports.BLOCK_SIZE = 64;
      exports.DIGEST_LENGTH = 32;
      exports.KEY = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      exports.INIT = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      exports.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
    }
  });

  // node_modules/@aws-crypto/sha256-js/build/RawSha256.js
  var require_RawSha256 = __commonJS({
    "node_modules/@aws-crypto/sha256-js/build/RawSha256.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RawSha256 = void 0;
      var constants_1 = require_constants();
      var RawSha256 = function() {
        function RawSha2562() {
          this.state = Int32Array.from(constants_1.INIT);
          this.temp = new Int32Array(64);
          this.buffer = new Uint8Array(64);
          this.bufferLength = 0;
          this.bytesHashed = 0;
          this.finished = false;
        }
        RawSha2562.prototype.update = function(data) {
          if (this.finished) {
            throw new Error("Attempted to update an already finished hash.");
          }
          var position = 0;
          var byteLength = data.byteLength;
          this.bytesHashed += byteLength;
          if (this.bytesHashed * 8 > constants_1.MAX_HASHABLE_LENGTH) {
            throw new Error("Cannot hash more than 2^53 - 1 bits");
          }
          while (byteLength > 0) {
            this.buffer[this.bufferLength++] = data[position++];
            byteLength--;
            if (this.bufferLength === constants_1.BLOCK_SIZE) {
              this.hashBuffer();
              this.bufferLength = 0;
            }
          }
        };
        RawSha2562.prototype.digest = function() {
          if (!this.finished) {
            var bitsHashed = this.bytesHashed * 8;
            var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
            var undecoratedLength = this.bufferLength;
            bufferView.setUint8(this.bufferLength++, 128);
            if (undecoratedLength % constants_1.BLOCK_SIZE >= constants_1.BLOCK_SIZE - 8) {
              for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE; i++) {
                bufferView.setUint8(i, 0);
              }
              this.hashBuffer();
              this.bufferLength = 0;
            }
            for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE - 8; i++) {
              bufferView.setUint8(i, 0);
            }
            bufferView.setUint32(constants_1.BLOCK_SIZE - 8, Math.floor(bitsHashed / 4294967296), true);
            bufferView.setUint32(constants_1.BLOCK_SIZE - 4, bitsHashed);
            this.hashBuffer();
            this.finished = true;
          }
          var out = new Uint8Array(constants_1.DIGEST_LENGTH);
          for (var i = 0; i < 8; i++) {
            out[i * 4] = this.state[i] >>> 24 & 255;
            out[i * 4 + 1] = this.state[i] >>> 16 & 255;
            out[i * 4 + 2] = this.state[i] >>> 8 & 255;
            out[i * 4 + 3] = this.state[i] >>> 0 & 255;
          }
          return out;
        };
        RawSha2562.prototype.hashBuffer = function() {
          var _a = this, buffer = _a.buffer, state = _a.state;
          var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
          for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {
            if (i < 16) {
              this.temp[i] = (buffer[i * 4] & 255) << 24 | (buffer[i * 4 + 1] & 255) << 16 | (buffer[i * 4 + 2] & 255) << 8 | buffer[i * 4 + 3] & 255;
            } else {
              var u = this.temp[i - 2];
              var t1_1 = (u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10;
              u = this.temp[i - 15];
              var t2_1 = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3;
              this.temp[i] = (t1_1 + this.temp[i - 7] | 0) + (t2_1 + this.temp[i - 16] | 0);
            }
            var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (constants_1.KEY[i] + this.temp[i] | 0) | 0) | 0;
            var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;
            state7 = state6;
            state6 = state5;
            state5 = state4;
            state4 = state3 + t1 | 0;
            state3 = state2;
            state2 = state1;
            state1 = state0;
            state0 = t1 + t2 | 0;
          }
          state[0] += state0;
          state[1] += state1;
          state[2] += state2;
          state[3] += state3;
          state[4] += state4;
          state[5] += state5;
          state[6] += state6;
          state[7] += state7;
        };
        return RawSha2562;
      }();
      exports.RawSha256 = RawSha256;
    }
  });

  // node_modules/@aws-sdk/util-utf8-browser/dist-cjs/pureJs.js
  var require_pureJs = __commonJS({
    "node_modules/@aws-sdk/util-utf8-browser/dist-cjs/pureJs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toUtf8 = exports.fromUtf8 = void 0;
      var fromUtf8 = (input) => {
        const bytes = [];
        for (let i = 0, len = input.length; i < len; i++) {
          const value = input.charCodeAt(i);
          if (value < 128) {
            bytes.push(value);
          } else if (value < 2048) {
            bytes.push(value >> 6 | 192, value & 63 | 128);
          } else if (i + 1 < input.length && (value & 64512) === 55296 && (input.charCodeAt(i + 1) & 64512) === 56320) {
            const surrogatePair = 65536 + ((value & 1023) << 10) + (input.charCodeAt(++i) & 1023);
            bytes.push(surrogatePair >> 18 | 240, surrogatePair >> 12 & 63 | 128, surrogatePair >> 6 & 63 | 128, surrogatePair & 63 | 128);
          } else {
            bytes.push(value >> 12 | 224, value >> 6 & 63 | 128, value & 63 | 128);
          }
        }
        return Uint8Array.from(bytes);
      };
      exports.fromUtf8 = fromUtf8;
      var toUtf8 = (input) => {
        let decoded = "";
        for (let i = 0, len = input.length; i < len; i++) {
          const byte = input[i];
          if (byte < 128) {
            decoded += String.fromCharCode(byte);
          } else if (192 <= byte && byte < 224) {
            const nextByte = input[++i];
            decoded += String.fromCharCode((byte & 31) << 6 | nextByte & 63);
          } else if (240 <= byte && byte < 365) {
            const surrogatePair = [byte, input[++i], input[++i], input[++i]];
            const encoded = "%" + surrogatePair.map((byteValue) => byteValue.toString(16)).join("%");
            decoded += decodeURIComponent(encoded);
          } else {
            decoded += String.fromCharCode((byte & 15) << 12 | (input[++i] & 63) << 6 | input[++i] & 63);
          }
        }
        return decoded;
      };
      exports.toUtf8 = toUtf8;
    }
  });

  // node_modules/@aws-sdk/util-utf8-browser/dist-cjs/whatwgEncodingApi.js
  var require_whatwgEncodingApi = __commonJS({
    "node_modules/@aws-sdk/util-utf8-browser/dist-cjs/whatwgEncodingApi.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toUtf8 = exports.fromUtf8 = void 0;
      function fromUtf8(input) {
        return new TextEncoder().encode(input);
      }
      exports.fromUtf8 = fromUtf8;
      function toUtf8(input) {
        return new TextDecoder("utf-8").decode(input);
      }
      exports.toUtf8 = toUtf8;
    }
  });

  // node_modules/@aws-sdk/util-utf8-browser/dist-cjs/index.js
  var require_dist_cjs = __commonJS({
    "node_modules/@aws-sdk/util-utf8-browser/dist-cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toUtf8 = exports.fromUtf8 = void 0;
      var pureJs_1 = require_pureJs();
      var whatwgEncodingApi_1 = require_whatwgEncodingApi();
      var fromUtf8 = (input) => typeof TextEncoder === "function" ? (0, whatwgEncodingApi_1.fromUtf8)(input) : (0, pureJs_1.fromUtf8)(input);
      exports.fromUtf8 = fromUtf8;
      var toUtf8 = (input) => typeof TextDecoder === "function" ? (0, whatwgEncodingApi_1.toUtf8)(input) : (0, pureJs_1.toUtf8)(input);
      exports.toUtf8 = toUtf8;
    }
  });

  // node_modules/@aws-crypto/util/build/convertToBuffer.js
  var require_convertToBuffer = __commonJS({
    "node_modules/@aws-crypto/util/build/convertToBuffer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.convertToBuffer = void 0;
      var util_utf8_browser_1 = require_dist_cjs();
      var fromUtf8 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
        return Buffer.from(input, "utf8");
      } : util_utf8_browser_1.fromUtf8;
      function convertToBuffer(data) {
        if (data instanceof Uint8Array)
          return data;
        if (typeof data === "string") {
          return fromUtf8(data);
        }
        if (ArrayBuffer.isView(data)) {
          return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
        }
        return new Uint8Array(data);
      }
      exports.convertToBuffer = convertToBuffer;
    }
  });

  // node_modules/@aws-crypto/util/build/isEmptyData.js
  var require_isEmptyData = __commonJS({
    "node_modules/@aws-crypto/util/build/isEmptyData.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isEmptyData = void 0;
      function isEmptyData(data) {
        if (typeof data === "string") {
          return data.length === 0;
        }
        return data.byteLength === 0;
      }
      exports.isEmptyData = isEmptyData;
    }
  });

  // node_modules/@aws-crypto/util/build/numToUint8.js
  var require_numToUint8 = __commonJS({
    "node_modules/@aws-crypto/util/build/numToUint8.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.numToUint8 = void 0;
      function numToUint8(num) {
        return new Uint8Array([
          (num & 4278190080) >> 24,
          (num & 16711680) >> 16,
          (num & 65280) >> 8,
          num & 255
        ]);
      }
      exports.numToUint8 = numToUint8;
    }
  });

  // node_modules/@aws-crypto/util/build/uint32ArrayFrom.js
  var require_uint32ArrayFrom = __commonJS({
    "node_modules/@aws-crypto/util/build/uint32ArrayFrom.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.uint32ArrayFrom = void 0;
      function uint32ArrayFrom(a_lookUpTable) {
        if (!Uint32Array.from) {
          var return_array = new Uint32Array(a_lookUpTable.length);
          var a_index = 0;
          while (a_index < a_lookUpTable.length) {
            return_array[a_index] = a_lookUpTable[a_index];
            a_index += 1;
          }
          return return_array;
        }
        return Uint32Array.from(a_lookUpTable);
      }
      exports.uint32ArrayFrom = uint32ArrayFrom;
    }
  });

  // node_modules/@aws-crypto/util/build/index.js
  var require_build = __commonJS({
    "node_modules/@aws-crypto/util/build/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
      var convertToBuffer_1 = require_convertToBuffer();
      Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function() {
        return convertToBuffer_1.convertToBuffer;
      } });
      var isEmptyData_1 = require_isEmptyData();
      Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function() {
        return isEmptyData_1.isEmptyData;
      } });
      var numToUint8_1 = require_numToUint8();
      Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function() {
        return numToUint8_1.numToUint8;
      } });
      var uint32ArrayFrom_1 = require_uint32ArrayFrom();
      Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function() {
        return uint32ArrayFrom_1.uint32ArrayFrom;
      } });
    }
  });

  // node_modules/@aws-crypto/sha256-js/build/jsSha256.js
  var require_jsSha256 = __commonJS({
    "node_modules/@aws-crypto/sha256-js/build/jsSha256.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Sha256 = void 0;
      var tslib_1 = require_tslib();
      var constants_1 = require_constants();
      var RawSha256_1 = require_RawSha256();
      var util_1 = require_build();
      var Sha2562 = function() {
        function Sha2563(secret) {
          this.hash = new RawSha256_1.RawSha256();
          if (secret) {
            this.outer = new RawSha256_1.RawSha256();
            var inner = bufferFromSecret(secret);
            var outer = new Uint8Array(constants_1.BLOCK_SIZE);
            outer.set(inner);
            for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {
              inner[i] ^= 54;
              outer[i] ^= 92;
            }
            this.hash.update(inner);
            this.outer.update(outer);
            for (var i = 0; i < inner.byteLength; i++) {
              inner[i] = 0;
            }
          }
        }
        Sha2563.prototype.update = function(toHash) {
          if ((0, util_1.isEmptyData)(toHash) || this.error) {
            return;
          }
          try {
            this.hash.update((0, util_1.convertToBuffer)(toHash));
          } catch (e) {
            this.error = e;
          }
        };
        Sha2563.prototype.digestSync = function() {
          if (this.error) {
            throw this.error;
          }
          if (this.outer) {
            if (!this.outer.finished) {
              this.outer.update(this.hash.digest());
            }
            return this.outer.digest();
          }
          return this.hash.digest();
        };
        Sha2563.prototype.digest = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              return [2, this.digestSync()];
            });
          });
        };
        return Sha2563;
      }();
      exports.Sha256 = Sha2562;
      function bufferFromSecret(secret) {
        var input = (0, util_1.convertToBuffer)(secret);
        if (input.byteLength > constants_1.BLOCK_SIZE) {
          var bufferHash = new RawSha256_1.RawSha256();
          bufferHash.update(input);
          input = bufferHash.digest();
        }
        var buffer = new Uint8Array(constants_1.BLOCK_SIZE);
        buffer.set(input);
        return buffer;
      }
    }
  });

  // node_modules/@aws-crypto/sha256-js/build/index.js
  var require_build2 = __commonJS({
    "node_modules/@aws-crypto/sha256-js/build/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = require_tslib();
      tslib_1.__exportStar(require_jsSha256(), exports);
    }
  });

  // node_modules/highlight.js/lib/core.js
  var require_core = __commonJS({
    "node_modules/highlight.js/lib/core.js"(exports, module) {
      var deepFreezeEs6 = { exports: {} };
      function deepFreeze(obj) {
        if (obj instanceof Map) {
          obj.clear = obj.delete = obj.set = function() {
            throw new Error("map is read-only");
          };
        } else if (obj instanceof Set) {
          obj.add = obj.clear = obj.delete = function() {
            throw new Error("set is read-only");
          };
        }
        Object.freeze(obj);
        Object.getOwnPropertyNames(obj).forEach(function(name) {
          var prop = obj[name];
          if (typeof prop == "object" && !Object.isFrozen(prop)) {
            deepFreeze(prop);
          }
        });
        return obj;
      }
      deepFreezeEs6.exports = deepFreeze;
      deepFreezeEs6.exports.default = deepFreeze;
      var Response = class {
        constructor(mode) {
          if (mode.data === void 0)
            mode.data = {};
          this.data = mode.data;
          this.isMatchIgnored = false;
        }
        ignoreMatch() {
          this.isMatchIgnored = true;
        }
      };
      function escapeHTML(value) {
        return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
      }
      function inherit$1(original, ...objects) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const key in original) {
          result[key] = original[key];
        }
        objects.forEach(function(obj) {
          for (const key in obj) {
            result[key] = obj[key];
          }
        });
        return result;
      }
      var SPAN_CLOSE = "</span>";
      var emitsWrappingTags = (node) => {
        return !!node.scope || node.sublanguage && node.language;
      };
      var scopeToCSSClass = (name, { prefix }) => {
        if (name.includes(".")) {
          const pieces = name.split(".");
          return [
            `${prefix}${pieces.shift()}`,
            ...pieces.map((x, i) => `${x}${"_".repeat(i + 1)}`)
          ].join(" ");
        }
        return `${prefix}${name}`;
      };
      var HTMLRenderer = class {
        constructor(parseTree, options) {
          this.buffer = "";
          this.classPrefix = options.classPrefix;
          parseTree.walk(this);
        }
        addText(text) {
          this.buffer += escapeHTML(text);
        }
        openNode(node) {
          if (!emitsWrappingTags(node))
            return;
          let className = "";
          if (node.sublanguage) {
            className = `language-${node.language}`;
          } else {
            className = scopeToCSSClass(node.scope, { prefix: this.classPrefix });
          }
          this.span(className);
        }
        closeNode(node) {
          if (!emitsWrappingTags(node))
            return;
          this.buffer += SPAN_CLOSE;
        }
        value() {
          return this.buffer;
        }
        span(className) {
          this.buffer += `<span class="${className}">`;
        }
      };
      var newNode = (opts = {}) => {
        const result = { children: [] };
        Object.assign(result, opts);
        return result;
      };
      var TokenTree = class {
        constructor() {
          this.rootNode = newNode();
          this.stack = [this.rootNode];
        }
        get top() {
          return this.stack[this.stack.length - 1];
        }
        get root() {
          return this.rootNode;
        }
        add(node) {
          this.top.children.push(node);
        }
        openNode(scope) {
          const node = newNode({ scope });
          this.add(node);
          this.stack.push(node);
        }
        closeNode() {
          if (this.stack.length > 1) {
            return this.stack.pop();
          }
          return void 0;
        }
        closeAllNodes() {
          while (this.closeNode())
            ;
        }
        toJSON() {
          return JSON.stringify(this.rootNode, null, 4);
        }
        walk(builder) {
          return this.constructor._walk(builder, this.rootNode);
        }
        static _walk(builder, node) {
          if (typeof node === "string") {
            builder.addText(node);
          } else if (node.children) {
            builder.openNode(node);
            node.children.forEach((child) => this._walk(builder, child));
            builder.closeNode(node);
          }
          return builder;
        }
        static _collapse(node) {
          if (typeof node === "string")
            return;
          if (!node.children)
            return;
          if (node.children.every((el) => typeof el === "string")) {
            node.children = [node.children.join("")];
          } else {
            node.children.forEach((child) => {
              TokenTree._collapse(child);
            });
          }
        }
      };
      var TokenTreeEmitter = class extends TokenTree {
        constructor(options) {
          super();
          this.options = options;
        }
        addKeyword(text, scope) {
          if (text === "") {
            return;
          }
          this.openNode(scope);
          this.addText(text);
          this.closeNode();
        }
        addText(text) {
          if (text === "") {
            return;
          }
          this.add(text);
        }
        addSublanguage(emitter, name) {
          const node = emitter.root;
          node.sublanguage = true;
          node.language = name;
          this.add(node);
        }
        toHTML() {
          const renderer = new HTMLRenderer(this, this.options);
          return renderer.value();
        }
        finalize() {
          return true;
        }
      };
      function source(re) {
        if (!re)
          return null;
        if (typeof re === "string")
          return re;
        return re.source;
      }
      function lookahead(re) {
        return concat("(?=", re, ")");
      }
      function anyNumberOfTimes(re) {
        return concat("(?:", re, ")*");
      }
      function optional(re) {
        return concat("(?:", re, ")?");
      }
      function concat(...args) {
        const joined = args.map((x) => source(x)).join("");
        return joined;
      }
      function stripOptionsFromArgs(args) {
        const opts = args[args.length - 1];
        if (typeof opts === "object" && opts.constructor === Object) {
          args.splice(args.length - 1, 1);
          return opts;
        } else {
          return {};
        }
      }
      function either(...args) {
        const opts = stripOptionsFromArgs(args);
        const joined = "(" + (opts.capture ? "" : "?:") + args.map((x) => source(x)).join("|") + ")";
        return joined;
      }
      function countMatchGroups(re) {
        return new RegExp(re.toString() + "|").exec("").length - 1;
      }
      function startsWith(re, lexeme) {
        const match = re && re.exec(lexeme);
        return match && match.index === 0;
      }
      var BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
      function _rewriteBackreferences(regexps, { joinWith }) {
        let numCaptures = 0;
        return regexps.map((regex) => {
          numCaptures += 1;
          const offset = numCaptures;
          let re = source(regex);
          let out = "";
          while (re.length > 0) {
            const match = BACKREF_RE.exec(re);
            if (!match) {
              out += re;
              break;
            }
            out += re.substring(0, match.index);
            re = re.substring(match.index + match[0].length);
            if (match[0][0] === "\\" && match[1]) {
              out += "\\" + String(Number(match[1]) + offset);
            } else {
              out += match[0];
              if (match[0] === "(") {
                numCaptures++;
              }
            }
          }
          return out;
        }).map((re) => `(${re})`).join(joinWith);
      }
      var MATCH_NOTHING_RE = /\b\B/;
      var IDENT_RE = "[a-zA-Z]\\w*";
      var UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
      var NUMBER_RE = "\\b\\d+(\\.\\d+)?";
      var C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
      var BINARY_NUMBER_RE = "\\b(0b[01]+)";
      var RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
      var SHEBANG = (opts = {}) => {
        const beginShebang = /^#![ ]*\//;
        if (opts.binary) {
          opts.begin = concat(
            beginShebang,
            /.*\b/,
            opts.binary,
            /\b.*/
          );
        }
        return inherit$1({
          scope: "meta",
          begin: beginShebang,
          end: /$/,
          relevance: 0,
          "on:begin": (m, resp) => {
            if (m.index !== 0)
              resp.ignoreMatch();
          }
        }, opts);
      };
      var BACKSLASH_ESCAPE = {
        begin: "\\\\[\\s\\S]",
        relevance: 0
      };
      var APOS_STRING_MODE = {
        scope: "string",
        begin: "'",
        end: "'",
        illegal: "\\n",
        contains: [BACKSLASH_ESCAPE]
      };
      var QUOTE_STRING_MODE = {
        scope: "string",
        begin: '"',
        end: '"',
        illegal: "\\n",
        contains: [BACKSLASH_ESCAPE]
      };
      var PHRASAL_WORDS_MODE = {
        begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
      };
      var COMMENT = function(begin, end, modeOptions = {}) {
        const mode = inherit$1(
          {
            scope: "comment",
            begin,
            end,
            contains: []
          },
          modeOptions
        );
        mode.contains.push({
          scope: "doctag",
          begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
          end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
          excludeBegin: true,
          relevance: 0
        });
        const ENGLISH_WORD = either(
          "I",
          "a",
          "is",
          "so",
          "us",
          "to",
          "at",
          "if",
          "in",
          "it",
          "on",
          /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
          /[A-Za-z]+[-][a-z]+/,
          /[A-Za-z][a-z]{2,}/
        );
        mode.contains.push(
          {
            begin: concat(
              /[ ]+/,
              "(",
              ENGLISH_WORD,
              /[.]?[:]?([.][ ]|[ ])/,
              "){3}"
            )
          }
        );
        return mode;
      };
      var C_LINE_COMMENT_MODE = COMMENT("//", "$");
      var C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
      var HASH_COMMENT_MODE = COMMENT("#", "$");
      var NUMBER_MODE = {
        scope: "number",
        begin: NUMBER_RE,
        relevance: 0
      };
      var C_NUMBER_MODE = {
        scope: "number",
        begin: C_NUMBER_RE,
        relevance: 0
      };
      var BINARY_NUMBER_MODE = {
        scope: "number",
        begin: BINARY_NUMBER_RE,
        relevance: 0
      };
      var REGEXP_MODE = {
        begin: /(?=\/[^/\n]*\/)/,
        contains: [{
          scope: "regexp",
          begin: /\//,
          end: /\/[gimuy]*/,
          illegal: /\n/,
          contains: [
            BACKSLASH_ESCAPE,
            {
              begin: /\[/,
              end: /\]/,
              relevance: 0,
              contains: [BACKSLASH_ESCAPE]
            }
          ]
        }]
      };
      var TITLE_MODE = {
        scope: "title",
        begin: IDENT_RE,
        relevance: 0
      };
      var UNDERSCORE_TITLE_MODE = {
        scope: "title",
        begin: UNDERSCORE_IDENT_RE,
        relevance: 0
      };
      var METHOD_GUARD = {
        begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
        relevance: 0
      };
      var END_SAME_AS_BEGIN = function(mode) {
        return Object.assign(
          mode,
          {
            "on:begin": (m, resp) => {
              resp.data._beginMatch = m[1];
            },
            "on:end": (m, resp) => {
              if (resp.data._beginMatch !== m[1])
                resp.ignoreMatch();
            }
          }
        );
      };
      var MODES = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        MATCH_NOTHING_RE,
        IDENT_RE,
        UNDERSCORE_IDENT_RE,
        NUMBER_RE,
        C_NUMBER_RE,
        BINARY_NUMBER_RE,
        RE_STARTERS_RE,
        SHEBANG,
        BACKSLASH_ESCAPE,
        APOS_STRING_MODE,
        QUOTE_STRING_MODE,
        PHRASAL_WORDS_MODE,
        COMMENT,
        C_LINE_COMMENT_MODE,
        C_BLOCK_COMMENT_MODE,
        HASH_COMMENT_MODE,
        NUMBER_MODE,
        C_NUMBER_MODE,
        BINARY_NUMBER_MODE,
        REGEXP_MODE,
        TITLE_MODE,
        UNDERSCORE_TITLE_MODE,
        METHOD_GUARD,
        END_SAME_AS_BEGIN
      });
      function skipIfHasPrecedingDot(match, response) {
        const before = match.input[match.index - 1];
        if (before === ".") {
          response.ignoreMatch();
        }
      }
      function scopeClassName(mode, _parent) {
        if (mode.className !== void 0) {
          mode.scope = mode.className;
          delete mode.className;
        }
      }
      function beginKeywords(mode, parent) {
        if (!parent)
          return;
        if (!mode.beginKeywords)
          return;
        mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
        mode.__beforeBegin = skipIfHasPrecedingDot;
        mode.keywords = mode.keywords || mode.beginKeywords;
        delete mode.beginKeywords;
        if (mode.relevance === void 0)
          mode.relevance = 0;
      }
      function compileIllegal(mode, _parent) {
        if (!Array.isArray(mode.illegal))
          return;
        mode.illegal = either(...mode.illegal);
      }
      function compileMatch(mode, _parent) {
        if (!mode.match)
          return;
        if (mode.begin || mode.end)
          throw new Error("begin & end are not supported with match");
        mode.begin = mode.match;
        delete mode.match;
      }
      function compileRelevance(mode, _parent) {
        if (mode.relevance === void 0)
          mode.relevance = 1;
      }
      var beforeMatchExt = (mode, parent) => {
        if (!mode.beforeMatch)
          return;
        if (mode.starts)
          throw new Error("beforeMatch cannot be used with starts");
        const originalMode = Object.assign({}, mode);
        Object.keys(mode).forEach((key) => {
          delete mode[key];
        });
        mode.keywords = originalMode.keywords;
        mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));
        mode.starts = {
          relevance: 0,
          contains: [
            Object.assign(originalMode, { endsParent: true })
          ]
        };
        mode.relevance = 0;
        delete originalMode.beforeMatch;
      };
      var COMMON_KEYWORDS = [
        "of",
        "and",
        "for",
        "in",
        "not",
        "or",
        "if",
        "then",
        "parent",
        "list",
        "value"
      ];
      var DEFAULT_KEYWORD_SCOPE = "keyword";
      function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
        const compiledKeywords = /* @__PURE__ */ Object.create(null);
        if (typeof rawKeywords === "string") {
          compileList(scopeName, rawKeywords.split(" "));
        } else if (Array.isArray(rawKeywords)) {
          compileList(scopeName, rawKeywords);
        } else {
          Object.keys(rawKeywords).forEach(function(scopeName2) {
            Object.assign(
              compiledKeywords,
              compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2)
            );
          });
        }
        return compiledKeywords;
        function compileList(scopeName2, keywordList) {
          if (caseInsensitive) {
            keywordList = keywordList.map((x) => x.toLowerCase());
          }
          keywordList.forEach(function(keyword) {
            const pair = keyword.split("|");
            compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
          });
        }
      }
      function scoreForKeyword(keyword, providedScore) {
        if (providedScore) {
          return Number(providedScore);
        }
        return commonKeyword(keyword) ? 0 : 1;
      }
      function commonKeyword(keyword) {
        return COMMON_KEYWORDS.includes(keyword.toLowerCase());
      }
      var seenDeprecations = {};
      var error = (message) => {
        console.error(message);
      };
      var warn = (message, ...args) => {
        console.log(`WARN: ${message}`, ...args);
      };
      var deprecated = (version2, message) => {
        if (seenDeprecations[`${version2}/${message}`])
          return;
        console.log(`Deprecated as of ${version2}. ${message}`);
        seenDeprecations[`${version2}/${message}`] = true;
      };
      var MultiClassError = new Error();
      function remapScopeNames(mode, regexes, { key }) {
        let offset = 0;
        const scopeNames = mode[key];
        const emit = {};
        const positions = {};
        for (let i = 1; i <= regexes.length; i++) {
          positions[i + offset] = scopeNames[i];
          emit[i + offset] = true;
          offset += countMatchGroups(regexes[i - 1]);
        }
        mode[key] = positions;
        mode[key]._emit = emit;
        mode[key]._multi = true;
      }
      function beginMultiClass(mode) {
        if (!Array.isArray(mode.begin))
          return;
        if (mode.skip || mode.excludeBegin || mode.returnBegin) {
          error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
          throw MultiClassError;
        }
        if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
          error("beginScope must be object");
          throw MultiClassError;
        }
        remapScopeNames(mode, mode.begin, { key: "beginScope" });
        mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
      }
      function endMultiClass(mode) {
        if (!Array.isArray(mode.end))
          return;
        if (mode.skip || mode.excludeEnd || mode.returnEnd) {
          error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
          throw MultiClassError;
        }
        if (typeof mode.endScope !== "object" || mode.endScope === null) {
          error("endScope must be object");
          throw MultiClassError;
        }
        remapScopeNames(mode, mode.end, { key: "endScope" });
        mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
      }
      function scopeSugar(mode) {
        if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
          mode.beginScope = mode.scope;
          delete mode.scope;
        }
      }
      function MultiClass(mode) {
        scopeSugar(mode);
        if (typeof mode.beginScope === "string") {
          mode.beginScope = { _wrap: mode.beginScope };
        }
        if (typeof mode.endScope === "string") {
          mode.endScope = { _wrap: mode.endScope };
        }
        beginMultiClass(mode);
        endMultiClass(mode);
      }
      function compileLanguage(language) {
        function langRe(value, global2) {
          return new RegExp(
            source(value),
            "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global2 ? "g" : "")
          );
        }
        class MultiRegex {
          constructor() {
            this.matchIndexes = {};
            this.regexes = [];
            this.matchAt = 1;
            this.position = 0;
          }
          addRule(re, opts) {
            opts.position = this.position++;
            this.matchIndexes[this.matchAt] = opts;
            this.regexes.push([opts, re]);
            this.matchAt += countMatchGroups(re) + 1;
          }
          compile() {
            if (this.regexes.length === 0) {
              this.exec = () => null;
            }
            const terminators = this.regexes.map((el) => el[1]);
            this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
            this.lastIndex = 0;
          }
          exec(s) {
            this.matcherRe.lastIndex = this.lastIndex;
            const match = this.matcherRe.exec(s);
            if (!match) {
              return null;
            }
            const i = match.findIndex((el, i2) => i2 > 0 && el !== void 0);
            const matchData = this.matchIndexes[i];
            match.splice(0, i);
            return Object.assign(match, matchData);
          }
        }
        class ResumableMultiRegex {
          constructor() {
            this.rules = [];
            this.multiRegexes = [];
            this.count = 0;
            this.lastIndex = 0;
            this.regexIndex = 0;
          }
          getMatcher(index) {
            if (this.multiRegexes[index])
              return this.multiRegexes[index];
            const matcher = new MultiRegex();
            this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
            matcher.compile();
            this.multiRegexes[index] = matcher;
            return matcher;
          }
          resumingScanAtSamePosition() {
            return this.regexIndex !== 0;
          }
          considerAll() {
            this.regexIndex = 0;
          }
          addRule(re, opts) {
            this.rules.push([re, opts]);
            if (opts.type === "begin")
              this.count++;
          }
          exec(s) {
            const m = this.getMatcher(this.regexIndex);
            m.lastIndex = this.lastIndex;
            let result = m.exec(s);
            if (this.resumingScanAtSamePosition()) {
              if (result && result.index === this.lastIndex)
                ;
              else {
                const m2 = this.getMatcher(0);
                m2.lastIndex = this.lastIndex + 1;
                result = m2.exec(s);
              }
            }
            if (result) {
              this.regexIndex += result.position + 1;
              if (this.regexIndex === this.count) {
                this.considerAll();
              }
            }
            return result;
          }
        }
        function buildModeRegex(mode) {
          const mm = new ResumableMultiRegex();
          mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: "begin" }));
          if (mode.terminatorEnd) {
            mm.addRule(mode.terminatorEnd, { type: "end" });
          }
          if (mode.illegal) {
            mm.addRule(mode.illegal, { type: "illegal" });
          }
          return mm;
        }
        function compileMode(mode, parent) {
          const cmode = mode;
          if (mode.isCompiled)
            return cmode;
          [
            scopeClassName,
            compileMatch,
            MultiClass,
            beforeMatchExt
          ].forEach((ext) => ext(mode, parent));
          language.compilerExtensions.forEach((ext) => ext(mode, parent));
          mode.__beforeBegin = null;
          [
            beginKeywords,
            compileIllegal,
            compileRelevance
          ].forEach((ext) => ext(mode, parent));
          mode.isCompiled = true;
          let keywordPattern = null;
          if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
            mode.keywords = Object.assign({}, mode.keywords);
            keywordPattern = mode.keywords.$pattern;
            delete mode.keywords.$pattern;
          }
          keywordPattern = keywordPattern || /\w+/;
          if (mode.keywords) {
            mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
          }
          cmode.keywordPatternRe = langRe(keywordPattern, true);
          if (parent) {
            if (!mode.begin)
              mode.begin = /\B|\b/;
            cmode.beginRe = langRe(cmode.begin);
            if (!mode.end && !mode.endsWithParent)
              mode.end = /\B|\b/;
            if (mode.end)
              cmode.endRe = langRe(cmode.end);
            cmode.terminatorEnd = source(cmode.end) || "";
            if (mode.endsWithParent && parent.terminatorEnd) {
              cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
            }
          }
          if (mode.illegal)
            cmode.illegalRe = langRe(mode.illegal);
          if (!mode.contains)
            mode.contains = [];
          mode.contains = [].concat(...mode.contains.map(function(c) {
            return expandOrCloneMode(c === "self" ? mode : c);
          }));
          mode.contains.forEach(function(c) {
            compileMode(c, cmode);
          });
          if (mode.starts) {
            compileMode(mode.starts, parent);
          }
          cmode.matcher = buildModeRegex(cmode);
          return cmode;
        }
        if (!language.compilerExtensions)
          language.compilerExtensions = [];
        if (language.contains && language.contains.includes("self")) {
          throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
        }
        language.classNameAliases = inherit$1(language.classNameAliases || {});
        return compileMode(language);
      }
      function dependencyOnParent(mode) {
        if (!mode)
          return false;
        return mode.endsWithParent || dependencyOnParent(mode.starts);
      }
      function expandOrCloneMode(mode) {
        if (mode.variants && !mode.cachedVariants) {
          mode.cachedVariants = mode.variants.map(function(variant) {
            return inherit$1(mode, { variants: null }, variant);
          });
        }
        if (mode.cachedVariants) {
          return mode.cachedVariants;
        }
        if (dependencyOnParent(mode)) {
          return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
        }
        if (Object.isFrozen(mode)) {
          return inherit$1(mode);
        }
        return mode;
      }
      var version = "11.6.0";
      var HTMLInjectionError = class extends Error {
        constructor(reason, html) {
          super(reason);
          this.name = "HTMLInjectionError";
          this.html = html;
        }
      };
      var escape = escapeHTML;
      var inherit = inherit$1;
      var NO_MATCH = Symbol("nomatch");
      var MAX_KEYWORD_HITS = 7;
      var HLJS = function(hljs) {
        const languages = /* @__PURE__ */ Object.create(null);
        const aliases = /* @__PURE__ */ Object.create(null);
        const plugins = [];
        let SAFE_MODE = true;
        const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
        const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
        let options = {
          ignoreUnescapedHTML: false,
          throwUnescapedHTML: false,
          noHighlightRe: /^(no-?highlight)$/i,
          languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
          classPrefix: "hljs-",
          cssSelector: "pre code",
          languages: null,
          __emitter: TokenTreeEmitter
        };
        function shouldNotHighlight(languageName) {
          return options.noHighlightRe.test(languageName);
        }
        function blockLanguage(block) {
          let classes = block.className + " ";
          classes += block.parentNode ? block.parentNode.className : "";
          const match = options.languageDetectRe.exec(classes);
          if (match) {
            const language = getLanguage(match[1]);
            if (!language) {
              warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
              warn("Falling back to no-highlight mode for this block.", block);
            }
            return language ? match[1] : "no-highlight";
          }
          return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
        }
        function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
          let code = "";
          let languageName = "";
          if (typeof optionsOrCode === "object") {
            code = codeOrLanguageName;
            ignoreIllegals = optionsOrCode.ignoreIllegals;
            languageName = optionsOrCode.language;
          } else {
            deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
            deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
            languageName = codeOrLanguageName;
            code = optionsOrCode;
          }
          if (ignoreIllegals === void 0) {
            ignoreIllegals = true;
          }
          const context = {
            code,
            language: languageName
          };
          fire("before:highlight", context);
          const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
          result.code = context.code;
          fire("after:highlight", result);
          return result;
        }
        function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
          const keywordHits = /* @__PURE__ */ Object.create(null);
          function keywordData(mode, matchText) {
            return mode.keywords[matchText];
          }
          function processKeywords() {
            if (!top.keywords) {
              emitter.addText(modeBuffer);
              return;
            }
            let lastIndex = 0;
            top.keywordPatternRe.lastIndex = 0;
            let match = top.keywordPatternRe.exec(modeBuffer);
            let buf = "";
            while (match) {
              buf += modeBuffer.substring(lastIndex, match.index);
              const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
              const data = keywordData(top, word);
              if (data) {
                const [kind, keywordRelevance] = data;
                emitter.addText(buf);
                buf = "";
                keywordHits[word] = (keywordHits[word] || 0) + 1;
                if (keywordHits[word] <= MAX_KEYWORD_HITS)
                  relevance += keywordRelevance;
                if (kind.startsWith("_")) {
                  buf += match[0];
                } else {
                  const cssClass = language.classNameAliases[kind] || kind;
                  emitter.addKeyword(match[0], cssClass);
                }
              } else {
                buf += match[0];
              }
              lastIndex = top.keywordPatternRe.lastIndex;
              match = top.keywordPatternRe.exec(modeBuffer);
            }
            buf += modeBuffer.substring(lastIndex);
            emitter.addText(buf);
          }
          function processSubLanguage() {
            if (modeBuffer === "")
              return;
            let result2 = null;
            if (typeof top.subLanguage === "string") {
              if (!languages[top.subLanguage]) {
                emitter.addText(modeBuffer);
                return;
              }
              result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
              continuations[top.subLanguage] = result2._top;
            } else {
              result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
            }
            if (top.relevance > 0) {
              relevance += result2.relevance;
            }
            emitter.addSublanguage(result2._emitter, result2.language);
          }
          function processBuffer() {
            if (top.subLanguage != null) {
              processSubLanguage();
            } else {
              processKeywords();
            }
            modeBuffer = "";
          }
          function emitMultiClass(scope, match) {
            let i = 1;
            const max = match.length - 1;
            while (i <= max) {
              if (!scope._emit[i]) {
                i++;
                continue;
              }
              const klass = language.classNameAliases[scope[i]] || scope[i];
              const text = match[i];
              if (klass) {
                emitter.addKeyword(text, klass);
              } else {
                modeBuffer = text;
                processKeywords();
                modeBuffer = "";
              }
              i++;
            }
          }
          function startNewMode(mode, match) {
            if (mode.scope && typeof mode.scope === "string") {
              emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
            }
            if (mode.beginScope) {
              if (mode.beginScope._wrap) {
                emitter.addKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
                modeBuffer = "";
              } else if (mode.beginScope._multi) {
                emitMultiClass(mode.beginScope, match);
                modeBuffer = "";
              }
            }
            top = Object.create(mode, { parent: { value: top } });
            return top;
          }
          function endOfMode(mode, match, matchPlusRemainder) {
            let matched = startsWith(mode.endRe, matchPlusRemainder);
            if (matched) {
              if (mode["on:end"]) {
                const resp = new Response(mode);
                mode["on:end"](match, resp);
                if (resp.isMatchIgnored)
                  matched = false;
              }
              if (matched) {
                while (mode.endsParent && mode.parent) {
                  mode = mode.parent;
                }
                return mode;
              }
            }
            if (mode.endsWithParent) {
              return endOfMode(mode.parent, match, matchPlusRemainder);
            }
          }
          function doIgnore(lexeme) {
            if (top.matcher.regexIndex === 0) {
              modeBuffer += lexeme[0];
              return 1;
            } else {
              resumeScanAtSamePosition = true;
              return 0;
            }
          }
          function doBeginMatch(match) {
            const lexeme = match[0];
            const newMode = match.rule;
            const resp = new Response(newMode);
            const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
            for (const cb of beforeCallbacks) {
              if (!cb)
                continue;
              cb(match, resp);
              if (resp.isMatchIgnored)
                return doIgnore(lexeme);
            }
            if (newMode.skip) {
              modeBuffer += lexeme;
            } else {
              if (newMode.excludeBegin) {
                modeBuffer += lexeme;
              }
              processBuffer();
              if (!newMode.returnBegin && !newMode.excludeBegin) {
                modeBuffer = lexeme;
              }
            }
            startNewMode(newMode, match);
            return newMode.returnBegin ? 0 : lexeme.length;
          }
          function doEndMatch(match) {
            const lexeme = match[0];
            const matchPlusRemainder = codeToHighlight.substring(match.index);
            const endMode = endOfMode(top, match, matchPlusRemainder);
            if (!endMode) {
              return NO_MATCH;
            }
            const origin = top;
            if (top.endScope && top.endScope._wrap) {
              processBuffer();
              emitter.addKeyword(lexeme, top.endScope._wrap);
            } else if (top.endScope && top.endScope._multi) {
              processBuffer();
              emitMultiClass(top.endScope, match);
            } else if (origin.skip) {
              modeBuffer += lexeme;
            } else {
              if (!(origin.returnEnd || origin.excludeEnd)) {
                modeBuffer += lexeme;
              }
              processBuffer();
              if (origin.excludeEnd) {
                modeBuffer = lexeme;
              }
            }
            do {
              if (top.scope) {
                emitter.closeNode();
              }
              if (!top.skip && !top.subLanguage) {
                relevance += top.relevance;
              }
              top = top.parent;
            } while (top !== endMode.parent);
            if (endMode.starts) {
              startNewMode(endMode.starts, match);
            }
            return origin.returnEnd ? 0 : lexeme.length;
          }
          function processContinuations() {
            const list = [];
            for (let current = top; current !== language; current = current.parent) {
              if (current.scope) {
                list.unshift(current.scope);
              }
            }
            list.forEach((item) => emitter.openNode(item));
          }
          let lastMatch = {};
          function processLexeme(textBeforeMatch, match) {
            const lexeme = match && match[0];
            modeBuffer += textBeforeMatch;
            if (lexeme == null) {
              processBuffer();
              return 0;
            }
            if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
              modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
              if (!SAFE_MODE) {
                const err = new Error(`0 width match regex (${languageName})`);
                err.languageName = languageName;
                err.badRule = lastMatch.rule;
                throw err;
              }
              return 1;
            }
            lastMatch = match;
            if (match.type === "begin") {
              return doBeginMatch(match);
            } else if (match.type === "illegal" && !ignoreIllegals) {
              const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || "<unnamed>") + '"');
              err.mode = top;
              throw err;
            } else if (match.type === "end") {
              const processed = doEndMatch(match);
              if (processed !== NO_MATCH) {
                return processed;
              }
            }
            if (match.type === "illegal" && lexeme === "") {
              return 1;
            }
            if (iterations > 1e5 && iterations > match.index * 3) {
              const err = new Error("potential infinite loop, way more iterations than matches");
              throw err;
            }
            modeBuffer += lexeme;
            return lexeme.length;
          }
          const language = getLanguage(languageName);
          if (!language) {
            error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
            throw new Error('Unknown language: "' + languageName + '"');
          }
          const md = compileLanguage(language);
          let result = "";
          let top = continuation || md;
          const continuations = {};
          const emitter = new options.__emitter(options);
          processContinuations();
          let modeBuffer = "";
          let relevance = 0;
          let index = 0;
          let iterations = 0;
          let resumeScanAtSamePosition = false;
          try {
            top.matcher.considerAll();
            for (; ; ) {
              iterations++;
              if (resumeScanAtSamePosition) {
                resumeScanAtSamePosition = false;
              } else {
                top.matcher.considerAll();
              }
              top.matcher.lastIndex = index;
              const match = top.matcher.exec(codeToHighlight);
              if (!match)
                break;
              const beforeMatch = codeToHighlight.substring(index, match.index);
              const processedCount = processLexeme(beforeMatch, match);
              index = match.index + processedCount;
            }
            processLexeme(codeToHighlight.substring(index));
            emitter.closeAllNodes();
            emitter.finalize();
            result = emitter.toHTML();
            return {
              language: languageName,
              value: result,
              relevance,
              illegal: false,
              _emitter: emitter,
              _top: top
            };
          } catch (err) {
            if (err.message && err.message.includes("Illegal")) {
              return {
                language: languageName,
                value: escape(codeToHighlight),
                illegal: true,
                relevance: 0,
                _illegalBy: {
                  message: err.message,
                  index,
                  context: codeToHighlight.slice(index - 100, index + 100),
                  mode: err.mode,
                  resultSoFar: result
                },
                _emitter: emitter
              };
            } else if (SAFE_MODE) {
              return {
                language: languageName,
                value: escape(codeToHighlight),
                illegal: false,
                relevance: 0,
                errorRaised: err,
                _emitter: emitter,
                _top: top
              };
            } else {
              throw err;
            }
          }
        }
        function justTextHighlightResult(code) {
          const result = {
            value: escape(code),
            illegal: false,
            relevance: 0,
            _top: PLAINTEXT_LANGUAGE,
            _emitter: new options.__emitter(options)
          };
          result._emitter.addText(code);
          return result;
        }
        function highlightAuto(code, languageSubset) {
          languageSubset = languageSubset || options.languages || Object.keys(languages);
          const plaintext = justTextHighlightResult(code);
          const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
            (name) => _highlight(name, code, false)
          );
          results.unshift(plaintext);
          const sorted = results.sort((a, b) => {
            if (a.relevance !== b.relevance)
              return b.relevance - a.relevance;
            if (a.language && b.language) {
              if (getLanguage(a.language).supersetOf === b.language) {
                return 1;
              } else if (getLanguage(b.language).supersetOf === a.language) {
                return -1;
              }
            }
            return 0;
          });
          const [best, secondBest] = sorted;
          const result = best;
          result.secondBest = secondBest;
          return result;
        }
        function updateClassName(element, currentLang, resultLang) {
          const language = currentLang && aliases[currentLang] || resultLang;
          element.classList.add("hljs");
          element.classList.add(`language-${language}`);
        }
        function highlightElement(element) {
          let node = null;
          const language = blockLanguage(element);
          if (shouldNotHighlight(language))
            return;
          fire(
            "before:highlightElement",
            { el: element, language }
          );
          if (element.children.length > 0) {
            if (!options.ignoreUnescapedHTML) {
              console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
              console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
              console.warn("The element with unescaped HTML:");
              console.warn(element);
            }
            if (options.throwUnescapedHTML) {
              const err = new HTMLInjectionError(
                "One of your code blocks includes unescaped HTML.",
                element.innerHTML
              );
              throw err;
            }
          }
          node = element;
          const text = node.textContent;
          const result = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto(text);
          element.innerHTML = result.value;
          updateClassName(element, language, result.language);
          element.result = {
            language: result.language,
            re: result.relevance,
            relevance: result.relevance
          };
          if (result.secondBest) {
            element.secondBest = {
              language: result.secondBest.language,
              relevance: result.secondBest.relevance
            };
          }
          fire("after:highlightElement", { el: element, result, text });
        }
        function configure(userOptions) {
          options = inherit(options, userOptions);
        }
        const initHighlighting = () => {
          highlightAll();
          deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
        };
        function initHighlightingOnLoad() {
          highlightAll();
          deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
        }
        let wantsHighlight = false;
        function highlightAll() {
          if (document.readyState === "loading") {
            wantsHighlight = true;
            return;
          }
          const blocks = document.querySelectorAll(options.cssSelector);
          blocks.forEach(highlightElement);
        }
        function boot() {
          if (wantsHighlight)
            highlightAll();
        }
        if (typeof window !== "undefined" && window.addEventListener) {
          window.addEventListener("DOMContentLoaded", boot, false);
        }
        function registerLanguage(languageName, languageDefinition) {
          let lang = null;
          try {
            lang = languageDefinition(hljs);
          } catch (error$1) {
            error("Language definition for '{}' could not be registered.".replace("{}", languageName));
            if (!SAFE_MODE) {
              throw error$1;
            } else {
              error(error$1);
            }
            lang = PLAINTEXT_LANGUAGE;
          }
          if (!lang.name)
            lang.name = languageName;
          languages[languageName] = lang;
          lang.rawDefinition = languageDefinition.bind(null, hljs);
          if (lang.aliases) {
            registerAliases(lang.aliases, { languageName });
          }
        }
        function unregisterLanguage(languageName) {
          delete languages[languageName];
          for (const alias of Object.keys(aliases)) {
            if (aliases[alias] === languageName) {
              delete aliases[alias];
            }
          }
        }
        function listLanguages() {
          return Object.keys(languages);
        }
        function getLanguage(name) {
          name = (name || "").toLowerCase();
          return languages[name] || languages[aliases[name]];
        }
        function registerAliases(aliasList, { languageName }) {
          if (typeof aliasList === "string") {
            aliasList = [aliasList];
          }
          aliasList.forEach((alias) => {
            aliases[alias.toLowerCase()] = languageName;
          });
        }
        function autoDetection(name) {
          const lang = getLanguage(name);
          return lang && !lang.disableAutodetect;
        }
        function upgradePluginAPI(plugin) {
          if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
            plugin["before:highlightElement"] = (data) => {
              plugin["before:highlightBlock"](
                Object.assign({ block: data.el }, data)
              );
            };
          }
          if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
            plugin["after:highlightElement"] = (data) => {
              plugin["after:highlightBlock"](
                Object.assign({ block: data.el }, data)
              );
            };
          }
        }
        function addPlugin(plugin) {
          upgradePluginAPI(plugin);
          plugins.push(plugin);
        }
        function fire(event, args) {
          const cb = event;
          plugins.forEach(function(plugin) {
            if (plugin[cb]) {
              plugin[cb](args);
            }
          });
        }
        function deprecateHighlightBlock(el) {
          deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
          deprecated("10.7.0", "Please use highlightElement now.");
          return highlightElement(el);
        }
        Object.assign(hljs, {
          highlight: highlight2,
          highlightAuto,
          highlightAll,
          highlightElement,
          highlightBlock: deprecateHighlightBlock,
          configure,
          initHighlighting,
          initHighlightingOnLoad,
          registerLanguage,
          unregisterLanguage,
          listLanguages,
          getLanguage,
          registerAliases,
          autoDetection,
          inherit,
          addPlugin
        });
        hljs.debugMode = function() {
          SAFE_MODE = false;
        };
        hljs.safeMode = function() {
          SAFE_MODE = true;
        };
        hljs.versionString = version;
        hljs.regex = {
          concat,
          lookahead,
          either,
          optional,
          anyNumberOfTimes
        };
        for (const key in MODES) {
          if (typeof MODES[key] === "object") {
            deepFreezeEs6.exports(MODES[key]);
          }
        }
        Object.assign(hljs, MODES);
        return hljs;
      };
      var highlight = HLJS({});
      module.exports = highlight;
      highlight.HighlightJS = highlight;
      highlight.default = highlight;
    }
  });

  // node_modules/highlight.js/styles/atom-one-light.css
  var require_ = __commonJS({
    "node_modules/highlight.js/styles/atom-one-light.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/highlight.js/styles/atom-one-dark.css
  var require_2 = __commonJS({
    "node_modules/highlight.js/styles/atom-one-dark.css"(exports, module) {
      module.exports = {};
    }
  });

  // src/lib/index.ts
  var import_ton = __toESM(require_dist2());
  var import_bn = __toESM(require_bn4());
  var import_ton_access = __toESM(require_lib3());
  var import_sha256_js = __toESM(require_build2());

  // node_modules/highlight.js/es/core.js
  var import_core = __toESM(require_core(), 1);
  var core_default = import_core.default;

  // node_modules/highlightjs-func/src/languages/func.js
  var IDENTIFIER = '(?!")(`([^`]+)`|((?=_)_|(?=\\{)\\{|(?=\\})\\}|(?![_`{}]))([^;,\\[\\]\\(\\)\\s~.]+))';
  var STRING = /\"[^\n\"]+\"[Hhcusa]?/;
  var NUMBER;
  try {
    NUMBER = new RegExp("(-?(?!_)([\\d_]+|0x[\\d_a-fA-F]+)|0b[1_0]+)(?<!_)(?=[\\s\\)\\],;])");
  } catch (e) {
    NUMBER = /\d/;
  }
  function func_default(hljs) {
    return {
      "name": "FunC",
      "aliases": ["func"],
      "case_insensitive": false,
      "keywords": {
        "keyword": [
          "if",
          "ifnot",
          "else",
          "elseif",
          "elseifnot|10",
          "while",
          "do",
          "until",
          "repeat",
          "return",
          "impure",
          "method_id",
          "forall",
          "asm",
          "inline",
          "inline_ref|10",
          "const",
          "global"
        ],
        "literal": ["true", "false"],
        "type": ["var", "int", "slice", "tuple", "cell", "builder", "cont", "_"],
        "built_in": []
      },
      "contains": [
        { "scope": "comment", "begin": ";;", "end": /(?=\n)/ },
        {
          "scope": "comment",
          "begin": "{-",
          "end": "-}",
          "contains": ["self"]
        },
        {
          "scope": "meta",
          "begin": /#pragma/,
          "end": /;/,
          "contains": [
            { "scope": "keyword", "match": /version|not-version/ },
            {
              "scope": "operator",
              "match": hljs.regex.either(/>=/, /<=/, /=/, />/, /</, /\^/)
            },
            {
              "scope": "number",
              "match": /([0-9]+)(.[0-9]+)?(.[0-9]+)?/
            }
          ]
        },
        {
          "scope": "keyword",
          "begin": /#include/,
          "end": /;/,
          "contains": [
            { "scope": "string", "match": STRING }
          ]
        },
        { "scope": "number", "match": NUMBER },
        { "scope": "string", "match": STRING },
        {
          "match": [
            /\b(const|global)\b/,
            /\s+/,
            /\w+/,
            /\s+/,
            IDENTIFIER
          ],
          "scope": {
            1: "keyword",
            5: "variable.constant"
          }
        },
        { "scope": "function", "match": new RegExp(IDENTIFIER + "(?=[(])") },
        {
          "scope": "operator",
          "match": hljs.regex.either(
            /<=>/,
            />=/,
            /<=/,
            /!=/,
            /==/,
            /\^>>/,
            /~>>/,
            />>/,
            /<</,
            /\/%/,
            /\^%/,
            /~%/,
            /\^\//,
            /~\//,
            /\+=/,
            /-=/,
            /\*=/,
            /\/=/,
            /~\/=/,
            /\^\/=/,
            /%=/,
            /\^%=/,
            /<<=/,
            />>=/,
            /~>>=/,
            /\^>>=/,
            /&=/,
            /\^=/,
            /\|=/,
            /\^/,
            /=/,
            /~/,
            /\//,
            /%/,
            /-/,
            /\*/,
            /\+/,
            />/,
            /</,
            /&/,
            /\|/,
            /:/,
            /\?/
          )
        },
        { "scope": "punctuation", "match": /[\.;\(\),\[\]~\{\}]/ }
      ]
    };
  }

  // node_modules/highlightjs-func/src/languages/fift.js
  var IDENTIFIER2 = /[0-9A-Za-z$_-]+/;
  var WORD_DEFS = /(::_|::|:_|=:|:)/;
  function fift_default(hljs) {
    return {
      "name": "Fift",
      "aliases": ["fift"],
      "case_insensitive": false,
      "keywords": {
        "keyword": [
          "-roll",
          "-rot|10",
          "-trailing",
          "-trailing0",
          "2constant|10",
          "2drop|10",
          "2dup|10",
          "2over|10",
          "2swap|10",
          "abort",
          "abs",
          "allot",
          "and",
          "anon",
          "atom",
          "bbitrefs",
          "bbits",
          "bl",
          "box",
          "brefs",
          "brembitrefs",
          "brembits",
          "bremrefs",
          "bye",
          "cadr",
          "caddr",
          "car",
          "cddr",
          "cdr",
          "char",
          "chr",
          "cmp",
          "cond",
          "cons",
          "constant",
          "count",
          "cr",
          "create",
          "drop",
          "depth",
          "dictmap",
          "dictmerge",
          "dictnew",
          "does",
          "drop",
          "dup",
          "ed25519_chksign",
          "ed25519_sign",
          "ed25519_sign_uint",
          "emit",
          "exch",
          "exch2|10",
          "execute",
          "explode",
          "find",
          "first",
          "fits",
          "forget",
          "gasrunvm",
          "gasrunvmcode",
          "gasrunvmctx",
          "gasrunvmdict",
          "halt",
          "hash",
          "hashB",
          "hashu",
          "hold",
          "hole",
          "if",
          "ifnot",
          "include",
          "list",
          "minmax",
          "max",
          "min",
          "mod",
          "negate",
          "newkeypair",
          "nil",
          "nip",
          "nop",
          "not",
          "now",
          "null",
          "or",
          "over",
          "pair",
          "pick",
          "quit",
          "remaining",
          "reverse",
          "roll",
          "rot",
          "runvm",
          "runvmcode",
          "runvmctx",
          "runvmdict",
          "sbitrefs",
          "sbits",
          "second",
          "sgn",
          "sign",
          "shash",
          "space",
          "swap",
          "single",
          "skipspc",
          "srefs",
          "ten",
          "third",
          "times",
          "triple",
          "tuck",
          "tuple",
          "type",
          "ufits",
          "uncons",
          "unpair",
          "unsingle",
          "until",
          "untriple",
          "untuple",
          "variable",
          "while",
          "word",
          "words",
          "xor"
        ],
        "literal": ["true", "false"],
        "type": [],
        "built_in": []
      },
      "contains": [
        {
          "scope": "comment",
          "variants": [
            hljs.C_BLOCK_COMMENT_MODE,
            hljs.C_LINE_COMMENT_MODE
          ],
          "relevance": 0
        },
        {
          "match": [
            /\s/,
            /2?constant/,
            /\s+/,
            IDENTIFIER2
          ],
          "scope": {
            2: "keyword",
            4: "variable.constant"
          }
        },
        {
          "match": [
            /\s/,
            /variable/,
            /\s+/,
            IDENTIFIER2
          ],
          "scope": {
            2: "keyword",
            4: "variable"
          }
        },
        {
          "match": [
            /}/,
            /\s+/,
            WORD_DEFS,
            /\s+/,
            IDENTIFIER2
          ],
          "scope": {
            1: "punctuation",
            3: "operator",
            5: "function"
          }
        },
        {
          "scope": "operator",
          "match": hljs.regex.either(
            /!/,
            /#>/,
            /#s/,
            /\$#/,
            /#/,
            /\$\+/,
            /\$,/,
            /\$\d/,
            /\$=/,
            /\$(?=\()/,
            /\$>smca/,
            /\$>s/,
            /\$@\+/,
            /\$@\?\+/,
            /\$@\?/,
            /\$@/,
            /\$cmp/,
            /\$len/,
            /\$pos/,
            /\$reverse/,
            /%1<</,
            /\('\)/,
            /\(-trailing\)/,
            /\(\.\)/,
            /\(atom\)/,
            /\(b\.\)/,
            /\(compile\)/,
            /\(create\)/,
            /\(def\?\)/,
            /\(dump\)/,
            /\(execute\)/,
            /\(forget\)/,
            /\(number\)/,
            /\(x\.\)/,
            /\(\{\)/,
            /\(\}\)/,
            /\*\/cmod/,
            /\*\/c/,
            /\*\/mod/,
            /\*\/rmod/,
            /\*\/r/,
            /\*\//,
            /\*>>c/,
            /\*>>r/,
            /\*>>/,
            /\*mod/,
            /\*/,
            /\+!/,
            /\+/,
            /,/,
            /-!/,
            /-/,
            /-1<</,
            /\._/,
            /\.dump/,
            /\.l/,
            /\.sl/,
            /\.s/,
            /\.tc/,
            /\//,
            /\/\*/,
            /\/cmod/,
            /\/c/,
            /\/mod/,
            /\/rmod/,
            /\/r/,
            /0!/,
            /0<=/,
            /0<>/,
            /0</,
            /0=/,
            /0>=/,
            /0>/,
            /1\+!/,
            /1\+/,
            /1-!/,
            /1-/,
            /1<</,
            /1<<1-/,
            /2\*/,
            /2\+/,
            /2-/,
            /2\//,
            /2=:/,
            WORD_DEFS,
            /<#/,
            /<<\/c/,
            /<<\/r/,
            /<=/,
            /<>/,
            /<b/,
            /<s/,
            /<<\//,
            /<</,
            /</,
            /=/,
            />=/,
            />>c/,
            />>r/,
            />>/,
            />/,
            /\?dup/,
            /@'/,
            /@/,
            /B\+/,
            /B,/,
            /B=/,
            /B>Li@\+/,
            /B>Li@/,
            /B>Lu@\+/,
            /B>Lu@/,
            /B>boc/,
            /B>file/,
            /B>i@\+/,
            /B>i@/,
            /B>u@\+/,
            /B>u@/,
            /B@\?\+/,
            /B@\+/,
            /B@\?/,
            /B@/,
            /Bcmp/,
            /BhashB/,
            /Bhashu/,
            /Bhash/,
            /Blen/,
            /Bx\./,
            /B\|/,
            /Li>B/,
            /Lu>B/,
            /\[\]/,
            /\[compile\]/,
            /\[/,
            /\]/,
            /atom\?/,
            /b\+/,
            /b\._/,
            /b\./,
            /b>idict!\+/,
            /b>idict!/,
            /b>sdict!\+/,
            /b>sdict!/,
            /b>udict!\+/,
            /b>udict!/,
            /b>/,
            /boc+>B/,
            /boc>B/,
            /csr\./,
            /def\?/,
            /empty\?/,
            /eq\?/,
            /file-exists\?/,
            /file>B/,
            /i,/,
            /i>B/,
            /i@\+/,
            /i@/,
            /i@\?\+/,
            /i@\?/,
            /idict!\+/,
            /idict!/,
            /idict-/,
            /idict@-/,
            /idict@/,
            /null!/,
            /null\?/,
            /pfxdict!\+/,
            /pfxdict!/,
            /pfxdict@/,
            /priv>pub/,
            /ref@\+/,
            /ref@/,
            /ref@\?\+/,
            /ref@\?/,
            /s,/,
            /s>c/,
            /s>/,
            /sdict!\+/,
            /sdict!/,
            /sdict-/,
            /sdict@-/,
            /sdict@/,
            /smca>\$/,
            /sr,/,
            /tuple\?/,
            /u,/,
            /u>B/,
            /u@\+/,
            /u@\?\+/,
            /u@\?/,
            /udict!\+/,
            /udict!/,
            /udict-/,
            /udict@-/,
            /udict@/,
            /undef\?/,
            /x\._/,
            /x\./,
            /\|\+/,
            /\|/,
            /\|_/,
            new RegExp("(?<=\\s)\\.(?=\\s)")
          )
        },
        {
          "scope": "number",
          "match": hljs.regex.either(
            /(0[xX][0-9a-fA-F]+)/,
            /(0[bB][01]+)/,
            /(-?[0-9]+(\/-?[0-9]+)?)/
          )
        },
        { "scope": "string", "match": /"([^"\r\n\\]|\\.)*"/ },
        {
          "scope": "symbol",
          "match": /[xX]\{[0-9a-fA-F_]*}/,
          "relevance": 10
        },
        {
          "scope": "symbol",
          "match": /[bB]\{[01]*}/,
          "relevance": 10
        },
        {
          "scope": "symbol",
          "match": /'[^\s]+/
        },
        { "scope": "punctuation", "match": /[\[\{\}\],]/ }
      ]
    };
  }

  // node_modules/highlightjs-func/src/languages/tlb.js
  var IDENTIFIER3 = /[a-zA-Z_][0-9a-zA-Z_]*/;
  function tlb_default(hljs) {
    return {
      "name": "TL-B",
      "aliases": ["Tlb", "tlb", "TLB", "tl-b", "TL-b", "Tl-B", "Tl-b"],
      "case_insensitive": false,
      "keywords": {
        "keyword": [],
        "literal": ["True", "BoolTrue", "False", "BoolFalse", "Null"],
        "type": [
          "Type",
          "Bool",
          "Unit",
          "Maybe",
          "Either",
          "Both",
          "Cell",
          "uint8",
          "uint15",
          "uint16",
          "uint32",
          "uint63",
          "uint64",
          "int8",
          "int16",
          "int32",
          "int64",
          "bits256",
          "bits512"
        ],
        "built_in": []
      },
      "contains": [
        {
          "scope": "comment",
          "variants": [
            hljs.C_BLOCK_COMMENT_MODE,
            hljs.C_LINE_COMMENT_MODE
          ]
        },
        {
          "scope": "symbol",
          "match": hljs.regex.either(
            /#[0-9a-f]*_?/,
            /\$[01]*_?/,
            /##/,
            /#<=/,
            /#</
          )
        },
        {
          "match": [
            /=/,
            /\s+/,
            IDENTIFIER3,
            /[\s;]/
          ],
          "scope": {
            1: "operator",
            3: "type"
          }
        },
        { "scope": "variable", "match": IDENTIFIER3 },
        {
          "scope": "operator",
          "match": hljs.regex.either(
            /\+/,
            /-/,
            /\*/,
            /\//,
            /!=/,
            /==/,
            /=/,
            /\?/,
            /~/,
            /\./,
            /\^/,
            /<=/,
            />=/,
            /</,
            />/
          )
        },
        { "scope": "number", "match": /[0-9]+/ },
        { "scope": "punctuation", "match": /[;\(\):\[\]\{\}]/ }
      ]
    };
  }

  // node_modules/highlightjs-func/src/index.js
  function src_default(hljs) {
    hljs.registerLanguage("fift", fift_default);
    hljs.registerLanguage("func", func_default);
    hljs.registerLanguage("tlb", tlb_default);
  }

  // src/lib/style.css
  var _default = {};

  // src/lib/dom.ts
  var div = (props, ...children) => createElement("div", props, ...children);
  var img = (props, ...children) => createElement("img", props, ...children);
  function appendChildren(parent, children) {
    for (let child of children) {
      if (!child)
        continue;
      switch (typeof child) {
        case "string":
          const el = document.createTextNode(child);
          parent.appendChild(el);
          break;
        default:
          parent.appendChild(child);
          break;
      }
    }
  }
  function setStyle(el, style) {
    if (typeof style == "string") {
      el.setAttribute("style", style);
    } else {
      Object.assign(el.style, style);
    }
  }
  function setClass(el, className) {
    className.split(/\s/).forEach((element) => {
      if (element) {
        el.classList.add(element);
      }
    });
  }
  function setProps(el, props) {
    const eventRegex = /^on([a-z]+)$/i;
    for (let propName in props) {
      if (!propName)
        continue;
      if (propName === "style") {
        setStyle(el, props[propName]);
      } else if (propName === "className") {
        setClass(el, props[propName]);
      } else if (eventRegex.test(propName)) {
        const eventToListen = propName.replace(eventRegex, "$1").toLowerCase();
        el.addEventListener(eventToListen, props[propName]);
      } else {
        el.setAttribute(propName, props[propName]);
      }
    }
  }
  function createElement(type, props, ...children) {
    if (typeof type === "function") {
      return type(props);
    } else {
      const el = document.createElement(type);
      if (props && typeof props === "object") {
        setProps(el, props);
      }
      if (children) {
        appendChildren(el, children);
      }
      return el;
    }
  }

  // src/lib/res/file-white.svg
  var file_white_default = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\n<g clip-path="url(#clip0_3604_24717)">\n<path d="M11 1H3C2.86739 1 2.74021 1.05268 2.64645 1.14645C2.55268 1.24021 2.5 1.36739 2.5 1.5V12.5C2.50079 13.1628 2.76444 13.7982 3.23311 14.2669C3.70178 14.7356 4.3372 14.9992 5 15H13C13.1326 15 13.2598 14.9473 13.3536 14.8536C13.4473 14.7598 13.5 14.6326 13.5 14.5V3.5C13.4992 2.8372 13.2356 2.20178 12.7669 1.73311C12.2982 1.26444 11.6628 1.00079 11 1ZM12.5 14H5C4.60218 14 4.22064 13.842 3.93934 13.5607C3.65804 13.2794 3.5 12.8978 3.5 12.5V2H11C11.3978 2 11.7794 2.15804 12.0607 2.43934C12.342 2.72064 12.5 3.10218 12.5 3.5V14Z" fill="white"/>\n<path d="M9.5 1.5V5H13M-1 1V1.5" stroke="white" stroke-linecap="round" stroke-linejoin="round"/>\n</g>\n<defs>\n<clipPath id="clip0_3604_24717">\n<rect width="16" height="16" fill="white"/>\n</clipPath>\n</defs>\n</svg>\n';

  // src/lib/res/file-black.svg
  var file_black_default = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\n<g clip-path="url(#clip0_3604_24717)">\n<path d="M11 1H3C2.86739 1 2.74021 1.05268 2.64645 1.14645C2.55268 1.24021 2.5 1.36739 2.5 1.5V12.5C2.50079 13.1628 2.76444 13.7982 3.23311 14.2669C3.70178 14.7356 4.3372 14.9992 5 15H13C13.1326 15 13.2598 14.9473 13.3536 14.8536C13.4473 14.7598 13.5 14.6326 13.5 14.5V3.5C13.4992 2.8372 13.2356 2.20178 12.7669 1.73311C12.2982 1.26444 11.6628 1.00079 11 1ZM12.5 14H5C4.60218 14 4.22064 13.842 3.93934 13.5607C3.65804 13.2794 3.5 12.8978 3.5 12.5V2H11C11.3978 2 11.7794 2.15804 12.0607 2.43934C12.342 2.72064 12.5 3.10218 12.5 3.5V14Z" fill="black"/>\n<path d="M9.5 1.5V5H13M-1 1V1.5" stroke="black" stroke-linecap="round" stroke-linejoin="round"/>\n</g>\n<defs>\n<clipPath id="clip0_3604_24717">\n<rect width="16" height="16" fill="white"/>\n</clipPath>\n</defs>\n</svg>\n';

  // src/lib/res/folder-closed-white.svg
  var folder_closed_white_default = '<svg width="16" height="13" viewBox="0 0 15 13" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path d="M13.1518 2.46462H8.40426C8.21155 2.46462 8.02331 2.38549 7.89332 2.25099L6.41199 0.690527C6.05592 0.335596 5.56874 0.150206 5.07532 0.153047H1.84816C0.829129 0.153018 0 0.982147 0 2.00115V10.9989C0 12.0179 0.829129 12.847 1.84816 12.847H13.1586H13.1603C14.1788 12.8425 15.0045 12.0094 15 10.9932V4.31276C15 3.29372 14.1708 2.46462 13.1518 2.46462ZM13.8696 10.9955C13.8713 11.3911 13.5509 11.715 13.1575 11.7167H1.84816C1.45254 11.7167 1.13039 11.3945 1.13039 10.9989V2.00115C1.13039 1.60553 1.45254 1.28338 1.84816 1.28279H5.09003C5.09624 1.28279 5.10245 1.28279 5.10869 1.28279C5.29745 1.28279 5.48059 1.35797 5.60378 1.48005L7.0772 3.03316C7.42308 3.39035 7.90689 3.59495 8.40426 3.59495H13.1518C13.5474 3.59495 13.8696 3.9171 13.8696 4.31273V10.9955H13.8696Z" fill="white"/>\n</svg>\n';

  // src/lib/res/folder-closed-black.svg
  var folder_closed_black_default = '<svg width="16" height="13" viewBox="0 0 15 13" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path d="M13.1518 2.46462H8.40426C8.21155 2.46462 8.02331 2.38549 7.89332 2.25099L6.41199 0.690527C6.05592 0.335596 5.56874 0.150206 5.07532 0.153047H1.84816C0.829129 0.153018 0 0.982147 0 2.00115V10.9989C0 12.0179 0.829129 12.847 1.84816 12.847H13.1586H13.1603C14.1788 12.8425 15.0045 12.0094 15 10.9932V4.31276C15 3.29372 14.1708 2.46462 13.1518 2.46462ZM13.8696 10.9955C13.8713 11.3911 13.5509 11.715 13.1575 11.7167H1.84816C1.45254 11.7167 1.13039 11.3945 1.13039 10.9989V2.00115C1.13039 1.60553 1.45254 1.28338 1.84816 1.28279H5.09003C5.09624 1.28279 5.10245 1.28279 5.10869 1.28279C5.29745 1.28279 5.48059 1.35797 5.60378 1.48005L7.0772 3.03316C7.42308 3.39035 7.90689 3.59495 8.40426 3.59495H13.1518C13.5474 3.59495 13.8696 3.9171 13.8696 4.31273V10.9955H13.8696Z" fill="black"/>\n</svg>\n';

  // src/lib/res/folder-open-white.svg
  var folder_open_white_default = '<svg width="16" height="14" viewBox="0 0 16 14" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path d="M15.5488 6.00997C15.3895 5.79006 15.1795 5.61182 14.9367 5.49039C14.6938 5.36896 14.4252 5.30793 14.1538 5.31247H13.9738V4.18747C13.9738 3.963 13.9291 3.74077 13.8421 3.5338C13.7552 3.32683 13.6279 3.13928 13.4676 2.98214C13.3073 2.82499 13.1173 2.7014 12.9086 2.61861C12.7 2.53581 12.4769 2.49548 12.2525 2.49997H8.6075C8.47112 2.49917 8.33875 2.45373 8.23063 2.3706L5.98063 0.615596C5.67268 0.378476 5.29492 0.249919 4.90625 0.249971H1.84625C1.62182 0.245482 1.39875 0.285814 1.1901 0.368607C0.981456 0.451399 0.791423 0.574988 0.631131 0.732136C0.47084 0.889284 0.343513 1.07683 0.256606 1.2838C0.169698 1.49077 0.124957 1.713 0.125002 1.93747V12.0625C0.124513 12.3738 0.214398 12.6787 0.383752 12.94C0.539399 13.1874 0.755121 13.3914 1.01083 13.5331C1.26655 13.6747 1.55394 13.7493 1.84625 13.75H12.5338C12.901 13.7591 13.2613 13.6482 13.5597 13.434C13.8582 13.2198 14.0786 12.914 14.1875 12.5631L15.7963 7.5006C15.8737 7.24999 15.8916 6.98479 15.8487 6.72603C15.8057 6.46728 15.703 6.22211 15.5488 6.00997ZM1.25 1.93747C1.24986 1.86067 1.26545 1.78466 1.29581 1.71412C1.32616 1.64358 1.37064 1.58 1.4265 1.5273C1.48236 1.4746 1.54842 1.4339 1.62061 1.4077C1.6928 1.3815 1.76959 1.37036 1.84625 1.37497H4.90625C5.04449 1.37496 5.1789 1.42042 5.28875 1.50435L7.53875 3.25935C7.84457 3.49643 8.22055 3.62505 8.6075 3.62497H12.2525C12.3292 3.62036 12.406 3.6315 12.4781 3.6577C12.5503 3.6839 12.6164 3.7246 12.6723 3.7773C12.7281 3.83 12.7726 3.89358 12.8029 3.96412C12.8333 4.03466 12.8489 4.11068 12.8488 4.18747V5.31247H3.84875C3.48433 5.30701 3.12794 5.41968 2.83288 5.63362C2.53782 5.84756 2.31996 6.15128 2.21188 6.49935L1.25 9.55372V1.93747ZM14.75 7.1631L13.1413 12.2256C13.1051 12.3452 13.0303 12.4493 12.9284 12.5216C12.8266 12.594 12.7035 12.6303 12.5788 12.625H1.89125C1.76439 12.6247 1.64068 12.5854 1.53688 12.5125L3.33688 6.83685C3.37299 6.71727 3.44787 6.61312 3.54972 6.54081C3.65156 6.46849 3.77458 6.43214 3.89938 6.43747H14.1538C14.2485 6.43681 14.3422 6.45835 14.4271 6.50035C14.5121 6.54235 14.5861 6.60365 14.6431 6.67935C14.6967 6.74647 14.7342 6.82497 14.7527 6.90882C14.7712 6.99267 14.7703 7.07965 14.75 7.1631Z" fill="white"/>\n</svg>\n';

  // src/lib/res/folder-open-black.svg
  var folder_open_black_default = '<svg width="16" height="14" viewBox="0 0 16 14" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path d="M15.5488 6.00997C15.3895 5.79006 15.1795 5.61182 14.9367 5.49039C14.6938 5.36896 14.4252 5.30793 14.1538 5.31247H13.9738V4.18747C13.9738 3.963 13.9291 3.74077 13.8421 3.5338C13.7552 3.32683 13.6279 3.13928 13.4676 2.98214C13.3073 2.82499 13.1173 2.7014 12.9086 2.61861C12.7 2.53581 12.4769 2.49548 12.2525 2.49997H8.6075C8.47112 2.49917 8.33875 2.45373 8.23063 2.3706L5.98063 0.615596C5.67268 0.378476 5.29492 0.249919 4.90625 0.249971H1.84625C1.62182 0.245482 1.39875 0.285814 1.1901 0.368607C0.981456 0.451399 0.791423 0.574988 0.631131 0.732136C0.47084 0.889284 0.343513 1.07683 0.256606 1.2838C0.169698 1.49077 0.124957 1.713 0.125002 1.93747V12.0625C0.124513 12.3738 0.214398 12.6787 0.383752 12.94C0.539399 13.1874 0.755121 13.3914 1.01083 13.5331C1.26655 13.6747 1.55394 13.7493 1.84625 13.75H12.5338C12.901 13.7591 13.2613 13.6482 13.5597 13.434C13.8582 13.2198 14.0786 12.914 14.1875 12.5631L15.7963 7.5006C15.8737 7.24999 15.8916 6.98479 15.8487 6.72603C15.8057 6.46728 15.703 6.22211 15.5488 6.00997ZM1.25 1.93747C1.24986 1.86067 1.26545 1.78466 1.29581 1.71412C1.32616 1.64358 1.37064 1.58 1.4265 1.5273C1.48236 1.4746 1.54842 1.4339 1.62061 1.4077C1.6928 1.3815 1.76959 1.37036 1.84625 1.37497H4.90625C5.04449 1.37496 5.1789 1.42042 5.28875 1.50435L7.53875 3.25935C7.84457 3.49643 8.22055 3.62505 8.6075 3.62497H12.2525C12.3292 3.62036 12.406 3.6315 12.4781 3.6577C12.5503 3.6839 12.6164 3.7246 12.6723 3.7773C12.7281 3.83 12.7726 3.89358 12.8029 3.96412C12.8333 4.03466 12.8489 4.11068 12.8488 4.18747V5.31247H3.84875C3.48433 5.30701 3.12794 5.41968 2.83288 5.63362C2.53782 5.84756 2.31996 6.15128 2.21188 6.49935L1.25 9.55372V1.93747ZM14.75 7.1631L13.1413 12.2256C13.1051 12.3452 13.0303 12.4493 12.9284 12.5216C12.8266 12.594 12.7035 12.6303 12.5788 12.625H1.89125C1.76439 12.6247 1.64068 12.5854 1.53688 12.5125L3.33688 6.83685C3.37299 6.71727 3.44787 6.61312 3.54972 6.54081C3.65156 6.46849 3.77458 6.43214 3.89938 6.43747H14.1538C14.2485 6.43681 14.3422 6.45835 14.4271 6.50035C14.5121 6.54235 14.5861 6.60365 14.6431 6.67935C14.6967 6.74647 14.7342 6.82497 14.7527 6.90882C14.7712 6.99267 14.7703 7.07965 14.75 7.1631Z" fill="black"/>\n</svg>\n';

  // src/lib/file-structure.ts
  var icons = {
    dark: {
      file: file_white_default,
      folder: {
        open: folder_open_white_default,
        closed: folder_closed_white_default
      }
    },
    light: {
      file: file_black_default,
      folder: {
        open: folder_open_black_default,
        closed: folder_closed_black_default
      }
    }
  };
  var svgToInline = (svg) => `data:image/svg+xml;base64,${Buffer.from(svg, "utf8").toString("base64")}`;
  var TreeFile = ({ name }, theme) => {
    return div(
      { className: `${classNames.FILE} ${classNames.TREE_ITEM}` },
      img({
        src: svgToInline(icons[theme].file)
      }),
      div(null, name)
    );
  };
  function changeOpened(theme, event) {
    const folderHeader = event.target.classList.contains("folder-header") ? event.target : event.target.parentElement;
    const opened = folderHeader.getAttribute("opened") == "true";
    const newOpened = !opened;
    folderHeader.children[0].attributes.src.value = svgToInline(
      newOpened ? icons[theme].folder.open : icons[theme].folder.closed
    );
    try {
      const sibling = folderHeader.nextElementSibling;
      if (newOpened) {
        sibling.classList.remove("hide");
      } else {
        sibling.classList.add("hide");
      }
    } catch (e) {
      console.warn(`No sibling of elem ${folderHeader} found ...`);
    }
    folderHeader.setAttribute("opened", newOpened);
  }
  var TreeFolder = (props, theme, ...children) => {
    const opened = props.opened || false;
    const folderIcon = icons[theme].folder[opened ? "open" : "closed"];
    const folderName = props.name || "unknown";
    return div(
      { className: classNames.FOLDER_CONTAINER },
      div(
        {
          onClick: changeOpened.bind(void 0, theme),
          className: `folder-header ${classNames.FOLDER} ${classNames.TREE_ITEM}`,
          opened
        },
        img({
          src: svgToInline(folderIcon)
        }),
        div(null, folderName)
      ),
      div({ className: `${opened ? "" : "hide"} folder-content` }, ...children)
    );
  };

  // src/lib/index.ts
  src_default(core_default);
  var SOURCES_REGISTRY = "EQD-BJSVUJviud_Qv7Ymfd3qzXdrmV525e3YDzWQoHIAiInL";
  function toSha256Buffer(s) {
    const sha = new import_sha256_js.Sha256();
    sha.update(s);
    return Buffer.from(sha.digestSync());
  }
  function defaultIpfsConverter(ipfs) {
    return ipfs.replace("ipfs://", "https://tonsource.infura-ipfs.io/ipfs/");
  }
  var _ContractVerifier = {
    getSourcesJsonUrl: function(codeCellHash, options) {
      return __async(this, null, function* () {
        var _a, _b;
        const tc = new import_ton.TonClient({
          endpoint: (_a = options == null ? void 0 : options.httpApiEndpoint) != null ? _a : yield (0, import_ton_access.getHttpEndpoint)(),
          apiKey: options == null ? void 0 : options.httpApiKey
        });
        const { stack: sourceItemAddressStack } = yield tc.callGetMethod(
          import_ton.Address.parse(SOURCES_REGISTRY),
          "get_source_item_address",
          [
            [
              "num",
              new import_bn.BN(toSha256Buffer((_b = options == null ? void 0 : options.verifier) != null ? _b : "orbs.com")).toString()
            ],
            ["num", new import_bn.BN(Buffer.from(codeCellHash, "base64")).toString(10)]
          ]
        );
        const sourceItemAddr = import_ton.Cell.fromBoc(
          Buffer.from(sourceItemAddressStack[0][1].bytes, "base64")
        )[0].beginParse().readAddress();
        const isDeployed = yield tc.isContractDeployed(sourceItemAddr);
        if (isDeployed) {
          const { stack: sourceItemDataStack } = yield tc.callGetMethod(
            sourceItemAddr,
            "get_source_item_data"
          );
          const contentCell = import_ton.Cell.fromBoc(
            Buffer.from(sourceItemDataStack[3][1].bytes, "base64")
          )[0].beginParse();
          const version = contentCell.readUintNumber(8);
          if (version !== 1)
            throw new Error("Unsupported version");
          const ipfsLink = contentCell.readRemainingBytes().toString();
          return ipfsLink;
        }
        return null;
      });
    },
    getSourcesData: function(sourcesJsonUrl, ipfsConverter) {
      return __async(this, null, function* () {
        ipfsConverter = ipfsConverter != null ? ipfsConverter : defaultIpfsConverter;
        const ipfsHttpLink = ipfsConverter(sourcesJsonUrl);
        const verifiedContract = yield (yield fetch(ipfsConverter(sourcesJsonUrl))).json();
        const files = (yield Promise.all(
          verifiedContract.sources.map(
            (source) => __async(this, null, function* () {
              const url = ipfsConverter(source.url);
              const content = yield fetch(url).then((u) => u.text());
              return {
                name: source.filename,
                content,
                isEntrypoint: source.isEntrypoint,
                type: source.type
              };
            })
          )
        )).reverse().sort((a, b) => {
          if (a.type && b.type) {
            return Number(b.type === "code") - Number(a.type === "code");
          }
          return Number(b.isEntrypoint) - Number(a.isEntrypoint);
        });
        return {
          files,
          verificationDate: new Date(verifiedContract.verificationDate),
          compilerSettings: verifiedContract.compilerSettings,
          compiler: verifiedContract.compiler,
          ipfsHttpLink
        };
      });
    }
  };
  var classNames = {
    CONTAINER: "contract-verifier-container",
    FILES: "contract-verifier-files",
    FILE: "contract-verifier-file",
    FOLDER: "contract-verifier-folder",
    TREE_ITEM: "contract-verifier-tree-item",
    FOLDER_CONTAINER: "contract-verifier-folder-container",
    CODE_CONTAINER: "contract-verifier-code",
    CODE_LINES: "contract-verifier-code-lines",
    CODE_CONTENT: "contract-verifier-code-content"
  };
  var _ContractVerifierUI = {
    _stylesPopulated: {
      internal: false
    },
    _populateStyle: function(theme) {
      if (!this._stylesPopulated[theme]) {
        this._stylesPopulated[theme] = true;
        const styleEl = document.createElement("style");
        styleEl.innerHTML = `${theme === "light" ? require_().toString() : require_2().toString()}`;
        document.head.appendChild(styleEl);
      }
      if (!this._stylesPopulated.internal) {
        this._stylesPopulated.internal = true;
        const styleEl = document.createElement("style");
        styleEl.innerHTML = _default;
        document.head.appendChild(styleEl);
      }
    },
    _populateCode: function(contentSelector, theme) {
      const codeContainer = document.querySelector(contentSelector);
      codeContainer.classList.add(classNames.CODE_CONTAINER);
      codeContainer.innerHTML = `<pre><code class="${theme}"></code></pre>`;
    },
    _setCode: function({ name, content }, codeWrapperEl, filesListEl, fileEl) {
      var _a;
      if (fileEl == null ? void 0 : fileEl.classList.contains("active"))
        return;
      codeWrapperEl.scrollTo(0, 0);
      content = content.trim();
      const codeEl = codeWrapperEl.querySelector("code");
      codeEl.innerHTML = "";
      codeEl.appendChild(
        div(
          { className: classNames.CODE_LINES },
          content.split("\n").map((_, i) => i + 1).join("\n")
        )
      );
      const contentEl = div({ className: classNames.CODE_CONTENT }, content);
      codeEl.appendChild(contentEl);
      if (name.match(/\.fif(t)?$/)) {
        contentEl.classList.add("language-fift");
      } else {
        contentEl.classList.add("language-func");
      }
      core_default.highlightElement(contentEl);
      (_a = filesListEl == null ? void 0 : filesListEl.querySelector(`.${classNames.FILE}.active`)) == null ? void 0 : _a.classList.remove("active");
      fileEl == null ? void 0 : fileEl.classList.add("active");
    },
    setCode: function(contentSelector, content) {
      this._setCode(
        { name: "", content },
        document.querySelector(contentSelector)
      );
    },
    _populateFiles: function(fileListSelector, contentSelector, files, theme) {
      const filePart = document.querySelector(fileListSelector);
      filePart.innerHTML = "";
      filePart.classList.add(theme);
      filePart.classList.add(classNames.FILES);
      const root = {
        type: "root",
        children: []
      };
      files.forEach((file) => {
        const nameParts = Array.from(
          file.name.matchAll(/(?:\/|^)([^\/\n]+)/g)
        ).map((m) => m[1]);
        const folders = nameParts.length > 1 ? nameParts.slice(0, nameParts.length - 1) : [];
        let levelToPushTo = root;
        folders.forEach((folder) => {
          let existingFolder = levelToPushTo.children.find(
            (obj) => obj.type === "folder" && obj.name === folder
          );
          if (!existingFolder) {
            const newLevel = {
              type: "folder",
              name: folder,
              children: []
            };
            levelToPushTo.children.push(newLevel);
            existingFolder = newLevel;
          }
          levelToPushTo = existingFolder;
        });
        levelToPushTo.children.push({
          type: "file",
          name: nameParts[nameParts.length - 1],
          content: file.content
        });
      });
      function processLevel(level) {
        return level.children.filter((obj) => obj.type === "file").map((child) => {
          const file = TreeFile({ name: child.name }, theme);
          file.onclick = () => {
            ContractVerifierUI._setCode(
              { name: child.name, content: child.content },
              document.querySelector(contentSelector),
              document.querySelector(fileListSelector),
              file
            );
          };
          return file;
        }).concat(
          level.children.filter((obj) => obj.type === "folder").map(
            (child) => TreeFolder(
              { name: child.name, opened: true },
              theme,
              ...processLevel(child)
            )
          )
        );
      }
      processLevel(root).forEach((el) => filePart.appendChild(el));
    },
    _populateContainer: function(selector, hideLineNumbers, layout) {
      const el = document.querySelector(selector);
      el.classList.add(classNames.CONTAINER);
      if (layout === "column") {
        el.classList.add("column");
      }
      if (!hideLineNumbers) {
        el.classList.add("lineNumbers");
      }
    },
    loadSourcesData: function(sourcesData, opts) {
      this._populateContainer(
        opts.containerSelector,
        !!opts.hideLineNumbers,
        opts.layout
      );
      if (opts.fileListSelector) {
        this._populateFiles(
          opts.fileListSelector,
          opts.contentSelector,
          sourcesData.files,
          opts.theme
        );
      }
      this._populateStyle(opts.theme);
      this._populateCode(opts.contentSelector, opts.theme);
      this._setCode(
        sourcesData.files[0],
        document.querySelector(opts.contentSelector),
        document.querySelector(opts.fileListSelector),
        document.querySelector(`${opts.fileListSelector} .contract-verifier-file`)
      );
    }
  };
  var ContractVerifier = _ContractVerifier;
  var ContractVerifierUI = _ContractVerifierUI;

  // src/lib/web.ts
  window.ContractVerifier = ContractVerifier;
  window.ContractVerifierUI = ContractVerifierUI;
})();
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
//# sourceMappingURL=index.js.map
